[{"title":"hello","date":"2022-03-29T16:44:19.000Z","url":"/2022/03/30/hello/","categories":[["undefined",""]],"content":""},{"title":"iproute2 中 tc qdisc cbs源码分析","date":"2022-03-29T14:27:26.000Z","url":"/2022/03/29/iproute2-%E4%B8%AD-tc-qdisc-cbs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","tags":[["linux","/tags/linux/"],["source code","/tags/source-code/"],["setup_arch","/tags/setup-arch/"]],"categories":[["内核分析","/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"]],"content":"iproute2 用户空间Sched 与 iproute2 的通信，是典型的 Linux 内核模块和用户空间的进程之间的通信，这 种通信一般由 Netlink Socket 来提供这种双向的通信连接。这种连接由标准的提供给用户进程的 socket 和提供给内核模块的 API 组成，用户空间的接口简单的说就是创建一个 family 为 AF_NETLINK 的 socket，然后使用这个 socket 进行通信。 rtnl_open() 函数的作用是打开一个AF_NETLINK 的 socket，rtnl_close() 函数的作用是关闭一个AF_NETLINK 的 socket。 用户空间通信前的准备：填充 netlink 包；然后把 netlink 包发送到内核空间去。 tc.c 通过cbs_qdisc_util→cbs_parse_opt调用 q_cbs.c 中的cbs_parse_opt()函数。 q_cbs.c 最后通过rtnl_talk(&amp;rth, &amp;req.n, NULL)把 netlink 包发送到内核空间去，rtnl_talk()发送过程包括 sendmsg 和 recvmsg。 内核模块的初始化内核模块的初始化：在 net/sched/sch_api.c 文件中的 void __init pktsched_init (void)函数中，初始化了 link_rtnetlink_table 表，link_rtnetlink_table 是一张 struct rtnetlink_link的表。 struct rtnetlink_link 由函数指针 doit 和 dumpit 组成，这张表可以由需要执行的动作的宏定义 （例如：RTM_NEWQDISC，RTM_DELQDISC）来索引，以使得能通过这张表调动相应的函数。内核模块从用户空间收到的就是这些索引和参数，以此调用注册在此表中的函数。 在qdisc_create()中的opt→init调用sch_cbs.c的cbs_init()初始化函数。 sch_cbs.c gdb调试过程tc部分分析 设置断点。main()—&gt;do_cmd()—&gt;do_qdisc()—&gt;tc_qdisc_modify() tc_qdisc_modify() 首先解析参数eth1 …… cbs 找到cbs_qdisc_util 通过addttr_l()添加k到NETLINK包里。 执行cbs_qdisc_util→parse_qopt 通过cbs_parse_opt()解析参数idleslope …… offload 1 通过addattr_l()添加到NETLINK包里。 与内核通信。 此时内核运行完打印消息 rtnl_close()结束与内核的通信 内核部分 net&#x2F;sched&#x2F;sch_api.c断到tc_modify_qdisc()函数。 进入ops→init 解析到cbs_init()函数，初始化。 进入cbs_change() —&gt; csb_enable_offload() ops→ndo_setup_tc()开始进入驱动部分。 gmac网卡驱动部分调用stmmac_tc_setup_cbs() 在stmmac_config_cbs()中对寄存器进行读写配置。 对CBS相关的DMA寄存器进行读写操作。 "},{"title":"setup_arch()源码分析","date":"2021-10-31T13:52:05.000Z","url":"/2021/10/31/setup-arch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","tags":[["linux","/tags/linux/"],["source code","/tags/source-code/"],["setup_arch","/tags/setup-arch/"]],"categories":[["内核分析","/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"]],"content":"setup_arch()start_kernel()中第一个重要的、体系结构密切相关的函数是 setup_arch()，定义在 arch/loongarch/kernel/setup.c中。 cpu_probe()用来探测 CPU 类型、ID号、版本等等。探测的主要依据是 PRID 寄存器，即协处理器 0 中的 15 号寄存器。PRID 是一个 32 位寄存器，最高 8 位保留，次高 8 位是公司 ID，第三个 8 位是处理器 ID，最后一个 8 位是修订号 ID。 early_init() fw_init_cmdline()：还记得 kernel_entry 里面保存的 fw_arg0～fw_arg3 这几个变量吗？现在就要开始用了。prom_init_cmdline()中处理前两个变量，其中 fw_arg0 是参数的个数，fw_arg1 是参数的字符串数组。这个函数建立来自 BIOS 或 BootLoader 的内核命令行参数，以便给后面start_kernel()中的setup_command_line() 进 一 步 处 理 。 fw_init_environ()：用于初始化环境变量，环境变量来源于 fw_arg2。引入了类似于 UEFI 的 LEFI 接口，fw_arg2 仅仅提供一个地址，该地址指向 BIOS 中的一片数据区，数据区有着特定的结构，可以通过它获得丰富的接口信息。LEFI 接口规范所使用的各种数据结果定义在 arch/loongarch/include/asm/mach-loongson64/boot_param.h 中。 early_memblock_init()：对boot_param.h里定义声明的内存分布图进行初始化。 通常情况下我们使用的是支持 NUMA 的版本，它首先初始化 NUMA 节点的距离矩阵，然后逐个解析内存分布图并将最终结果保存于 loongson_memmap。 Others bootcmdline_init(cmdline_p)：启动命令行的初始化； init_initrd()：初始化临时根文件系统，如果正常，则使用它们； Linux初始RAM磁盘（initrd）是在系统引导过程中挂载的一个临时根文件系统，用来支持两阶段的引导过程。 initrd文件中包含了各种可执行程序和驱动程序，它们可以用来挂载实际的根文件系统，然后再将这个 initrd RAM磁盘卸载，并释放内存。 platform_init()：控制台相关初始化 finalize_initrd():将 initrd&#x2F;initramfs 所在的内存段设置为保留。 cpu_report() arch_mem_init(char *cmdline_p) sparse_init()：即稀疏内存模型初始化。内存模型指的是物理地址空间分布的模型，Linux 内核支持三种内存模型：平坦模型，非连续模型和稀疏模型。包括龙芯在内的现代体系结构大都采用了比较自由的稀疏模型。如果不采用稀疏模型，sparse_init()是空操作；如果采用稀疏模型，sparse_init()会初始化一些稀疏模型专有的数据结构（如全局区段描述符数组 mem_section[]及其附带的页描述符数组）。 plat_swiotlb_setup()：定义在 arch/loongarch/loongson64/dma.c 中。先我们简单介绍一下 SWIOTLB，这是一种 DMA API。龙芯 3 号的访存能力是 48 位，但是由于芯片组或者设备本身的限制，设备的访存能力往往没有这么大。比如龙芯的顶级 I&#x2F;O 总线（HT 总线）位宽只有 40 位，一部分 PCI 设备的访存能力只有 32 位，而 ISA&#x2F;LPC 设备的访问能力甚至只有 24 位。为了让任意设备能够对任意内存地址发起 DMA 访问，就必须在硬件上设置一个“DMA 地址-物理地址”翻译表，或者由内核在设备可访问的地址范围内预先准备一块内存做中转站。许多 X86 处理器在硬件上提供翻译表，称为 IOMMU；龙芯没有IOMMU，于是提供了软件中转站，也就是 SWIOTLB。plat_swiotlb_setup()调用 swiotlb_init()初始化 SWIOTLB 的元数据并在 32 位地址范围内分配中转缓冲区（缺省为 64MB），然后注册了一个 DMA API 操作集 loongson_linear_dma_map_ops。操作集里面的“物理地址-DMA地址”转换函数（即 loongson_linear_dma_map_ops 中的 phys_to_dma 和 dma_to_phys 两个函数指针）是同芯片组相关的： Others resource_init() plat_smp_setup() prefill_possible_map()：它会建立合理的逻辑 CPU 的 possible 值。prefill_possible_map()会通过 set_cpu_possible()来更新 cpu_possible_mask，最后将 possible 值赋给全局变量 nr_cpu_ids。 cpu_cache_init() 在龙芯处理器手册中，将 P-Cache 称之为一级 Cache，将 V-Cache 称之为二级 Cache，将 S-Cache 称之为三级 Cache。 r4k_cache_init()通过调用 probe_pcache()、probe_vcache()和 setup_scache()完成各级 Cache的容量、行大小和相联度探测。然后给各个 Cache 刷新操作函数赋值（刷新即 Flush，对于指令 Cache 指的是作废，对于数据 Cache 指的是写回并作废）。 page_init()该函数初始化各个内存页面管理区（Zone）。页面管理区的类型包括 ZONE_DMA、ZONE_DMA32、ZONE_NORMAL 和 ZONE_HIGHME几种。ZONE_DMA 区包括所有物理地址为小于 16MB 的页面，设置这个区的目的是为ISA&#x2F;LPC 等 DMA 能力只有 24 位地址的设备服务。ZONE_DMA32 区包括所有 ZONE_DMA区之外的物理地址小于 4GB 的页面，设置这个区的目的是为 DMA 能力只有 32 位地址的 PCI设备服务。设置 ZONE_HIGHMEM 的目的是为物理地址超过线性地址表达能力的内存服务：对于 32 位的 MIPS 内核，线性地址表达能力只有 512M，因此 512M 以外的页面被放置到ZONE_HIGHMEM 区；对于 64 位的 MIPS 内核，物理地址暂时还没有超过线性地址的表达能力，因此通常不设置 ZONE_HIGHMEM 区。ZONE_NORMAL 区则包括了上述几个区以外的所有页面。在初始化每个 Zone 的时候，会调用 init_page_count()将每个页帧的初始引用计数设置为 1。因为此时此刻内存还处于 BootMem 管理器的控制下，这些页帧尚未转交到伙伴系统（内存页帧管理器），不是自由页帧（自由页帧的引用计数为 1），不可以被伙伴系统的页帧分配函数分配。 boot_cpu_trap_init() vec_size：向量大小 eentry：通用例外入口地址 tlbrentry：tlb refill例外入口地址 configure_exception_vector()：配置例外向量 tlb_init()：主要做的事就是handle_tlb_refill handle_tlb_refill TLBMISS_HANDLER_SETUP()：主要工作是建立内核页全局目录的基地址。 trap_init()其余的例外在start_kernel()中的trap_init()中。 trap_init() except_vec_vi_handler：32位LOONGARCH 中断请求相关start_kernel()中的init_IRQ() 调用arch_init_irq() setup_IRQ()：这一步的主要工作就是初始化通过 Device-Tree描述的中断控制器（即“IRQ 芯片”，数据结构用 irq_chip 描述）。 "},{"title":"内核启动过程分析","date":"2021-10-30T10:37:14.000Z","url":"/2021/10/30/%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/","tags":[["linux","/tags/linux/"],["source code","/tags/source-code/"],["start_kernel","/tags/start-kernel/"]],"categories":[["内核分析","/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"]],"content":"kernel_entry→start_kernel()vmlinux原始内核启动：内核的初始启动入口是位于arch&#x2F;loongarch&#x2F;kernel&#x2F;head.S中的kernel_entry → start_kernel() vmlinuxz压缩版内核启动：在解压前真正的执行入口是arch&#x2F;loongarch&#x2F;boot&#x2F;compressed&#x2F;head.S中的start →kernel_entry→start_kernel() 执行decompress_kernel()进行自解压，解压内容释放到内存里面形成一个原始内核。 第一入口：kernel_entry 通过一个循环来清零.bss 段中的全局数据； 将 a0～a3 寄存器中的值保存到 fw_arg0～fw_arg3四个内存变量，这四个变量包含 BIOS 或者引导程序传递给内核的参数； 配置DMWIN0和DMWIN1映射窗口地址； 打开PG&#x3D;1； 进行CPU类型相关的初始化； 使用init_thread_union的地址来初始化GP寄存器，GP是全局指针； 初始化SP寄存器，SP是堆栈指针； 最后的 b start_kernel 是跳转到第二入口处继续执行，第二入口即 start_kernel()函数； 处理器0的Status寄存器 IE：全局中断使能位，为 1 表示开中断，为 0 表示关中断； EXL：异常级别指示，为 1 表示 CPU 处于异常模式，异常模式表示发生了除复位、NMI和 Cache 错误以外的某种异常。 ERL：错误级别指示，为 1 表示 CPU 处于错误模式，错误模式表示发生了复位、NMI或者 Cache 错误之类的某种异常。 KSU：特权模式位：为 0 表示 CPU 处于核心态（内核态），为 1 表示 CPU 处于管理态，为 2 表示 CPU 处于用户态，为 3 表示未定义。核心态权限最高，可以执行任意指令（特权指令和非特权令），可以访问任意地址空间（核心空间、管理空间和用户空间）；管理态权限居中，不能执行特权指令，能访问管理地址空间和用户地址空间；用户态权限最低，不能执行特权指令，只能访问用户地址空间。另外，当 EXL 或者 ERL 置位时，不管 KSU 如何取值，CPU 自动处于核心态。 UX：为 1 表示启用 64 位用户地址空间段； SX：为 1 表示启用 64 位管理地址空间段； KX：为 1 表示启用 64 位核心地址空间段； IM7~IM0：中断掩码位，MIPS 在 CPU 层面一共有 8 个中断源，分别有 8 个掩码位与之对应，为 1 的位表示允许该中断触发，为 0 的位表示禁止该中断触发； NMI：为 1 表示发生了 NMI（不可屏蔽中断）； SR：为 1 表示发生了软件复位；BEV：控制异常向量的入口，为 1 表示使用启动时异常向量入口，为 0 表示使用运行时异常向量入口； PX：为 1 表示在用户态使能 64 位操作数指令（如 daddu、dsubu 等）； FR：浮点协处理器模式切换，为 1 表示有 32 个双精度浮点寄存器可用，为 0 表示只有16 个双精度浮点寄存器可用； CU3~CU0：标识四个协处理器是否可用，协处理器 0（CP0）是系统控制协处理器，在所有 MIPS 处理器上总是可用的；协处理器 1（CP1）通常是浮点协处理器（FPU），在所有龙芯处理器上总是可用的；协处理器 2（CP2）在龙芯 3 号上总是可用的，表示多媒体指令协处理器。 龙芯 3 号总是使用 64 位内核，所以 setup_c0_status_pri 实际上就是设置当前模式为内核态模（KSU），启用内核的 64 位地址段访问能力（KX），启用系统控制协处理器（CU0），启用多媒体指令协处理器（CU2），清除异常状态并禁止中断（清零 EXL、ERL、IE）。BEV等位保持 BIOS 设置的原值（内核尚未建立运行时异常向量）。 init_thread_union相关在 Linux 中，进程和线程都是运行的程序实体，进程有独立的地址空间，若干个线程共享同一个地址空间；也就是说，线程是一种特殊的进程。Linux 中线程的容器并不是进程，而是线程组。例如：一个运行中的多线程程序是一个线程组，里面包含多个线程；一个运行中的单线程程序也是一个线程组，里面包含一个线程。单线程程序的那个唯一线程，就是一般意义上的进程。内核本身也可以视为一个特殊的进程，它可以派生出很多共享地址空间的内核线程，因此这个拥有许多线程的内核又可以视为一个特殊的线程组。 线程相关的数据结构： 每一个进程（包括普通进程和内核线程）用一个进程描述符 task_struct 表示；每一个进程都有一个体系结构相关的线程信息描述符，即 thread_info；每一个进程都有一个内核态栈，用于处理异常、中断或者系统调用。Linux 内核为每个进程分配一个大小为 THREAD_SIZE的内存区（大小通常就是一个页面），把 thread_info 和内核栈放在一起，即 thread_union。 thread_union 地址从低处开始往上是 thread_info，从高处开始往下是内核栈，task_struct 中的stack 指针指向 thread_union。这里的 init_task 就是 Linux 中 0 号进程的 task_struct，0 号进程一开始就是内核自身，在完成启动初始化以后，变身为 Idle 进程（空闲进程）。 第二入口：start_kernel()init&#x2F;main.c 虽然这棵树很庞大，但我们大致可以将整个 start_kernel()的过程分为三个大的阶段：关中断单线程阶段（从 start_kernel()头部开始直到 local_irq_enable()结束）；开中断单线程阶段（从local_irq_enable()开始直到 rest_init()前夕）；开中断多线程阶段（rest_init()的整个过程）。 第一阶段：关中断单线程阶段启动初期的初始化过程必须关中断进行（中断处理的基础设施尚未准备好），所以start_kernel()开始执行不久之后就通过 local_irq_disable()来关闭中断。 boot_cpu_init()，这个函数是设置启动 CPU（通常是 0 号 CPU）的存在性状态。 一个逻辑 CPU 有四种存在性状态：possible，表示物理上有可能存在；present，表示物理上确实存在；online，表示已经在线；active，表示已经在线并且处于活动状态。possible 和 present 的区别跟 CPU 物理热插拔有关，如果物理上移除一个 CPU，present 数目就会减少一个。present 和online 的区别是CPU 逻辑热插拔，在不改变硬件的情况下，可以对 &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpuN&#x2F;online 写 0来关闭一个 CPU，写 1 则重新打开。online 和 active 非常相似，前者表示这个 CPU 可以调度任务了，后者表示可以往这个 CPU 迁移任务了。两者的区别在于，在通过逻辑热插拔关闭一个 CPU 的过程中，被关闭的 CPU 首先必须退出 active 状态，然后才能退出 online 状态。 整个 boot_cpu_init()的功能，就是将启动核（在龙芯上面就是 0 号核）的状态设置成 possible 的，present 的，online 的并且是 active 的。 然后是一个重要函数 setup_arch()，这是根据体系结构进行相关的初始化，LOONGARCH的setup_arch()定义在 arch&#x2F;loongarch&#x2F;kernel&#x2F;setup.c 中。 接下来的 trap_init()异常初始化，这个函数都是体系结构相关的并且非常重要。 setup_command_line()，建立内核命令行参数。内核命令行参数可以写在启动配置文件（boot.cfg 或 grub.cfg）中，由 BIOS 或者启动器（BootLoader，如 Grub）传递给内核；或缺省参数。 setup_nr_cpu_ids()，它获取 cpu_possible_mask 中的最大 CPU 编号（所有 possible 状态的逻辑 CPU 的最大编号），并将其赋值给全局变量 nr_cpu_ids。 setup_per_cpu_areas()，建立每 CPU 变量区，每 CPU 变量用 DEFINE_PER_CPU(type, name)语句定义，在功能上等价于用 type name[NR_CPUS]定义一个数组。 smp_prepare_boot_cpu()是一个体系结构相关的函数，在 LOONGARCH 上主要是把 0 号逻辑 CPU设成 possible 的和 online 的，该函数在功能上和 boot_cpu_init()有所重复。 接下来的 trap_init()异常初始化，这个函数都是体系结构相关的并且非常重要。 随后的 mm_init()是内存管理初始化。体系结构相关的内存管理部分已经在 setup_arch()里面完成（其中会将 BIOS 传递的固件内存分布图转换成 BootMem 内存分布图），这里主要是调用mem_init()建立内存分布图（将 BootMem 内存分布图转换为伙伴系统的内存分布图，对其中的每个可用的页帧调用set_page_count()将其引用计数设为0），调用kmem_cache_init()完成 SLAB 内存对象管理器的初始化，以及调用 vmalloc_init()完成非连续内存区管理器的初始化。 sched_init()，调度器初始化，完成以后主核就可以进行任务调度了。sched_init()会通过for_each_possible_cpu()迭代器在初始化每个 CPU 的运行队列（运行队列 rq 用于进程组织和调度），其中包括将 CPU 负载水平（即 rq-&gt;cpu_load[]数组，记录了最近 5 个时钟节拍内的CPU 平均负载水平）初值设为 0。接下来，sched_init()里面还有几个比较重要的步骤就是对init_task 的操作：init_task 的大部分成员字段已经通过 INIT_TASK()在定义的时候就初始化好了，这里只需调用 set_load_weight()设置 init_task 的负荷权重（负荷权重跟基于优先级的进程调度有关，详见第 6 章），将其调度类设为 fair_sched_class（公平调度类，使用 CFS 调度策略对其进行调度），再调用 init_idle()将内核自己进程化（准备工作完成后，调度类会被重新设置为 idle_sched_class，使用专门的 IDLE 调度策略）。从现在开始内核也是一个“进程”了，即零号进程。 rcu_init()，RCU 是一种内核同步原语，全称 Read-Copy-Update（读-复制-更新），和自旋锁、信号量、读写锁等同步原语有类似的 API，但 RCU 本身并不是锁。 early_irq_init()，初始化中断描述符。中断描述符就是 irq_desc[NR_IRQS]数组，包含了每个中断号（IRQ）的芯片数据 irq_data 和中断处理程序 irqaction 等各种信息。本函数只是设置缺省信息，比如芯片数据都设成 no_irq_chip ，中断处理程序都设成handle_bad_irq()。真正有意义的信息由后面体系结构相关的 init_IRQ()函数完成。 init_timers()，基本定时器初始化；hrtimers_init()，高分辨率定时器初始化。 softirq_init()，软中断初始化。软中断和硬中断的概念来自于早期内核中的“上半部”和“下半部”。上半部是中断处理里面非常紧急、必须立即完成的那部分工作；下半部是不那么紧急，可以延迟完成的那部分工作。软中断在概念上基本上就是继承自下半部。当前内核中定义了 11 种软中断（优先级从高到低）： SCHED_SOFTIRQ 在之前的 sched_init()里面进行初始化，RCU_SOFTIRQ 在之前的rcu_init()里面进行初始化，TIMER_SOFTIRQ 和 HRTIMER_SOFTIRQ 在之前的 init_timers(和 hrtimers_init()中进行初始化，本函数主要完成 HI_SOFTIRQ 和 TASKLET_SOFTIRQ 的初始化，其他类型的软中断分布在各自的子系统里面完成。 timekeeping_init()，timekeeping 的意思是系统时间维护。该函数的作用主要是初始化各种时间相关的变量，如 jiffies，xtime 等等。Jiffies 记录了系统启动以来所经历的节拍数，而xtime 记录的时间可以精确到纳秒。随后的 time_init()是一个体系结构相关的函数，会进一步初始化计时系统。 PerfEvents 和 OProfile 是 Linux 内核中的两种性能剖析工具，perf_event_init()和profileinit()分别完成其初始化。 中断有关的初始化都已经完成，现在可以开中断了。开中断的函数是 local_irq_enable()，对于 LOONGARCH 来讲就是设置协处理器 0 中 Status 寄存器的 IE 位。 第二阶段：开中断单线程阶段第二阶段中断已经打开，所以虽然现在内核还是以单线程的方式执行，但是一旦产生断就会切换控制流。因此，这一阶段除了按顺序执行代码流程以外，还可能以交错方式执行中断处理的代码。 console_init()，控制台初始化。 numa_policy_init()，NUMA 内存分配策略初始化。 calibrate_delay()，用于计算 loops_per_jiffy 的值。loops_per_jiffy 的含义是每个时钟节拍对应的空循环数，这个值用于以后实现各种 delay()类的忙等函数。 fork_init()，Linux 用 fork()系统调用来创建新进程。本函数的作用是初始化 fork()所用到的一些数据结构，如创建名为”task_struct”的 SLAB 内存对象缓存，将最大线程数设置为MAXTHREADS，等等。 signals_init()，跟信号相关的数据结构初始化。信号之于进程，好比中断之于内核，用于打断当前的执行流程，去完成一些更重要的工作。 cgroup_init()，CGroup 全称 Contol Group，即控制组，是内核一种控制资源分配的机制。本函数完成控制组相关数据结构的初始化，并且创建相应的 sysfs 和 procfs 节点。 现在，所有调度有关的子系统已经全部初始化完成，接下来可以创建新的内核线程，以并发的方式继续内核启动了。因为显卡尚未初始化，所以第二阶段显示器上依然没有输出信息。 第三阶段：开中断多线程阶段rest_init()，顾名思义，第三阶段就是余下的初始化工作任务。函数 rest_init()的主要工作是通过 kernel_thread()创建了 1 号进程 kernel_init 和 2 号进程 kthreadd（实际上是两个内核线程）。1 号进程的执行体函数是 kernel_init()，它完成接下来的大部分初始化工作。2 号进程则是除 0、1、2 号进程以外其他所有内核线程的祖先（如果 1号进程在运行过程中需要创建新的内核线程，会委托 2 号进程来创建）。 1 号进程和 2 号进程创建以后，内核自己的初始化工作就基本完成了。但是别忘了，内核自己是 0 号进程，因此它也有必须持续进行的“工作”。内核初始化的最后一步是执行 cpu_startup_entry()，而后者的主要工作是调用cpu_idle_loop()。从名字可以看出，0 号进程现在成了空闲进程（即 IDLE 进程），它的工作就是“休息”（如果别的进程有事要做，就调度别的进程，反之意味着系统空闲，回到零号进程）。顺着调用链追踪下去，可以发现 0 号进程的核心过程是循环执行 arch_cpu_idle()，而具体到 LOONGARCH 处理器，则是 cpu_wait()。cpu_wait()可以有多种实现，一般就是执行 WAIT指令进入节能状态。 1 号进程与 2 号进程会派生很多新的内核线程来完成各种内核功能。在 SMP 系统上，1号进程会打开所有辅核，让后面的内核启动真正并行起来。包括显卡驱动在内的各种设备驱动都在 1 号进程里面完成，因此第三阶段除了起始点以外的的大部分时间是有显示信息输出的。 "},{"title":"状态机","date":"2021-10-26T04:12:13.000Z","url":"/2021/10/26/%E7%8A%B6%E6%80%81%E6%9C%BA/","tags":[["FSM","/tags/FSM/"]],"categories":[["基础概念","/categories/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"]],"content":"什么是状态机？状态机的全称是有限状态自动机，是现实事物运行规则抽象而成的一个数学模型。给定一个状态机，同时给定它的当前状态以及输入，那么输出状态时可以明确的运算出来的。 状态机四大概念下面来给出状态机的四大概念。 第一个是 State ，状态。一个状态机至少要包含两个状态。例如上面自动门的例子，有 open 和 closed 两个状态。 第二个是 Event ，事件。事件就是执行某个操作的触发条件或者口令。对于自动门，“按下开门按钮”就是一个事件。 第三个是 Action ，动作。事件发生以后要执行动作。例如事件是“按开门按钮”，动作是“开门”。编程的时候，一个 Action 一般就对应一个函数。 第四个是 Transition ，变换。也就是从一个状态变化为另一个状态。例如“开门过程”就是一个变换。 应用最后再来说说状态机的应用。状态机是一个对真实世界的抽象，而且是逻辑严谨的数学抽象，所以明显非常适合用在数字领域。可以应用到各个层面上，例如硬件设计，编译器设计，以及编程实现各种具体业务逻辑的时候。 来举个例子。街上的自动售货机中明显能看到状态机逻辑。我们做一下简化，假设这是一台只卖2元一瓶的汽水的售货机，只接受五毛和一块的硬币。初始状态是”未付款“，中间状态有”已付款5毛“，”已付款1块“，”已付款1.5块“，”已足额付款“，四个状态。状态切换的触发条件是”投一块硬币“和”投5毛硬币“两种，”到达足额付款“状态，还要进行余额清零和弹出汽水操作。所以如果画出一张完整的状态转换图，也会是比较复杂的一张图了。而实际中的售货机对应的状态机就会更加复杂了。 总之，状态机应用范围很广，这里就不展开了。插一句，跟状态机类似的概念还有图灵机，图灵机就是计算机底层采用的计算模型。 总结这就是对状态机概念的一个通俗的简述了。总结一下，状态机不是实际机器设备，而是一个数学模型，通常体现为一个状态转换图。涉及到的相关概念是 State 状态，Event 事件，Action 动作，Transition 转换。状态机是计算机科学的重要基础概念之一，也可以说是一种总结归纳问题的思想，应用范围非常广泛。"},{"title":"tlb异常处理","date":"2021-10-21T11:09:17.000Z","url":"/2021/10/21/tlb%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","tags":[["linux","/tags/linux/"],["tlbex","/tags/tlbex/"]],"categories":[["内核分析","/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"]],"content":"tlb异常相关的简要概述该内核源码为linux5.14中的32位loongarch架构下tlb异常相关部分。下面为相关部分的关键源代码和函数。 mm&#x2F;tlbex-32.S handle_tlb_load handle_tlb_store handle_tlb_modify heandle_tlb_refill kernel&#x2F;traps.c ebase eentry+0x4000 LOONGARCH_CSR_EENTRY 例外入口地址 0x200 * 32 &#x3D; 0x4000 tlbrentr vec_size &#x3D; 0x200 tlb_load *(0xa0210000 + 0x200) gdb调试: trap_init kerne&#x2F;geneX.S except_vec_vi_handler loongarch32&#x2F;irq.c plat_irq_dispatch 中断 0x800 时钟中断 arch&#x2F;loongarch&#x2F;mm&#x2F;tlb.c __update_tlb arch&#x2F;loongarch&#x2F;mm&#x2F;fault.c do_page_fault mm&#x2F;tlbex-32.S中handle_tlb_load函数 传入的BADV为0x0022614c。其中PGD为0xa24b7000，*0xa24b7000 &#x3D; 0xa24bc000。PTE基址 &#x3D; PGD基址 + PGD_OFFSET &#x3D; 0xa24bc000 + (0x000(10bits)&lt;&lt;2) &#x3D; 0xa24bc000该PTE基址 + PTE_OFFSET &#x3D; 0xa24bc000 + (0x226(10bits)&lt;&lt;2) &#x3D; 0xa24bc898 &#x3D; 包含物理页号、页状态位的物理地址将(*0xa24bc898)0xff3a09c的page_valid位置1，即改为0xff3a09d，其中0xff3a(高20bits为物理页号)tlb取0xa24bc898、0xa24bc89c两页表项按规则填入TLBLO0和TLBLO1中填入规则：31:12(PPN)→8:27(PPN)，7:0(page状态位)→7:0(page状态位)，最高4位清0 handle_tlb_load执行过程进入tlb_load过程时，首先保存现场(0x1213b8)，即执行csrwr，将r1的地址0x1213b8存到了0x32地址的内存处。 csrrd传入出错虚拟地址(BADV)0x2134d4到r12寄存器，0x2134d4比0xc0000000小，故继续顺序执行。 将PGD基址0xa23e1000传入r13寄存器，其内存的值为0xa23de000 先获取t0(BADV)0x002134d4的前10bits再偏移2位，得到PGD_OFFSET(0x000)，加上PGD(0xa23e1000)，存到r13寄存器，为0xa23e1000。 接着获取t0(0x002134d4)的中间10bits再偏移2位，得到PTE_OFFSET(213&lt;&lt;2 &#x3D; 0x84c)，最后加上t1寄存器内存处的值0xa23de000，得到地址0xa23de84c存到t0寄存器。 把r12内存处的值(*0xa23de84c&#x3D; 0)写入r13寄存器，再刷新tlb。 因为_PAGE_PRESENT为0(页不存在)，所以跳转到nopage_tlb_load处，即PC跳转到0xa02102b0处执行。 接着恢复现场(r1&#x3D;0x1213b8)，跳转到tlb_do_page_fault函数处执行。 第二次tlb_load: 继续(gdb) c之后，可以看到第二次触发tlb_load的BADV也为0x2134d4。 继续(gdb) si调试到PTE+PTE_OFFSET可以得到r12为0x23de84c，此时该内存地址中有值，为0xff2309c，存到r13寄存器。 0xff2309c的_PAGE_PRESENT(第8位，判断该页是否存在)为1，并将_PAGE_VALID(第1位，判断该页是否有效)置1，即0xff2309d，将0xff2309d写回r12寄存器的内存地址处(*0xa23de84c&#x3D;0xff2309d)。注意：该_PAGE_PRESENT、_PAGE_VALID都为页表的软件位，tlb只有硬件位。 由于tlb一次存取两页，其中第3位表示奇偶页。故将0xa23de848和0xa23de84c内存地址处的值（包含PPN、页表标志位的地址）按规则存入TLBLO0和TLBLO1中。由于TLBLO0寄存器的31:8位表示PPN，而页表31:12位表示PPN，故需要将该页表*0xa23de848的高20位PPN写入到TLBLO0寄存器的31:8位(其中高4位清0)，低8位标志位写入到TLBLO0寄存器的7:0位。所以TLBO0 &#x3D; ( t1 &gt;&gt;12 &lt;&lt; 8) | (t1 &amp; 0xff)。所以通过csrwr写入寄存器，TLBLO0寄存器按0xff229c写入 。TLBLO1寄存器按0xff239d写入，将旧值写回t0,t1。由于TLBLO0寄存器实际第8位只读恒为0，故第8位写忽略。 csrwr t0, LOONGARCH_CSR_TLBELO1 接着恢复现场，从例外处理现场返回。 总结 BADV: 0x002134d4 *0xa23de848 &#x3D; 0xff2209c, TLBLO0 &#x3D; ff229c(实际为ff221c，第8位恒为0，其中第1位页有效位为0); *0xa23de84c &#x3D; 0xff2309d, TLBLO0 &#x3D; ff239d(实际为ff231d，第8位恒为0，其中第1位页有效位为1); 参考四种TLB异常TLB 异常总共有 4 种：TLB&#x2F;XTLB 重填异常（TLB Refill Exception，意味着 TLB 中没有对应项），TLB 加载无效异常（TLB Load Invalid Exception，意味着读请求、TLB 中有对应项、但对应项无效），TLB 存储无效异常（TLB Store Invalid Exception，意味着写请求、TLB 中有对应项、但对应项无效），TLB 修改异常（TLB Modify Exception，意味着写请求，TLB 中有对应项、也有效、但对应项只读）。TLB&#x2F;XTLB 重填异常有专门的入口向量（向量 0 和向量 1），而其他几种异常使用通用入口向量（向量 3）。 BADV 出错虚地址 虚拟地址结构32位系统的页面大小4KB。PGD和PTE占10位，故页表项4B，页目录表4KB，页目录表中每个有效表项对应一个 4KB 页表。 虚拟地址 10：10：12 （PGD：PTE：PAGE_OFFSET） PGD 全局目录基址 PGDL+PGDOFFSET &#x3D; BADV对应PGD物理地址 TLBSRCH TLBELO0,1 ld.w和st.w指令 Load 用于把内存中的数据装载到寄存器中。 rd &#x3D; *rjStore用于把寄存器中的数据存入内存。 *rj &#x3D; rd DBAR 栅障指令 ERTN TLBFILL Page table bits 虚拟地址划分：最低的2GB（USEG）既缓存又分页；随后的512MB（KSEG0）缓存但不分页，对应物理地址的低 512MB（虚拟地址去掉高三位即为物理地址）；接下来的512MB（KSEG1）既不缓存又不分页，同样对应物理地址的低 512MB（虚拟地址去掉高三位即为物理地址）；最后的 1GB（KSEG2）对应物理既缓存又分页。 其他tlb_load tlb_modify tlb_refill"},{"title":"EOF","date":"2021-07-30T02:46:29.000Z","url":"/2021/07/30/EOF/","tags":[["technique","/tags/technique/"],["note","/tags/note/"],["C","/tags/C/"]],"categories":[["编程技术","/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"]],"content":"EOF是&lt;stdio.h&gt;中的宏定义，EOF(End Of File)是一个与标准输入&#x2F;输出流相关联的标志位。当文件指针已经指向文件尾且再次尝试读取时，EOF标志会被设置。同时，某些函数会在读取到文件尾（即EOF标志被设置）时返回EOF作为标识。 在操作系统中，文件以文件存储占用的扇区数作为文件大小的计数单位，故而如果文件的大小不能恰好填满存储文件的最后一个扇区，则需要对该扇区剩余的空间进行填充，过去填充使用的是值为26(0x1a)的字节，也就是某些系统中 Ctrl+Z 的对应码值。 EOF 函数getchar()getchar()的返回值与EOF进行比较，如果不相同，说明还没有到达文件结尾。 在Unix系统中，可以通过在一行开始键入Ctrl+D来从键盘模拟文件结束条件；windows系统则使用Ctrl+Z来达到这个目的。 scanf()scanf()函数返回一个整数值，这个值是成功读取的项目数，或者当遇到文件结束时返回一个EOF(文件结尾符)。 fclose()fclose()函数 如果成功返回 0，否则返回EOF（-1）。 getc()如果读入字符时发现已经到达文件结尾，getc()会返回一个特殊值EOF。 feof()int feof(FILE * stream); 会检查与文件对应流的eof( end of file )标志是否被设置，如果被设置则返回非零值，如未被设置，则返回0。 "},{"title":"《C Primer Plus》笔记","date":"2021-07-26T04:51:22.000Z","url":"/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/","tags":[["note","/tags/note/"],["C","/tags/C/"],["book","/tags/book/"]],"categories":[["编程技术","/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"]],"content":"摘要：从2021&#x2F;07&#x2F;19到2021&#x2F;07&#x2F;26阅读完毕 参考： C在线工具 C Primer Plus 第6版中文版.pdf 基础内容#include#include这行代码是一条C预处理器指令（preprocessor directive）。通常，C编译器在编译前会对源代码做一些准备工作，即预处理（preprocessing）。 #include &quot;hotels.h&quot;指令中的双引号表明被包含的源文件位于当前目录中（通常是包含源代码的目录）。 字符和字符串字符串是以空字符（\\0）（ASCII &#x3D; 0）结尾的char类型数组。 scanf()只会读取字符数组中的一个单词，而不是一整句，在遇到空格、换行时就停止了。 字符串常量”x”和字符常量’x’不同。区别之一在于’x’是基本类型（char），而”x”是派生类型（char数组）；区别之二是”x”实际上由两个字符组成：’x’和空字符\\0。 sizeof() 、size_t和 scanf()sizeof 运算符，它以字节为单位给出对象的大小。sizeof 返回 size_t 类型的值。这是一个无符号整数类型，但它不是新类型。 size_t是语言定义的标准类型，size_t 类型被定义为 sizeof 运算符的返回值类型——无符号整数类型。C有一个typedef机制，允许程序员为现有类型创建别名。例如，typedef double real;类似地，C 头文件系统可以使用 typedef把 size_t 作为 unsigned int 或unsigned long的别名。stddef.h文件中包含了size_t类型的typedef或#define定义。这样，在使用size_t类型时，编译器会根据不同的系统替换标准类型。 scanf()中把***放在%和转换字符之间时，会使得scanf()跳过相应的输出项。如%*d、%.2f等 字符缓冲区用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。 为什么要有缓冲区？ 首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。缓冲分为两类：完全缓冲I&#x2F;O和行缓冲I&#x2F;O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I&#x2F;O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。 行缓冲输入getchar() 回显无缓冲输入的getche() 无回显无缓冲输入的getch() 缓冲输入和无缓冲输入 从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。 如果包含&lt;stdio.h&gt;文件，并使用EOF符号，就不必担心EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。 重定向输入 、 重定向输出 递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。 指针和运算符地址运算符：&amp;一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。可以把地址看作是变量在内存中的位置。 指针指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址，大小为4B。 要创建指针变量，先要声明指针变量的类型。假设想把ptr声明为储存int类型变量地址的指针，就要使用间接运算符：*。 间接运算符：* scanf(&quot;%d&quot;, &amp;num) //scanf()读取一个值，然后把该值储存到指定的地址上。 指针和数组我们的系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节。 对形式参数使用const如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。 多维数组zippo[2][1] &#x3D; ((zippo+2) + 1)zippo[0] &#x3D; *zippozippo[0][0] &#x3D; *zippo[0] &#x3D; **zippo &#x3D; 2 数组的数组 命令行参数 命令行参数 字符串什么是字符串gets()、gets_s()、fgets()、puts()、fputs()、strcat()、strncat()、strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr() 字符串是以空字符（\\0）结尾的char类型数组。在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）。 初始化数组 字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。 初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。 字符串中数组和指针的区别初始化字符数组来储存字符串和初始化指针来指向字符串有何区别（“指向字符串”的意思是指向字符串的首字符）？ 例如，假设有下面两个声明：char heart[] &#x3D; “I love Tillie!”;const char *head &#x3D; “I love Millie!”;两者主要的区别是：数组名heart是常量，而指针名head是变量，字符串常量属于静态存储类别（static storage class）。 这样的语句可能导致内存访问错误。原因前面提到过，编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。如果编译器使用这种单次副本表示法，并允许word[1]修改为’1’，那将影响所有使用该字符串的代码。因此，建议在把指针初始化为字符串字面量时使用const限定符：const char * word = &quot;frame&quot;; // 推荐用法 读入字符串scanf()、gets()和fgets()为字符串分配内存后，便可读入字符串。C 库提供了许多读取字符串的函数：scanf()、gets()和fgets()。 scanf()和转换说明%s只能读取一个字符。 gets()函数读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符’\\0’使其成为一个 C 字符串。它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。 如果输入的字符串过长，会导致缓冲区溢出，该函数的不安全行为造成了安全隐患。【运行时异常】过去通常用fgets()来代替gets()。C11标准新增的gets_s()函数也可代替gets()。用一个参数限制读入的字符数。 fgets()和fputs()fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别如下。 fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。 fgets()函数的第3个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与 fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout（标准输出）作为该参数。 字符串函数 unsigned long strlen(const char *p);用以统计字符串的长度。（不包含‘\\0’） char *strcat(char *p, const char *q); 用以拼接字符串，返回第一个参数 char *strncat(char *dest, const char *src, size_t count);用以拼接字符串，返回第一个参数，第三个参数是能够添加字符数的大小 int strcmp(const char *cs, const char *ct);由于非零值都为“真”，while (strcmp(str1, str2)) &#x2F;&#x2F;当str1和str2不相同时如果两个字符串相等，则返回0 char *strcpy(char *p, const char *q); char *strncpy(char *p, const char *q, unsigned long size);将str2拷贝到str1中 char *strchr(const char * s, int c); 【参数】str 为要查找的字符串，c 为要查找的字符。 【返回值】如果找到指定的字符则返回该字符所在地址，否则返回 NULL。 strchr() 将会找出 str 字符串中第一次出现的字符 c 的地址，然后将该地址返回。 int sprintf( char *buffer, const char *format, [ argument] … ); buffer： char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。***[argument]…***：可选参数，可以是任何类型的数据。return：成功则返回参数buffer字符串长度，失败则返回-1，错误原因存于errno 中。 存储类别、链接和内存管理存储类别从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为对象（object）。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小。（面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言） 从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来完成： 程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值的数组就是一个对象。由于数组中的每个字符都能被单独访问，所以每个字符也是一个对象。该声明还创建了一个标识符为pc的对象，储存着字符串的地址。由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的左值。const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指向别的字符串。 可以用存储期（storage duration）描述对象，所谓存储期是指对象在内存中保留了多长时间。标识符用于访问对象，可以用作用域（scope）和链接（linkage）描述标识符，标识符的作用域和链接表明了程序的哪些部分可以使用它。不同的存储类别具有不同的存储期、作用域和链接。标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的执行期存在。可以通过函数调用的方式显式分配和释放内存。 链接C 变量有 3 种链接属性：外部链接、内部链接或无链接。具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。 C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。 一些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”。 存储期C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。 静态存储期：它在程序的执行期间一直存在。无论是内部链接（static）还是外部链接，所有的文件作用域变量都具有静态存储期。 线程存储期：用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明（_Thread_local）时到线程结束一直存在。 自动存储期：局部变量。块作用域的变量通常都具有自动存储期，当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。 动态分配存储期：malloc()、free()。 静态变量块作用域的静态变量“局部静态变量”是描述具有块作用域的静态变量的另一个术语。 内部链接的静态变量普通的外部变量可用于同一程序中任意文件中的函数，但是内部链接的静态变量只能用于同一个文件中的函数。 C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。 外部链接的静态变量把变量的定义性声明（defining declaration）放在在所有函数的外面便创建了外部变量。当然，为了指出该函数使用了外部变量，可以在函数中用关键字extern再次声明。 外部变量只能初始化一次，且必须在定义该变量时进行，只有定义式声明才能初始化变量。 存储类别说明符C语言有6个关键字作为存储类别说明符：auto、register、static、extern、_Thread_local和typedef。 下面用一个简短的程序使用了5种存储类别。 存储类别和函数函数也有存储类别，可以是外部函数（默认）或静态函数。 在同一个程序中，其他文件中的函数可以调用gamma()和delta()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。 通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，否则一般函数声明都默认为extern。 随机数函数和静态变量ANSI C库提供了rand()函数生成随机数。生成随机数有多种算法，ANSI C允许C实现针对特定机器使用最佳算法。然而，ANSI C标准还提供了一个可移植的标准算法，在不同系统中生成相同的随机数。实际上，rand()是“伪随机数生成器”，意思是可预测生成数字的实际序列。但是，数字在其取值范围内均匀分布。 可移植版本的方案开始于一个“种子”数字。该函数使用该种子生成新的数，这个新数又成为新的种子。然后，新种子可用于生成更新的种子，以此类推。 问题：伪随机，每次运行的结果都相同。改进：可以引入另一个函数srand1()重置种子来解决这个问题。关键是要让next成为只供rand1()和srand1()访问的内部链接静态变量（srand1()相当于C库中的srand()函数）。 如果 C 实现允许访问一些可变的量（如，时钟系统），可以用这些值（可能会被截断）初始化种子值。 掷骰子 分配内存：malloc()和free()malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。从ANSI C标准开始，C使用一个新的类型：指向void的指针。该类型相当于一个“通用指针”。malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。在ANSI C中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向 void的指针赋给任意类型的指针完全不用考虑类型匹配的问题。如果 malloc()分配内存失败，将返回空指针。 通常，malloc()要与free()配套使用。free()函数的参数是之前malloc()返回的地址，该函数释放之前malloc()分配的内存。 设想malloc()和free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用free()把内存归还内存池中，这样便可重复使用这些内存。free()的参数应该是一个指针，指向由 malloc()分配的一块内存。不能用 free()释放通过其他方式（如，声明一个数组）分配的内存。malloc()和free()的原型都在stdlib.h头文件中。 calloc()函数 变长数组 变长二位数组正确的做法是先分配行，再分配列。 释放内存的时候，要先释放列，再释放行。 注意，顺序反了的话，会把列的地址擦除，导致释放列时内存时找不到地址，程序崩溃。 正确的分配空间代码如下： 这种分配方式得到的其实并不是真正意义上的二维数组，因为其行与行之间的内存并不连续，虽然可以用下标arr[i][j]的方式访问，但当用指向该二维数组的指针来访问时候，不能通过指针值的增加来跨行获取元素，不过这种情况一般用的也不多，因此上述分配方式在大多数情况下的操作都能得到正确的结果。 ANSI C类型限定符const类型限定符以const关键字声明的对象，其值不能通过赋值或递增、递减来修改。 就近原则：const 跟 float 还是 * 更近。创建了 pf 指向的值不能被改变，而 pf 本身的值可以改变。创建的指针pt本身的值不能更改。pt必须指向同一个地址，但是它所指向的值可以改变。 const放在左侧任意位置，限定了指针指向的数据不能改变；const放在的右侧，限定了指针本身不能改变。 volatile类型限定符1、为什么用volatile？ volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。例如，一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算机传入的信息。 现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但并未改变它的值。于是编译器把 x的值临时储存在寄存器中，然后在val2需要使用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时间。这个过程被称为高速缓存（caching）。 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如： volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中（内存）读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。volatile 可以保证对特殊地址的稳定访问。 一般说来，volatile用在如下的几个地方： 中断服务程序中修改的供其它程序检测的变量需要加 volatile； 多任务环境下各任务间共享的标志应该加 volatile； 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义； 可以同时用const和volatile限定一个值。例如，通常用const把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。 参考：C&#x2F;C++ 中 volatile 关键字详解 restrict类型限定符restrict 关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。 由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式，编译器可以把涉及 restar的两条语句替换成下面这条语句，效果相同：restar[n] += 8; /* 可以进行替换 */ restrict 限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途。例如，C 库有两个函数用于把一个位置上的字节拷贝到另一个位置。在C99中，这两个函数的原型是： _Atomic类型限定符（C11）并发程序设计把程序执行分成可以同时执行的多个线程。这给程序设计带来了新的挑战，包括如何管理访问相同数据的不同线程。C11通过包含可选的头文件stdatomic.h和threads.h，提供了一些可选的（不是必须实现的）管理方法。值得注意的是，要通过各种宏函数来访问原子类型。当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。 文件输入&#x2F;输出函数：fopen()、getc()、putc()、exit()、fclose()fprintf()、fscanf()、fgets()、fputs()rewind()、fseek()、ftell()、fflush()fgetpos()、fsetpos()、feof()、ferror()ungetc()、setvbuf()、fread()、fwrite() C程序把输入看作是字节流(文本流或二进制流)，输入流来源于文件、输入设备（如键盘），或者甚至是另一个程序的输出。类似地，C程序把输出也看作是字节流，输出流的目的地可以是文件、视频显示等。 与文件进行通信二进制模式和文本模式C 提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式中，程序所见的内容和文件的实际内容不同。 I&#x2F;O的级别可以选择I&#x2F;O的两个级别（即处理文件访问的两个级别）。底层I&#x2F;O（low-level I&#x2F;O）使用操作系统提供的基本I&#x2F;O服务。标准高级I&#x2F;O（standard high-level I&#x2F;O）使用C库的标准包和stdio.h头文件定义。因为无法保证所有的操作系统都使用相同的底层I&#x2F;O模型，C标准只支持标准I&#x2F;O包。有些实现会提供底层库，但是C标准建立了可移植的I&#x2F;O模型，我们主要讨论这些I&#x2F;O。 标准文件C程序会自动打开3个文件，它们被称为标准输入（standard input）、标准输出（standard output）和标准错误输出（standard error output）。在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。 通常，标准输入为程序提供输入，它是 getchar()和 scanf()使用的文件。程序通常输出到标准输出，它是putchar()、puts()和printf()使用的文件。 标准I&#x2F;O与底层I&#x2F;O相比，标准I&#x2F;O包除了可移植以外还有两个好处。第一，标准I&#x2F;O有许多专门的函数简化了处理不同I&#x2F;O的问题。例如，printf()把不同形式的数据转换成与终端相适应的字符串输出。第二，输入和输出都是缓冲的。也就是说，一次转移一大块信息而不是一字节信息（通常至少512字节）。 getc()和putc()函数 文件结尾getc()函数在读取一个字符时发现是文件结尾，它将返回一个特殊值EOF。 fclose()函数如果成功关闭，fclose()函数返回0，否则返回EOF： 指向标准文件的指针stdio.h头文件把3个文件指针与3个标准文件相关联，C程序会自动打开这3个标准文件。 这些文件指针都是指向FILE的指针，所以它们可用作标准I&#x2F;O函数的参数，如fclose(fp)中的fp。 一个简单的文件压缩程序问题描述：把一个文件中选定的数据拷贝到另一个文件中。该程序同时打开了两个文件，以”r”模式打开一个，以”w”模式打开另一个。以保留每3个字符中的第1个字符的方式压缩第1个文件的内容。最后，把压缩后的文本存入第2个文件。第2个文件的名称是第1个文件名加上.red后缀。 文件I&#x2F;O：fprintf()、fscanf()、fgets()和fputs()I&#x2F;O函数都类似于文件I&#x2F;O函数。它们的主要区别是，文件I&#x2F;O函数要用FILE指针指定待处理的文件。与 getc()、putc()类似，这些函数都要求用指向 FILE 的指针（如，stdout）指定一个文件，或者使用fopen()的返回值。 fgets(buf, STLEN, fp);输入函数，读操作，buf是char类型数组的名称，STLEN是字符串的大小，fp是指向FILE的指针。 fputs(buf, fp);输出函数，写操作，这里，buf是字符串的地址，fp用于指定目标文件。 ch &#x3D; getc(fp); &#x2F;&#x2F;输入流→输入缓冲区putchar(ch);putc(ch,stdout); &#x2F;&#x2F;输出缓冲区→输出流 随机访问：fseek()和ftell()有了 fseek()函数，便可把文件看作是数组，在 fopen()打开的文件中直接移动到任意字节处。 fseek(fp, offset, SEEK_MODE); fseek()的第1个参数是FILE指针，指向待查找的文件，fopen()应该已打开该文件。 fseek()的第2个参数是偏移量（offset）。该参数表示从起始点开始要移动的距离（参见表13.3列出的起始点模式）。该参数必须是一个long类型的值，可以为正（前移）、负（后移）或0（保持不动） fseek()的第3个参数是模式，该参数确定起始点。 如果一切正常，fseek()的返回值为0；如果出现错误（如试图移动的距离超出文件的范围），其返回值为-1。 example: fgetpos()和fsetpos()函数ANSI C新增了两个处理较大文件的新定位函数：fgetpos()和 fsetpos()。这两个函数不使用 long 类型的值表示位置，它们使用一种新类型：fpos_t（代表file, position, type，文件定位类型）。fpos_t类型不是基本类型，它根据其他类型来定义。 int fgetpos(FILE * restrict stream, fpos_t * restrict pos); 调用该函数时，它把fpos_t类型的值放在pos指向的位置上，该值描述了文件中的一个位置。如果成功，fgetpos()函数返回0；如果失败，返回非0。 int fsetpos(FILE *stream, const fpos_t *pos); 调用该函数时，使用pos指向位置上的fpos_t类型值来设置文件指针指向该值指定的位置。如果成功，fsetpos()函数返回0；如果失败，则返回非0。fpos_t类型的值应通过之前调用fgetpos()获得。 标准I&#x2F;O的机理调用fopen()打开文件fopen()函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen()返回一个指向该结构的指针，以便其他函数知道如何找到该结构。 文件输入：调用fscanf()、getc()或 fgets()将输入流拷贝到输入缓冲区调用这些函数，文件中的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而异，一般是512字节或是它的倍数，如4096。最初调用函数，除了填充缓冲区外，还要设置fp所指向的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从字节0开始。 当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中。 文件输出：调用fprinf()、putc()或 fputs()将输出缓冲区拷贝到输出流输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。 ungetc()、fllush()、setvbuf()函数int ungetc()函数把c指定的字符放回输入流中。如果把一个字符放回输入流，下次调用标准输入函数时将读取该字符。 int ungetc(int c, FILE *fp); int fflush(FILE *fp); 调用fflush()函数引起输出缓冲区中所有的未写入数据被发送到fp指定的输出文件。这个过程称为刷新缓冲区。只要最近一次操作不是输入操作，就可以用该函数来更新流（任何读写模式）。 int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size); setvbuf()函数创建了一个供标准I&#x2F;O函数替换使用的缓冲区。在打开文件后且未对流进行其他操作之前，调用该函数。 假设一个程序要储存一种数据对象，每个数据对象的大小是3000字节。可以使用setvbuf()函数创建一个缓冲区，其大小是该数据对象大小的倍数。 二进制I&#x2F;O：fread()和fwrite()为什么需要用二进制文件存储？之前用到的标准I&#x2F;O函数都是面向文本的，用于处理字符和字符串。如何要在文件中保存数值数据？用 fprintf()函数和%f转换说明只是把数值保存为字符串。例如： 把num储存为8个字符：0.333333。 为保证数值在储存前后一致，最精确的做法是使用与计算机相同的位组合来储存。因此，double 类型的值应该储存在一个 double 大小的单元中。如果以程序所用的表示法把数据储存在文件中，则称以二进制形式储存数据。这样就不存在从数值形式到字符串的转换过程。 实际上，所有的数据都是以二进制形式储存的，甚至连字符都以字符码的二进制表示来储存。如果文件中的所有数据都被解释成字符码，则称该文件包含文本数据。如果部分或所有的数据都被解释成二进制形式的数值数据，则称该文件包含二进制数据（另外，用数据表示机器语言指令的文件都是二进制文件） fwrite()函数size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp); fwrite()函数把二进制数据写入文件。fwrite()函数返回成功写入项的数量。正常情况下，该返回值就是nmemb，但如果出现写入错误，返回值会比nmemb小。 fwrite()原型中的const void * restrict ptr声明。fwrite()的一个问题是，它的第1个参数不是固定的类型。例如，第1个例子中使用buffer，其类型是指向char的指针；而第2个例子中使用earnings，其类型是指向double的指针。在ANSI C函数原型中，这些实际参数都被转换成指向void的指针类型，这种指针可作为一种通用类型指针（在ANSI C之前，这些参数使用char*类型，需要把实参强制转换成char *类型）。 fread()函数size_t fread(void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp); fwrite()函数把文件中的二进制数据读入数据指针。ffread()函数返回成功读取项的数量。正常情况下，该返回值就是nmemb，但如果出现读取错误或读到文件结尾，该返回值就会比nmemb小。 如果标准输入函数返回 EOF，则通常表明函数已到达文件结尾。然而，出现读取错误时，函数也会返回EOF。feof()和ferror()函数用于区分这两种情况。当上一次输入调用检测到文件结尾时，feof()函数返回一个非零值，否则返回0。当读或写出现错误，ferror()函数返回一个非零值，否则返回0。 程序：使用fread()和fwrite()函数进行拷贝 程序：用二进制I&#x2F;O进行随机访问 结构和其他数据形式关键字：struct、union、typedef运算符：.和-&gt; C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。参考：C 库函数 - fgets() 定义结构变量初始化结构初始化变量和数组如下： 结构变量是否也可以这样初始化？是的，可以。初始化一个结构变量与初始化数组的语法类似： 访问结构成员 其他结构特性 结构中的字符数组和字符指针 对于struct names类型的结构变量veep，以上字符串都储存在结构内部，结构总共要分配40字节储存姓名。然而，对于struct pnames类型的结构变量treas，以上字符串储存在编译器储存常量的地方。结构本身只储存了两个地址，在我们的系统中共占16字节（一个指针在64位的计算机上，占8个字节；一个指针在32位的计算机上，占4个字节）。如果要用结构储存字符串，用字符数组作为成员比较简单。用指向 char 的指针也行，但是误用会导致严重的问题。 如果使用malloc()分配内存并使用指针储存该地址，那么在结构中使用指针处理字符串就比较合理。 复合字面量 伸缩型数组成员（flexible array member）利用这项特性声明的结构，其最后一个数组成员具有一些特性。第1个特性是，该数组不会立即存在。第2个特性是，使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。 带伸缩型数组成员的结构确实有一些特殊的处理要求。第一，不能用结构进行赋值或拷贝： *pf2 = *pf1; // 不要这样做 这样做只能拷贝除伸缩型数组成员以外的其他成员。确实要进行拷贝，应使用memcpy()函数。 第二，不要以按值方式把这种结构传递给结构。原因相同，按值传递一个参数与赋值类似。要把结构的地址传递给函数。第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员。 匿名结构（C11） 把结构内容保存到文件中储存记录最没效率的方法是用fprintf() fprintf(pbooks, &quot;%s %s %.2f\\n&quot;, primer.title,primer.author, primer.value); 更好的方案是使用fread()和fwrite()函数读写结构大小的单元。这两个函数使用与程序相同的二进制表示法。 fwrite(&amp;primer, sizeof(struct book), 1, pbooks); 缺点移植性较差。以二进制表示法储存数据的缺点是，不同的系统可能使用不同的二进制表示法，所以数据文件可能不具可移植性。甚至同一个系统，不同编译器设置也可能导致不同的二进制布局。 联合简介联合（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。 根据以下形式声明的结构可以储存一个int类型、一个double类型和char类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的值或char类型的值。 声明时，编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。其中double类型占64位，即8字节。 匿名联合（C11）匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的无名联合成员。 如果flits是car_data类型的结构变量，通过以下方式访问 flits.owncar.socsecurity 枚举类型可以用枚举类型（enumerated type）声明符号名称来表示整型常量。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如，可以这样声明： C枚举的一些特性并不适用于C++。例如，C允许枚举变量使用++运算符，但是C++标准不允许。 赋值 枚举类型的目的是为了提高程序的可读性和可维护性。 因为枚举类型是整数类型，所以可以在表达式中以使用整数变量的方式使用enum变量。它们用在case语句中很方便。 共享名称空间C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来识别。作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲突；两个相同作用域的同名变量冲突。 在特定作用域中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称空间与普通变量使用的空间不同。这意味着在相同作用域中变量和标记的名称可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。 尽管如此，以两种不同的方式使用相同的标识符会造成混乱。另外，C++不允许这样做，因为它把标记名和变量名放在相同的名称空间中。 typedef简介利用typedef可以为某一类型自定义名称。这方面与#define类似，但是两者有3处不同： 与#define不同，typedef创建的符号名只受限于类型，不能用于值。 typedef由编译器解释，不是预处理器。 在其受限范围内，typedef比#define更灵活。 使用typedef的第1个原因是：为经常出现的类型创建一个方便、易识别的类型名。 使用typedef的第2个原因是：typedef常用于给复杂的类型命名。 通过结构、联合和typedef，C提供了有效处理数据的工具和处理可移植数据的工具。 其他复杂的声明 数组名后面的[]和函数名后面的()具有相同的优先级。它们比*（解引用运算符）的优先级高。 []和()的优先级相同，且都是从左往右结合 函数和指针 位操作运算符：～、&amp;、|、^、&lt;&lt;、&gt;&gt;&amp;&#x3D;、|&#x3D;、^&#x3D;、&gt;&gt;&#x3D;、&lt;&lt;&#x3D; 处理一个值中的位的两个C工具：位运算符和位字段 关键字：_Alignas、_Alignof 按位运算符逻辑运算符、移位运算符 按位逻辑运算符 二进制反码或按位取反：~ 按位与：&amp;（1&amp;1&#x3D;1，其余为0） 按位或： |（0|0&#x3D;0，其余为1） 按位异或：^（0^1&#x3D;1; 1^0&#x3D;1） 用法：掩码&amp;按位与（&amp;）运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合。 例如，假设定义符号常量MASK为2 （即，二进制形式为00000010）, 把掩码中的0看作不透明，1看作透明。表达式flags&amp;MASK相当于用掩码覆盖在flags的位组合上，只有MASK为1的位才可见。 用法：打开位（设置位）|有时，需要打开一个值中的特定位，同时保持其他位不变。例如，一台IBM PC 通过向端口发送值来控制硬件。例如，为了打开内置扬声器，必须打开 1 号位，同时保持其他位不变。这种情况可以使用按位或运算符（|）。 用法：关闭位（清空位）&amp;~和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的位。假设要关闭变量flags中的1号位。同样，MASK只有1号位为1（即，打开）。可以这样做： 例如：假设flags是00001111，MASK是10110110。~MASK&#x3D;01001001，flags &amp; ~MASK = 00001001 用法：切换位^切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或运算符（^）切换位。 如果使用^组合一个值和一个掩码，将切换该值与MASK为1的位相对应的位，该值与MASK为0的位相对应的位不变。 例如：(00001111) ^ (10110110) &#x2F;&#x2F; 表达式其结果为：(10111001) &#x2F;&#x2F; 结果值 用法：检查位的值有时，需要检查某位的值。例如，flags中1号位是否被设置为1？ 位移运算符左移：&lt;&lt;左移运算符（&lt;&lt;）将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。左侧运算对象移出左末端位的值丢失，用0填充空出的位置。 1000 1000&lt;&lt;1 &#x3D; 0010 000 右移：&gt;&gt;右移运算符（&gt;&gt;）将其左侧运算对象每一位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢。对于无符号类型，用0填充空出的位置；对于有符号类型，其结果取决于机器（空出的位置可用0填充，或者用符号位的副本填充）。 下面是有符号值的例子：(10001010) &gt;&gt; 2 &#x2F;&#x2F; 表达式，有符号值(00100010) &#x2F;&#x2F; 在某些系统中的结果值(10001010) &gt;&gt; 2 &#x2F;&#x2F; 表达式，有符号值(11100010) &#x2F;&#x2F; 在另一些系统上的结果值 下面是无符号值的例子：(10001010) &gt;&gt; 2 &#x2F;&#x2F; 表达式，无符号值(00100010) &#x2F;&#x2F; 所有系统都得到该结果值 用法：移位运算符移位运算符针对2的幂提供快速有效的乘法和除法：number &lt;&lt; n number乘以2的n次幂number &gt;&gt; n 如果number为非负，则用number除以2的n次幂 位字段操控位的第2种方法是位字段（bit field）。位字段是一个signed int或unsigned int类型变量中的一组相邻的位（C99和C11新增了**_Bool类型**的位字段）。位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度。 如果声明的总位数超过了一个unsigned int类型的大小会怎样？ 会用到下一个unsigned int类型的存储位置。一个字段不允许跨越两个unsigned int之间的边界。编译器会自动移动跨界的字段，保持unsigned int的边界对齐。一旦发生这种情况，第1个unsigned int中会留下一个未命名的“洞”。 这里，在stuff.field1和stuff.field2之间，有一个2位的空隙；stuff.field3将储存在下一个unsigned int中。 位字段示例我们假设方框具有如下属性：方框是透明的或不透明的；方框的填充色选自以下调色板：黑色、红色、绿色、黄色、蓝色、紫色、青色或白色；边框可见或隐藏；边框颜色与填充色使用相同的调色板；边框可以使用实线、点线或虚线样式。 加上未命名的字段，该结构共占用 16 位。如果不使用填充，该结构占用 10 位。C语言以unsigned int作为位字段结构的基本布局单元。（unsigned int是32位） 对齐特性（C11）C11 的对齐特性比用位填充字节更自然，它们还代表了C在处理硬件相关问题上的能力。在这种上下文中，对齐指的是如何安排对象在内存中的位置。 例如，把数据从一个硬件位置转移到另一个位置，或者调用指令同时操作多个数据项。 _Alignof运算符给出一个类型的对齐要求，在关键字_Alignof后面的圆括号中写上类型名即可： C11在stdlib.h库还添加了一个新的内存分配函数，用于对齐动态分配的内存。该函数的原型如下：void *aligned_alloc(size_t alignment, size_t size);第1个参数代表指定的对齐，第2个参数是所需的字节数，其值应是第1个参数的倍数。与其他内存分配函数一样，要使用free()函数释放之前分配的内存。 C预处理器和C库预处理指令：#define、#include、#ifdef、#else、#endif、#ifndef、#if、#elif、#line、#error、#pragma关键字：_Generic、_Noreturn、_Static_assert函数&#x2F;宏：sqrt()、atan()、atan2()、exit()、atexit()、assert()、memcpy()、memmove()、va_start()、va_arg()、va_copy()、va_end() C语言建立在适当的关键字、表达式、语句以及使用它们的规则上。然而，C标准不仅描述C语言，还描述如何执行C预处理器、C标准库有哪些函数，以及详述这些函数的工作原理。 GCC预处理——编译——汇编——链接 使用C语编写test程序的源代码文件test.c过程： 首先进入GCC的预编译器进行预处理，对头文件、宏定义等进行展开，生成test.i文件；然后进入GCC的编译器，编译完生成汇编程序test.s；然后调用汇编器进行汇编，生成可重定位的目标程序test.o；最后调用链接器，将所有目标文件和C语言库链接成可执行的二进制文件。 预处理器C预处理器在程序执行之前查看程序。根据程序中的预处理器指令，预处理器把符号缩写替换成其表示的内容。 翻译程序的第一步在预处理之前，编译器必须对该程序进行一些翻译处理。 Step1: 编译器把源代码中出现的字符映射到源字符集。该过程处理多字节字符集或Unicode字符集——字符扩展让C更加国际化（要在编译器中设置相关选项才能激活这个特性） Step2: 编译器定位每个反斜杠后面跟着换行符的实例，并删除它们。也就是说，把下面两个物理行（physical line）： 将变成： Step3: 编译器把文本划分成预处理记号序列、空白序列和注释序列。编译器将用一个空格字符替换每一条注释。 将变成： 最后，程序已经准备好进入预处理阶段，预处理器查找一行中以#号开始的预处理指令。 明示常量：#define 将变为： 记号从技术角度来看，可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串。 重定义常量假设先把LIMIT定义为20，稍后在该文件中又把它定义为25。这个过程称为重定义常量。 如果需要重定义宏，使用#undef 指令（稍后讨论）。 如果确实需要重定义常量，使用const关键字和作用域规则更容易些。 在#define中使用参数 预处理器黏合剂：##运算符 变参宏：…和__VA_ARGS__一些函数（如 printf()）接受数量可变的参数。stdvar.h 头文件提供了工具，让用户自定义带可变参数的函数。C99&#x2F;C11也对宏提供了这样的工具。 通过把宏参数列表中最后的参数写成省略号（...）来实现这一功能。这样，预定义宏__VA_ARGS__可用在替换部分中，表明省略号代表什么。 程序： 宏和函数的选择宏的一个优点是，不用担心变量类型 文件包含：#include当预处理器发现#include 指令时，会查看后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的#include指令。 这相当于把被包含文件的全部内容输入到源文件#include指令所在的位置。#include指令有两种形式：#include &lt;stdio.h&gt; ←查找系统目录#include &quot;hot.h&quot; ←查找当前工作目录#include &quot;/usr/biff/p.h&quot; ←查找&#x2F;usr&#x2F;biff目录 头文件中最常用的形式如下。 明示常量——例如，stdio.h中定义的EOF、NULL和BUFSIZE（标准I&#x2F;O缓冲区大小）。 宏函数——例如，getc(stdin)通常用getchar()定义，而getc()经常用于定义较复杂的宏，头文件ctype.h通常包含ctype系列函数的宏定义。 函数声明——例如，string.h头文件（一些旧的系统中是strings.h）包含字符串函数系列的函数声明。在ANSI C和后面的标准中，函数声明都是函数原型形式。 结构模版定义——标准I&#x2F;O函数使用FILE结构，该结构中包含了文件和与文件缓冲区相关的信息。FILE结构在头文件stdio.h中。 类型定义——标准 I&#x2F;O 函数使用指向 FILE 的指针作为参数。通常，stdio.h 用#define 或typedef把FILE定义为指向结构的指针。类似地，size_t和time_t类型也定义在头文件中。 外部变量——还可以使用头文件声明外部变量供其他文件共享。 其他指令程序员可能要为不同的工作环境准备C程序和C库包。不同的环境可能使用不同的代码类型。预处理器提供一些指令，程序员通过修改#define的值即可生成可移植的代码。#undef指令取消之前的#define定义。#if、#ifdef、#ifndef、#else、#elif和#endif指令用于指定什么情况下编写哪些代码。#line指令用于重置行和文件信息，#error指令用于给出错误消息，#pragma指令用于向编译器发出指令。 #undef指令#undef指令用于“取消”已定义的#define指令。 从C预处理器角度看已定义 当预处理器在预处理器指令中发现一个标识符时，它会把该标识符当作已定义的或未定义的。 条件编译可以使用其他指令创建条件编译（conditinal compilation）。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息（或代码）块。 #ifdef、#else和#endif指令 #ifndef指令 #ifndef指令通常用于防止多次包含一个文件。 SIZE则被设置为10。这里，当执行到#include “arrays.h”这行，处理array.h中的代码时，由于SIZE是已定义的，所以跳过了#define SIZE 100这行代码。 预定义宏 C99 标准提供一个名为__func__的预定义标识符，它展开为一个代表函数名的字符串（该函数包含该标识符）。 #line和#error#line指令重置__LINE__和__FILE__宏报告的行号和文件名。 #error指令让预处理器发出一条错误消息，该消息包含指令中的文本。如果可能的话，编译过程应该中断。 编译以上代码生成后，输出如下： 如果编译器只支持旧标准，则会编译失败，如果支持C11标准，就能成功编译。 #pragma在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些设置。#pragma把编译器指令放入源代码中。 例如，在开发C99时，标准被称为C9X，可以使用下面的编译指示（pragma）让编译器支持C9X： 一般而言，编译器都有自己的编译指示集。例如，编译指示可能用于控制分配给自动变量的内存量，或者设置错误检查的严格程度，或者启用非标准语言特性等。 C99还提供_Pragma预处理器运算符，该运算符把字符串转换成普通的编译指示。 等价于： 由于该运算符不使用#符号，所以可以把它作为宏展开的一部分： 泛型选择（C11）在程序设计中，泛型编程（generic programming）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。 C++在模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码。C没有这种功能。C11新增了一种表达式，叫作泛型选择表达式（generic selection expression），可根据表达式的类型（即表达式的类型是int、double 还是其他类型）选择一个值。 _Generic是C11的关键字。_Generic后面的圆括号中包含多个用逗号分隔的项。第1个项是一个表达式，后面的每个项都由一个类型、一个冒号和一个值组成，如float: 1。如果x的类型匹配是float:标签，那么整个表达式的值就是1。 下面的例子为：对泛型选择表达式求值得字符串。 内联函数通常，函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回。使用宏使代码内联，可以避免这样的开销。C99还提供另一种方法：内联函数（inline function）。 其实C99和C11标准中叙述的是：“把函数变成内联函数建议尽可能快地调用该函数，其具体效果由实现定义”。因此，把函数变成内联函数，编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。 标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。因此，最简单的方法是使用函数说明符 inline 和存储类别说明符static。 编译器查看内联函数的定义（也是原型），可能会用函数体中的代码替换 eatline()函数调用。也就是说，效果相当于在函数调用的位置输入函数体中的代码： 由于并未给内联函数预留单独的代码块，所以无法获得内联函数的地址（实际上可以获得地址，不过这样做之后，编译器会生成一个非内联函数）。另外，内联函数无法在调试器中显示。 编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。鉴于此，一般情况下内联函数都具有内部链接。因此，如果程序有多个文件都要使用某个内联函数，那么这些文件中都必须包含该内联函数的定义。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。 一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。 _Noreturn函数（C11）C99新增inline关键字时，它是唯一的函数说明符（关键字extern和static是存储类别说明符，可应用于数据对象和函数）。 C11新增了第2个函数说明符_Noreturn，表明调用完成后函数不返回主调函数。 exit()函数是_Noreturn函数的一个示例，一旦调用exit()，它不会再返回主调函数。void类型的函数在执行完毕后返回主调函数，只是它不提供返回值。 C库使用库表述C99&#x2F;C11标准提供了下面的描述： size_t 类型被定义为 sizeof 运算符的返回值类型——无符号整数类型，通常是unsignedint或unsigned long。stddef.h文件中包含了size_t类型的typedef或#define定义。其他文件（包括stdio.h）通过包含stddef.h来包含这个定义。许多函数（包括fread()）的实际参数中都要使用sizeof运算符，形式参数的size_t类型中正好匹配这种常见的情况。 restrict关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。 数学库#include &lt;math.h&gt;#include &lt;math.h&gt; 利用C11新增的泛型选择表达式_Generic定义一个泛型宏，根据参数类型选择最合适的数学函数版本。 &lt;tgmath.h&gt;定义 sqrt()宏展开为sqrtf()、sqrt()或 sqrtl()函数。 通用工具库rand()、srand()、malloc()和free()函数。在ANSI C标准中，这些函数的原型都在&lt;stdlib.h&gt;头文件中。 exit()和atexit()函数在main()返回系统时将自动调用exit()函数。 atexit()函数通过退出时注册被调用的函数提供这种功能，atexit()函数接受一个函数指针作为参数。 如果在IDE中运行，可能看不到最后4行。 atexit()函数的用法 这个函数使用函数指针。要使用 atexit()函数，只需把退出时要调用的函数地址传递给 atexit()即可。函数名作为函数参数时相当于该函数的地址，所以该程序中把sign_off或too_bad作为参数。然后，atexit()注册函数列表中的函数，当调用exit()时就会执行这些函数。ANSI保证，在这个列表中至少可以放 32 个函数。最后调用 exit()函数时，exit()会执行这些函数（执行顺序与列表中的函数顺序相反，即最后添加的函数最先执行）。 exit()函数的用法 exit()执行完atexit()指定的函数后，会完成一些清理工作：刷新所有输出流、关闭所有打开的流和关闭由标准I&#x2F;O函数tmpfile()创建的临时文件。然后exit()把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。在main()以外的函数中使用exit()也会终止整个程序。 qsort()函数对较大型的数组而言，“快速排序”方法是最有效的排序算法之一。 它把数组不断分成更小的数组，直到变成单元素数组。首先，把数组分成两部分，一部分的值都小于另一部分的值。这个过程一直持续到数组完全排序好为止。 第1个参数是指针，指向待排序数组的首元素。ANSI C允许把指向任何数据类型的指针强制转换成指向void的指针，因此，qsort()的第1个实际参数可以引用任何类型的数组。 第2个参数是待排序项的数量。函数原型把该值转换为size_t类型。前面提到过，size_t定义在标准头文件中，是sizeof运算符返回的整数类型。 由于qsort()把第1个参数转换为void指针，所以qsort()不知道数组中每个元素的大小。为此，函数原型用第 3 个参数补偿这一信息，显式指明待排序数组中每个元素的大小。例如，如果排序 double类型的数组，那么第3个参数应该是sizeof(double)。 最后，qsort()还需要一个指向函数的指针，这个被指针指向的比较函数用于确定排序的顺序。该函数应接受两个参数：分别指向待比较两项的指针。如果第1项的值大于第2项，比较函数则返回正数；如果两项相同，则返回0；如果第1项的值小于第2项，则返回负数。qsort()根据给定的其他信息计算出两个指针的值，然后把它们传递给比较函数。 string.h库中的memcpy()和 memmove()不能把一个数组赋给另一个数组，所以要通过循环把数组中的每个元素赋给另一个数组相应的元素。有一个例外的情况是：使用strcpy()和strncpy()函数来处理字符数组。memcpy()和memmove()函数提供类似的方法处理任意类型的数组。 这两个函数都从 s2 指向的位置拷贝 n 字节到 s1 指向的位置，而且都返回 s1 的值。 所不同的是， memcpy()的参数带关键字restrict，即memcpy()假设两个内存区域之间没有重叠；而memmove()不作这样的假设，所以拷贝过程类似于先把所有字节拷贝到一个临时缓冲区，然后再拷贝到最终目的地。 可变参数：stdarg.h 高级数据表示从数组到链表使用数组分配内存空间： 一种方法是调用malloc()一次，为5个movies结构请求分配足够的空间；另一种方法是调用malloc()5次，分别为每个movies结构请求分配足够的空间。 如果用不完500个指针，这种方法节约了大量的内存，因为内含500个指针的数组比内含500个结构的数组所占的内存少得多。尽管如此，如果用不到 500 个指针，还是浪费了不少空间。而且，这样还是有500个结构的限制。 还有一种更好的方法。每次使用 malloc()为新结构分配空间时，也为新指针分配空间。但是，还得需要另一个指针来跟踪新分配的指针，用于跟踪新指针的指针本身，也需要一个指针来跟踪，以此类推。要重新定义结构才能解决这个潜在的问题，即每个结构中包含指向 next 结构的指针。 虽然结构不能含有与本身类型相同的结构，但是可以含有指向同类型结构的指针。这种定义是定义链表（linked list）的基础，链表中的每一项都包含着在何处能找到下一项的信息。 假设要显示这个链表，每显示一项，就可以根据该项中已储存的地址来定位下一个待显示的项。然而，这种方案能正常运行，还需要一个指针储存链表中第1项的地址，因为链表中没有其他项储存该项的地址。此时，头指针就派上了用场。 抽象数据类型（ADT）计算机科学领域已开发了一种定义新类型的好方法，用3个步骤完成从抽象到具体的过程。 提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种正式的抽象描述被称为抽象数据类型（ADT）。 开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执行所需操作的函数。例如在 C中，可以提供结构定义和操控该结构的函数原型。这些作用于用户定义类型的函数相当于作用于 C基本类型的内置运算符。需要使用该新类型的程序员可以使用这个接口进行编程。 编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无需了解具体的实现细节。 链表的ADT： 类型名： 简单链表类型属性： 可以储存一系列项类型操作： 初始化链表为空确定链表为空确定链表已满确定链表中的项数在链表末尾添加项遍历链表，处理链表中的项清空链表 接口函数的实现 使用接口 队列队列是一种“先进先出”（first in,first out，缩写为FIFO）的数据形式 链表和数组 二叉查找树 "},{"title":"Hexo搭建个人博客","date":"2021-07-15T15:09:16.000Z","url":"/2021/07/15/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":[["hexo","/tags/hexo/"]],"categories":[["教程文档","/categories/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"]],"content":"前提准备 安装了Git for windows 配置了GitHub_Settings_keys 在github中新建一个名为username.github.io的仓库 安装node.js进入Node官网，安装node.js，打开cmd输入以下命令行： 配置hexo 配置GitHub配置站点配置文件hexo 有2种 _config.yml文件，一个是根目录下的全局的 _config.yml，一个是各个主题 theme 下的 _config.yml。将前者称为站点配置文件， 后者称为主题配置文件。 打开根目录下站点配置文件 _config.yml，配置有关 deploy 的部分： 部署到Github 网址：  能够正常访问即部署成功。 Hexo博客基本配置更改主题 启用主题，打开站点配置文件 _config.yml， 找到 theme 字段，并更改为 next，如下： 打开主题配置文件：themes\\next_config.yml，找到 scheme 字段，并更改为 Gemini，如下： 上传到github 其他主题 hexo常用命令 参考教程从零开始搭建个人博客/ 顶部导航栏相关"}]