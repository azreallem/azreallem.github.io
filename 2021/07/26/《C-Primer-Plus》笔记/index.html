<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>《C Primer Plus》笔记 | Hexo</title>
  <meta name="description" content="摘要：从2021&#x2F;07&#x2F;19到2021&#x2F;07&#x2F;26阅读完毕 参考： C在线工具 C Primer Plus 第6版中文版.pdf  基础内容#include#include这行代码是一条C预处理器指令（preprocessor  directive）。通常，C编译器在编译前会对源代码做一些准备工作，即预处理（preprocessing）。 #include">
<meta property="og:type" content="article">
<meta property="og:title" content="《C Primer Plus》笔记">
<meta property="og:url" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Azreallem&#39;s Blog">
<meta property="og:description" content="摘要：从2021&#x2F;07&#x2F;19到2021&#x2F;07&#x2F;26阅读完毕 参考： C在线工具 C Primer Plus 第6版中文版.pdf  基础内容#include#include这行代码是一条C预处理器指令（preprocessor  directive）。通常，C编译器在编译前会对源代码做一些准备工作，即预处理（preprocessing）。 #include">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%201.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%202.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%203.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%204.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%205.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%206.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%207.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%208.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%209.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2010.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2011.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2012.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2013.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2014.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2015.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2016.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2017.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2018.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2019.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2020.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2021.png">
<meta property="og:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2022.png">
<meta property="article:published_time" content="2021-07-26T04:51:22.000Z">
<meta property="article:modified_time" content="2022-03-29T15:17:28.000Z">
<meta property="article:author" content="Azreallem">
<meta property="article:tag" content="note">
<meta property="article:tag" content="C">
<meta property="article:tag" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Azreallem&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    <link href="//cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" rel="stylesheet">
  
  
  
  
<meta name="generator" content="Hexo 6.1.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">昵称</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/help/">help</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/">内核分析</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/">教程文档</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/">编程技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/">随手笔记</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FSM/" rel="tag">FSM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/backtracking/" rel="tag">backtracking</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/combine/" rel="tag">combine</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gdb/" rel="tag">gdb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/help/" rel="tag">help</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iproute2/" rel="tag">iproute2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/link/" rel="tag">link</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/note/" rel="tag">note</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/quckily-note/" rel="tag">quckily-note</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setup-arch/" rel="tag">setup_arch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/source-code/" rel="tag">source code</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/start-kernel/" rel="tag">start_kernel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/technique/" rel="tag">technique</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tlbex/" rel="tag">tlbex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tmux/" rel="tag">tmux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/C/" style="font-size: 13.33px;">C</a> <a href="/tags/FSM/" style="font-size: 13px;">FSM</a> <a href="/tags/Linux/" style="font-size: 13px;">Linux</a> <a href="/tags/algorithm/" style="font-size: 13px;">algorithm</a> <a href="/tags/backtracking/" style="font-size: 13px;">backtracking</a> <a href="/tags/book/" style="font-size: 13.33px;">book</a> <a href="/tags/c/" style="font-size: 13px;">c++</a> <a href="/tags/combine/" style="font-size: 13px;">combine</a> <a href="/tags/gdb/" style="font-size: 13px;">gdb</a> <a href="/tags/help/" style="font-size: 14px;">help</a> <a href="/tags/hexo/" style="font-size: 13px;">hexo</a> <a href="/tags/iproute2/" style="font-size: 13px;">iproute2</a> <a href="/tags/link/" style="font-size: 13.33px;">link</a> <a href="/tags/linux/" style="font-size: 14px;">linux</a> <a href="/tags/note/" style="font-size: 13.67px;">note</a> <a href="/tags/quckily-note/" style="font-size: 13px;">quckily-note</a> <a href="/tags/setup-arch/" style="font-size: 13px;">setup_arch</a> <a href="/tags/shell/" style="font-size: 13.33px;">shell</a> <a href="/tags/source-code/" style="font-size: 13.67px;">source code</a> <a href="/tags/start-kernel/" style="font-size: 13px;">start_kernel</a> <a href="/tags/technique/" style="font-size: 13px;">technique</a> <a href="/tags/tlbex/" style="font-size: 13px;">tlbex</a> <a href="/tags/tmux/" style="font-size: 13px;">tmux</a> <a href="/tags/vim/" style="font-size: 13px;">vim</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/04/23/Memory%20Layout%20of%20C%20Programs/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-23T02:21:10.000Z" itemprop="datePublished">2022-04-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/04/16/linuxatemyram/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-16T02:20:11.000Z" itemprop="datePublished">2022-04-16</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/">编程技术</a>
              </p>
              <p class="item-title">
                <a href="/2022/04/13/linux-probe-note/" class="title">linux-probe-note</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-13T14:33:18.000Z" itemprop="datePublished">2022-04-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/help/">help</a>
              </p>
              <p class="item-title">
                <a href="/2022/04/13/shell-help/" class="title">shell-help</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-13T14:27:23.000Z" itemprop="datePublished">2022-04-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/help/">help</a>
              </p>
              <p class="item-title">
                <a href="/2022/04/13/vim-help/" class="title">vim-help</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-13T14:24:13.000Z" itemprop="datePublished">2022-04-13</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9"><span class="toc-number">1.</span> <span class="toc-text">基础内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#include"><span class="toc-number">1.1.</span> <span class="toc-text">#include</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">字符和字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof-%E3%80%81size-t%E5%92%8C-scanf"><span class="toc-number">1.3.</span> <span class="toc-text">sizeof() 、size_t和 scanf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.4.</span> <span class="toc-text">字符缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5-%E3%80%81-%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.</span> <span class="toc-text">重定向输入 、 重定向输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">指针和运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A-amp"><span class="toc-number">1.6.1.</span> <span class="toc-text">地址运算符：&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.6.2.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">1.6.3.</span> <span class="toc-text">间接运算符：*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.7.</span> <span class="toc-text">指针和数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8const"><span class="toc-number">1.8.</span> <span class="toc-text">对形式参数使用const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">命令行参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.</span> <span class="toc-text">什么是字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">字符串中数组和指针的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2scanf-%E3%80%81gets-%E5%92%8Cfgets"><span class="toc-number">2.3.</span> <span class="toc-text">读入字符串scanf()、gets()和fgets()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fgets-%E5%92%8Cfputs"><span class="toc-number">2.4.</span> <span class="toc-text">fgets()和fputs()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">字符串函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">存储类别、链接和内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">存储类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">3.2.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-number">3.3.</span> <span class="toc-text">存储期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text">静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">块作用域的静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">内部链接的静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.4.3.</span> <span class="toc-text">外部链接的静态变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text">存储类别说明符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">存储类别和函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.7.</span> <span class="toc-text">随机数函数和静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%B7%E9%AA%B0%E5%AD%90"><span class="toc-number">3.8.</span> <span class="toc-text">掷骰子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9Amalloc-%E5%92%8Cfree"><span class="toc-number">3.9.</span> <span class="toc-text">分配内存：malloc()和free()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#calloc-%E5%87%BD%E6%95%B0"><span class="toc-number">3.9.1.</span> <span class="toc-text">calloc()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.2.</span> <span class="toc-text">变长数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E4%BA%8C%E4%BD%8D%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.3.</span> <span class="toc-text">变长二位数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANSI-C%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">3.10.</span> <span class="toc-text">ANSI C类型限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">3.10.1.</span> <span class="toc-text">const类型限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">3.10.2.</span> <span class="toc-text">volatile类型限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#restrict%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">3.10.3.</span> <span class="toc-text">restrict类型限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%88C11%EF%BC%89"><span class="toc-number">3.10.4.</span> <span class="toc-text">_Atomic类型限定符（C11）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA"><span class="toc-number">4.</span> <span class="toc-text">文件输入&#x2F;输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">4.1.</span> <span class="toc-text">与文件进行通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">二进制模式和文本模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-number">4.1.2.</span> <span class="toc-text">I&#x2F;O的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.3.</span> <span class="toc-text">标准文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-x2F-O"><span class="toc-number">4.2.</span> <span class="toc-text">标准I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getc-%E5%92%8Cputc-%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">getc()和putc()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE"><span class="toc-number">4.2.2.</span> <span class="toc-text">文件结尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fclose-%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">fclose()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">4.2.4.</span> <span class="toc-text">指向标准文件的指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">一个简单的文件压缩程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6I-x2F-O%EF%BC%9Afprintf-%E3%80%81fscanf-%E3%80%81fgets-%E5%92%8Cfputs"><span class="toc-number">4.4.</span> <span class="toc-text">文件I&#x2F;O：fprintf()、fscanf()、fgets()和fputs()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%EF%BC%9Afseek-%E5%92%8Cftell"><span class="toc-number">4.5.</span> <span class="toc-text">随机访问：fseek()和ftell()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fgetpos-%E5%92%8Cfsetpos-%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">fgetpos()和fsetpos()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-x2F-O%E7%9A%84%E6%9C%BA%E7%90%86"><span class="toc-number">4.7.</span> <span class="toc-text">标准I&#x2F;O的机理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8fopen-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">4.7.1.</span> <span class="toc-text">调用fopen()打开文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%EF%BC%9A%E8%B0%83%E7%94%A8fscanf-%E3%80%81getc-%E6%88%96-fgets-%E5%B0%86%E8%BE%93%E5%85%A5%E6%B5%81%E6%8B%B7%E8%B4%9D%E5%88%B0%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.7.2.</span> <span class="toc-text">文件输入：调用fscanf()、getc()或 fgets()将输入流拷贝到输入缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%EF%BC%9A%E8%B0%83%E7%94%A8fprinf-%E3%80%81putc-%E6%88%96-fputs-%E5%B0%86%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E6%8B%B7%E8%B4%9D%E5%88%B0%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">4.7.3.</span> <span class="toc-text">文件输出：调用fprinf()、putc()或 fputs()将输出缓冲区拷贝到输出流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ungetc-%E3%80%81fllush-%E3%80%81setvbuf-%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">ungetc()、fllush()、setvbuf()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6I-x2F-O%EF%BC%9Afread-%E5%92%8Cfwrite"><span class="toc-number">4.9.</span> <span class="toc-text">二进制I&#x2F;O：fread()和fwrite()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">4.9.1.</span> <span class="toc-text">为什么需要用二进制文件存储？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fwrite-%E5%87%BD%E6%95%B0"><span class="toc-number">4.9.2.</span> <span class="toc-text">fwrite()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fread-%E5%87%BD%E6%95%B0"><span class="toc-number">4.9.3.</span> <span class="toc-text">fread()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%EF%BC%9A%E4%BD%BF%E7%94%A8fread-%E5%92%8Cfwrite-%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.9.4.</span> <span class="toc-text">程序：使用fread()和fwrite()函数进行拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%EF%BC%9A%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6I-x2F-O%E8%BF%9B%E8%A1%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">4.9.5.</span> <span class="toc-text">程序：用二进制I&#x2F;O进行随机访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">结构和其他数据形式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text">定义结构变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.1.</span> <span class="toc-text">初始化结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="toc-number">5.1.2.</span> <span class="toc-text">访问结构成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E7%89%B9%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">其他结构特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">复合字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B8%E7%BC%A9%E5%9E%8B%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98%EF%BC%88flexible-array-member%EF%BC%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">伸缩型数组成员（flexible array member）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%EF%BC%88C11%EF%BC%89"><span class="toc-number">5.2.3.</span> <span class="toc-text">匿名结构（C11）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E7%BB%93%E6%9E%84%E5%86%85%E5%AE%B9%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">5.2.4.</span> <span class="toc-text">把结构内容保存到文件中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%AE%80%E4%BB%8B"><span class="toc-number">5.3.</span> <span class="toc-text">联合简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E8%81%94%E5%90%88%EF%BC%88C11%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">匿名联合（C11）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">5.4.1.</span> <span class="toc-text">赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.</span> <span class="toc-text">共享名称空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typedef%E7%AE%80%E4%BB%8B"><span class="toc-number">5.6.</span> <span class="toc-text">typedef简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%A4%8D%E6%9D%82%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">5.7.</span> <span class="toc-text">其他复杂的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">5.7.1.</span> <span class="toc-text">函数和指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">6.</span> <span class="toc-text">位操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">按位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.1.1.</span> <span class="toc-text">按位逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A%E6%8E%A9%E7%A0%81-amp"><span class="toc-number">6.1.2.</span> <span class="toc-text">用法：掩码&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A%E6%89%93%E5%BC%80%E4%BD%8D%EF%BC%88%E8%AE%BE%E7%BD%AE%E4%BD%8D%EF%BC%89"><span class="toc-number">6.1.3.</span> <span class="toc-text">用法：打开位（设置位）|</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A%E5%85%B3%E9%97%AD%E4%BD%8D%EF%BC%88%E6%B8%85%E7%A9%BA%E4%BD%8D%EF%BC%89-amp"><span class="toc-number">6.1.4.</span> <span class="toc-text">用法：关闭位（清空位）&amp;~</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A%E5%88%87%E6%8D%A2%E4%BD%8D"><span class="toc-number">6.1.5.</span> <span class="toc-text">用法：切换位^</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A%E6%A3%80%E6%9F%A5%E4%BD%8D%E7%9A%84%E5%80%BC"><span class="toc-number">6.1.6.</span> <span class="toc-text">用法：检查位的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">位移运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%EF%BC%9A-lt-lt"><span class="toc-number">6.2.1.</span> <span class="toc-text">左移：&lt;&lt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E7%A7%BB%EF%BC%9A-gt-gt"><span class="toc-number">6.2.2.</span> <span class="toc-text">右移：&gt;&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%EF%BC%9A%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.2.3.</span> <span class="toc-text">用法：移位运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">6.3.</span> <span class="toc-text">位字段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%AD%97%E6%AE%B5%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">位字段示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7%EF%BC%88C11%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">对齐特性（C11）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93"><span class="toc-number">7.</span> <span class="toc-text">C预处理器和C库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC"><span class="toc-number">7.1.</span> <span class="toc-text">GCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">7.2.</span> <span class="toc-text">预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="toc-number">7.2.1.</span> <span class="toc-text">翻译程序的第一步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%8E%E7%A4%BA%E5%B8%B8%E9%87%8F%EF%BC%9A-define"><span class="toc-number">7.3.</span> <span class="toc-text">明示常量：#define</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%8F%B7"><span class="toc-number">7.3.1.</span> <span class="toc-text">记号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="toc-number">7.3.2.</span> <span class="toc-text">重定义常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-define%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">7.3.3.</span> <span class="toc-text">在#define中使用参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E9%BB%8F%E5%90%88%E5%89%82%EF%BC%9A-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.3.4.</span> <span class="toc-text">预处理器黏合剂：##运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%8F%82%E5%AE%8F%EF%BC%9A%E2%80%A6%E5%92%8C-VA-ARGS"><span class="toc-number">7.3.5.</span> <span class="toc-text">变参宏：…和__VA_ARGS__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">7.3.6.</span> <span class="toc-text">宏和函数的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%9A-include"><span class="toc-number">7.4.</span> <span class="toc-text">文件包含：#include</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-number">7.5.</span> <span class="toc-text">其他指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undef%E6%8C%87%E4%BB%A4"><span class="toc-number">7.5.1.</span> <span class="toc-text">#undef指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">7.5.2.</span> <span class="toc-text">条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-number">7.5.3.</span> <span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#line%E5%92%8C-error"><span class="toc-number">7.5.4.</span> <span class="toc-text">#line和#error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pragma"><span class="toc-number">7.5.5.</span> <span class="toc-text">#pragma</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%89%E6%8B%A9%EF%BC%88C11%EF%BC%89"><span class="toc-number">7.5.6.</span> <span class="toc-text">泛型选择（C11）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Noreturn%E5%87%BD%E6%95%B0%EF%BC%88C11%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">_Noreturn函数（C11）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E5%BA%93"><span class="toc-number">7.8.</span> <span class="toc-text">C库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%93%E8%A1%A8%E8%BF%B0"><span class="toc-number">7.8.1.</span> <span class="toc-text">使用库表述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%BA%93-include-lt-math-h-gt"><span class="toc-number">7.8.2.</span> <span class="toc-text">数学库#include &lt;math.h&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-number">7.9.</span> <span class="toc-text">通用工具库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exit-%E5%92%8Catexit-%E5%87%BD%E6%95%B0"><span class="toc-number">7.9.1.</span> <span class="toc-text">exit()和atexit()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qsort-%E5%87%BD%E6%95%B0"><span class="toc-number">7.9.2.</span> <span class="toc-text">qsort()函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-h%E5%BA%93%E4%B8%AD%E7%9A%84memcpy-%E5%92%8C-memmove"><span class="toc-number">7.10.</span> <span class="toc-text">string.h库中的memcpy()和 memmove()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%EF%BC%9Astdarg-h"><span class="toc-number">7.11.</span> <span class="toc-text">可变参数：stdarg.h</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">8.</span> <span class="toc-text">高级数据表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E7%BB%84%E5%88%B0%E9%93%BE%E8%A1%A8"><span class="toc-number">8.1.</span> <span class="toc-text">从数组到链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88ADT%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">抽象数据类型（ADT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.1.</span> <span class="toc-text">接口函数的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.2.2.</span> <span class="toc-text">使用接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">8.3.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">8.4.</span> <span class="toc-text">链表和数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">8.5.</span> <span class="toc-text">二叉查找树</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-《C-Primer-Plus》笔记" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      《C Primer Plus》笔记
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/" class="article-date">
	  <time datetime="2021-07-26T04:51:22.000Z" itemprop="datePublished">2021-07-26</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/">编程技术</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/C/" rel="tag">C</a>, <a class="article-tag-link-link" href="/tags/book/" rel="tag">book</a>, <a class="article-tag-link-link" href="/tags/note/" rel="tag">note</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>摘要：从2021&#x2F;07&#x2F;19到2021&#x2F;07&#x2F;26阅读完毕</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://c.runoob.com/compile/11">C在线工具</a></p>
<p><a target="_blank" rel="noopener" href="https://www.google.com/search?q=C+Primer+Plus+%E7%AC%AC6%E7%89%88%E4%B8%AD%E6%96%87%E7%89%88+filetype:pdf&newwindow=1&sxsrf=ALeKk03SmmAJuucbGnKsbDAatwPtDIT4pQ:1626680117200&source=hp&ei=NSv1YOLPCLKFr7wPs_yuqA4&iflsig=AINFCbYAAAAAYPU5RS99S3uEXSzPhUY-her1BWef8ded&oq=C+Primer+Plus+%E7%AC%AC6%E7%89%88%E4%B8%AD%E6%96%87%E7%89%88+filetype:pdf&gs_lcp=Cgdnd3Mtd2l6EAM6BwgjEOoCECc6BAgAEAw6BQghEKABUOA_WNdaYIVdaANwAHgAgAGRAYgBhwuSAQM3LjeYAQCgAQKgAQGqAQdnd3Mtd2l6sAEK&sclient=gws-wiz&ved=0ahUKEwiivq7Uz-7xAhWywosBHTO-C-UQ4dUDCAc&uact=5">C Primer Plus 第6版中文版.pdf</a></p>
<hr>
<h1 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h1><h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><p><code>#include</code>这行代码是一条C预处理器指令（preprocessor  directive）。通常，C编译器在编译前会对源代码做一些准备工作，即预处理（preprocessing）。</p>
<p><code>#include &quot;hotels.h&quot;</code>指令中的双引号表明被包含的源文件位于当前目录中（通常是包含源代码的目录）。</p>
<h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><p>字符串是以空字符（\0）（ASCII &#x3D; 0）结尾的char类型数组。</p>
<p><code>scanf()</code>只会读取字符数组中的一个单词，而不是一整句，在遇到空格、换行时就停止了。</p>
<p>字符串常量”x”和字符常量’x’不同。区别之一在于’x’是基本类型（char），而”x”是派生类型（char数组）；区别之二是”x”实际上由两个字符组成：’x’和空字符\0。</p>
<h2 id="sizeof-、size-t和-scanf"><a href="#sizeof-、size-t和-scanf" class="headerlink" title="sizeof() 、size_t和 scanf()"></a>sizeof() 、size_t和 scanf()</h2><p><code>sizeof</code> 运算符，它以字节为单位给出对象的大小。<code>sizeof</code> 返回 <code>size_t</code> 类型的值。这是一个无符号整数类型，但它不是新类型。</p>
<p><code>size_t</code>是语言定义的标准类型，<code>size_t</code> 类型被定义为 sizeof 运算符的返回值类型——无符号整数类型。C有一个<code>typedef</code>机制，允许程序员为现有类型创建别名。例如，<code>typedef double real;</code>类似地，C 头文件系统可以使用 <code>typedef</code>把 <code>size_t</code> 作为 <code>unsigned int</code> 或<code>unsigned long</code>的别名。<code>stddef.h</code>文件中包含了<code>size_t</code>类型的<code>typedef</code>或<code>#define</code>定义。这样，在使用<code>size_t</code>类型时，编译器会根据不同的系统替换标准类型。</p>
<p><code>scanf()</code>中把***放在%和转换字符之间时，会使得<code>scanf()</code>跳过相应的输出项。如%*d、%.2f等</p>
<h2 id="字符缓冲区"><a href="#字符缓冲区" class="headerlink" title="字符缓冲区"></a>字符缓冲区</h2><p>用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。</p>
<p>为什么要有缓冲区？</p>
<p>首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。<br>虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。<br>缓冲分为两类：完全缓冲I&#x2F;O和行缓冲I&#x2F;O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I&#x2F;O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。</p>
<p>行缓冲输入<code>getchar()</code> </p>
<p>回显无缓冲输入的<code>getche()</code></p>
<p>无回显无缓冲输入的<code>getch()</code></p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled.png"></p>
<p>缓冲输入和无缓冲输入</p>
<p>从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。</p>
<p>如果包含<code>&lt;stdio.h&gt;</code>文件，并使用EOF符号，就不必担心EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。</p>
<h2 id="重定向输入-、-重定向输出"><a href="#重定向输入-、-重定向输出" class="headerlink" title="重定向输入 、 重定向输出"></a>重定向输入 、 重定向输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./helloworld &lt; words           <span class="comment"># 将words文件中的内容以字符流的方式输入到helloworld中</span></span><br><span class="line">./helloworld &gt; words           <span class="comment"># Ctrl + D 结束输入</span></span><br><span class="line">./helloworld &lt; words &gt; words2  <span class="comment"># 组合重定向</span></span><br></pre></td></tr></table></figure>

<p>递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。</p>
<h2 id="指针和运算符"><a href="#指针和运算符" class="headerlink" title="指针和运算符"></a>指针和运算符</h2><h3 id="地址运算符：-amp"><a href="#地址运算符：-amp" class="headerlink" title="地址运算符：&amp;"></a>地址运算符：&amp;</h3><p>一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。可以把地址看作是变量在内存中的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pooh = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %p\n&quot;</span>, pooh, &amp;pooh);</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址，大小为4B。</p>
<p>要创建指针变量，先要声明指针变量的类型。假设想把ptr声明为储存int类型变量地址的指针，就要使用间接运算符：*。</p>
<h3 id="间接运算符："><a href="#间接运算符：" class="headerlink" title="间接运算符：*"></a>间接运算符：*</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> bah = <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;bah;    <span class="comment">// 定义ine类型的指针ptr，值为bah地址</span></span><br><span class="line"><span class="type">int</span> val = *ptr;     <span class="comment">// 找出ptr指向的值,val = 500</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%201.png"></p>
<p><code>scanf(&quot;%d&quot;, &amp;num)  //scanf()读取一个值，然后把该值储存到指定的地址上。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STLEN 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span>* p = &amp;a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a=%d\t*p=%d\n&quot;</span>, a, *p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>我们的系统中，地址按字节编址，<code>short</code>类型占用2字节，<code>double</code>类型占用8字节。在C中，指针加1指的是增加一个<strong>存储单元</strong>。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> ,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">char</span> c[<span class="number">11</span>] = <span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a + <span class="number">1</span>)); <span class="comment">//ar[i] 与 *(ar + i)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *(c + <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对形式参数使用const"><a href="#对形式参数使用const" class="headerlink" title="对形式参数使用const"></a>对形式参数使用const</h2><p>如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字<code>const</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ar[], <span class="type">int</span> n)</span>; <span class="comment">/* 函数原型 */</span></span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>zippo[2][1] &#x3D; <em>(</em>(zippo+2) + 1)<br>zippo[0] &#x3D; *zippo<br>zippo[0][0] &#x3D; *zippo[0] &#x3D; **zippo &#x3D; 2</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%202.png"></p>
<p>数组的数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">somefunction</span><span class="params">( <span class="type">int</span> pt[][<span class="number">4</span>])</span>;</span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%203.png"></p>
<p>命令行参数</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="什么是字符串"><a href="#什么是字符串" class="headerlink" title="什么是字符串"></a>什么是字符串</h2><p>gets()、gets_s()、fgets()、puts()、fputs()、strcat()、strncat()、strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr()</p>
<p>字符串是以空字符（\0）结尾的char类型数组。在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）。</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%204.png"></p>
<p>初始化数组</p>
<p>字符串常量属于<strong>静态存储类别</strong>（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSG <span class="string">&quot;I&#x27;m special&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ar[] = MSG;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* pt = MSG;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;address ar: %p\n&quot;</span>, ar);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;address pt: %p\n&quot;</span>, pt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;address of MSG: %p\n&quot;</span>, MSG);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;address of \&quot;I&#x27;m special\&quot;: %p \n&quot;</span>, <span class="string">&quot;I&#x27;m special&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\tsizeof(MSG)=%d\tstrlen(MSG)=%d\tsizeof(pt)=%d\n&quot;</span>, MSG[<span class="number">1</span>], <span class="keyword">sizeof</span>(ar), <span class="built_in">strlen</span>(MSG), <span class="keyword">sizeof</span>(pt));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。</p>
<h2 id="字符串中数组和指针的区别"><a href="#字符串中数组和指针的区别" class="headerlink" title="字符串中数组和指针的区别"></a>字符串中数组和指针的区别</h2><p>初始化字符数组来储存字符串和初始化指针来指向字符串有何区别（“指向字符串”的意思是指向字符串的首字符）？</p>
<p>例如，假设有下面两个声明：<br>char heart[] &#x3D; “I love Tillie!”;<br>const char *head &#x3D; “I love Millie!”;<br>两者主要的区别是：数组名heart是常量，而指针名head是变量，字符串常量属于静态存储类别（static storage class）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> heart[] = <span class="string">&quot;I love Tillie!&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* head = <span class="string">&quot;I love Millie!&quot;</span>;</span><br><span class="line">	head = heart;</span><br><span class="line">	heart[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * word = <span class="string">&quot;frame&quot;</span>;</span><br><span class="line">word[<span class="number">1</span>] = <span class="string">&#x27;l&#x27;</span>; <span class="comment">// 是否允许？</span></span><br></pre></td></tr></table></figure>

<p>这样的语句可能导致内存访问错误。原因前面提到过，编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。如果编译器使用这种单次副本表示法，并允许word[1]修改为’1’，那将影响所有使用该字符串的代码。<br>因此，建议在把指针初始化为字符串字面量时使用const限定符：<br><code>const char * word = &quot;frame&quot;;　// 推荐用法</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MES <span class="string">&quot;Don&#x27;t be a fool!&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* mesg = <span class="string">&quot;Don&#x27;t be a fool!&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* copy;</span><br><span class="line">	copy = mesg;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, copy);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mesg = %s; &amp;mesg = %p; value = %p\n&quot;</span>, mesg, &amp;mesg, mesg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;copy = %s; &amp;copy = %p; value = %p\n&quot;</span>, copy, &amp;copy, copy);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\&quot;%s\&quot; = %p&quot;</span>, MES,MES);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读入字符串scanf-、gets-和fgets"><a href="#读入字符串scanf-、gets-和fgets" class="headerlink" title="读入字符串scanf()、gets()和fgets()"></a>读入字符串scanf()、gets()和fgets()</h2><p>为字符串分配内存后，便可读入字符串。C 库提供了许多读取字符串的函数：scanf()、gets()和fgets()。</p>
<p>scanf()和转换说明%s只能读取一个字符。</p>
<p>gets()函数读取整行输入，直至遇到<strong>换行符</strong>，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符’\0’使其成为一个 C 字符串。它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。</p>
<p>如果输入的字符串过长，会导致缓冲区溢出，该函数的不安全行为造成了安全隐患。【运行时异常】<br>过去通常用fgets()来代替gets()。C11标准新增的gets_s()函数也可代替gets()。用一个参数限制读入的字符数。</p>
<h2 id="fgets-和fputs"><a href="#fgets-和fputs" class="headerlink" title="fgets()和fputs()"></a>fgets()和fputs()</h2><p>fgets()函数通过<strong>第2个参数</strong>限制读入的字符数来解决溢出的问题。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别如下。</p>
<p>fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。</p>
<p>fgets()函数的<strong>第3个参数</strong>指明要读入的文件。如果读入从键盘输入的数据，则以<code>stdin</code>（标准输入）作为参数，该标识符定义在stdio.h中。<br>因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与 fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用<code>stdout</code>（标准输出）作为该参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STLEN 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> words[STLEN];</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please.&quot;</span>);</span><br><span class="line">	fgets(words, STLEN, <span class="built_in">stdin</span>); <span class="comment">// 典型用法</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your string twice:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(words);          <span class="comment">// 末尾有换行</span></span><br><span class="line">	<span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>); <span class="comment">// 末尾没有换行</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ol>
<li><p><code>unsigned long strlen(const char *p);</code><br>用以统计字符串的长度。（不包含‘\0’）</p>
</li>
<li><p><code>char *strcat(char *p, const char *q);</code></p>
<p> 用以拼接字符串，返回第一个参数</p>
</li>
<li><p><code>char *strncat(char *dest, const char *src, size_t count);</code><br>用以拼接字符串，返回第一个参数，第三个参数是能够添加字符数的大小</p>
</li>
<li><p><code>int strcmp(const char *cs, const char *ct);</code><br>由于非零值都为“真”，while (strcmp(str1, str2)) &#x2F;&#x2F;当str1和str2不相同时<br>如果两个字符串相等，则返回0</p>
</li>
<li><p><code>char *strcpy(char *p, const char *q); char *strncpy(char *p, const char *q, unsigned long size);</code><br>将str2拷贝到str1中</p>
</li>
<li><p><code>char *strchr(const char * s, int c);</code></p>
<p> 【参数】str 为要查找的字符串，c 为要查找的字符。<br> 【返回值】如果找到指定的字符则返回该字符所在地址，否则返回 NULL。<br> strchr() 将会找出 str 字符串中第一次出现的字符 c 的地址，然后将该地址返回。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* s = <span class="string">&quot;0123456789012345678901234567890&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* p = <span class="built_in">strchr</span>(s, <span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int sprintf( char *buffer, const char *format, [ argument] … );</code></p>
</li>
</ol>
<p><em><strong>buffer</strong></em>： char型指针，指向将要写入的字符串的缓冲区。<br><em><strong>format</strong></em>：格式化字符串。<br>***[argument]…***：可选参数，可以是任何类型的数据。<br><em><strong>return</strong></em>：成功则返回参数<code>buffer</code>字符串长度，失败则返回-1，错误原因存于errno 中。</p>
<pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, <span class="number">123</span>);  <span class="comment">//把整数123打印成一个字符串保存在s中</span></span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;The length of the string is more than %d\n&quot;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    srand(time(<span class="number">0</span>));  <span class="comment">// *随机种子</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        offset += <span class="built_in">sprintf</span>(str + offset, <span class="string">&quot;%d,&quot;</span>, rand() % <span class="number">100</span>);  <span class="comment">// 格式化的数据写入字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    str[offset - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The command line has %d arguments:\n&quot;</span>, argc - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; argc; count++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, count, argv[count]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="存储类别、链接和内存管理"><a href="#存储类别、链接和内存管理" class="headerlink" title="存储类别、链接和内存管理"></a>存储类别、链接和内存管理</h1><h2 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a>存储类别</h2><p>从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为对象（object）。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小。（面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言）</p>
<p>从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> entity = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * pc = <span class="string">&quot;Behold a string literal!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值的数组就是一个对象。由于数组中的每个字符都能被单独访问，所以每个字符也是一个对象。该声明还创建了一个标识符为pc的对象，储存着字符串的地址。由于<strong>可以设置pc重新指向其他字符串</strong>，所以<strong>标识符pc是一个可修改的左值</strong>。const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指向别的字符串。</p>
<p>可以用<strong>存储期（storage duration）</strong>描述对象，所谓存储期是指对象在内存中保留了多长时间。标识符用于访问对象，可以用作用域（scope）和链接（linkage）描述标识符，标识符的作用域和链接表明了程序的哪些部分可以使用它。<strong>不同的存储类别具有不同的存储期、作用域和链接。</strong>标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的<br>执行期存在。可以通过函数调用的方式显式分配和释放内存。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>C 变量有 3 种链接属性：外部链接、内部链接或无链接。具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。</p>
<p>C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。</p>
<p>一些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> giants = <span class="number">5</span>;　　　　　　　<span class="comment">// 文件作用域，外部链接</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dodgers = <span class="number">3</span>;　　 <span class="comment">// 文件作用域，内部链接</span></span><br><span class="line"><span class="type">int</span>　<span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储期"><a href="#存储期" class="headerlink" title="存储期"></a>存储期</h2><p>C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。</p>
<ul>
<li>静态存储期：它在程序的执行期间一直存在。无论是内部链接（static）还是外部链接，所有的文件作用域变量都具有静态存储期。</li>
<li>线程存储期：用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明（_Thread_local）时到线程结束一直存在。</li>
<li>自动存储期：局部变量。块作用域的变量通常都具有自动存储期，当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。</li>
<li>动态分配存储期：malloc()、free()。</li>
</ul>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><h3 id="块作用域的静态变量"><a href="#块作用域的静态变量" class="headerlink" title="块作用域的静态变量"></a>块作用域的静态变量</h3><p>“局部静态变量”是描述具有块作用域的静态变量的另一个术语。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trystat1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> stay = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= <span class="number">3</span>; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Here comes iteration %d:\n&quot;</span>, count);</span><br><span class="line">		trystat1();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;main: stay:%d\n&quot;</span>, stay);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trystat1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fade = <span class="number">1</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> stay = <span class="number">1</span>; <span class="comment">//块作用域的静态变量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fade = %d and stay = %d\n&quot;</span>, fade++, stay++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部链接的静态变量"><a href="#内部链接的静态变量" class="headerlink" title="内部链接的静态变量"></a>内部链接的静态变量</h3><p>普通的外部变量可用于同一程序中任意文件中的函数，但是内部链接的静态变量只能用于同一个文件中的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> svil = <span class="number">1</span>;   <span class="comment">// 静态变量，内部链接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。</p>
<h3 id="外部链接的静态变量"><a href="#外部链接的静态变量" class="headerlink" title="外部链接的静态变量"></a>外部链接的静态变量</h3><p>把变量的定义性声明（defining declaration）放在在所有函数的外面便创建了外部变量。当然，为了指出该函数使用了外部变量，可以在函数中用关键字<code>extern</code>再次声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Errupt;        <span class="comment">/* 外部定义的变量 ，定义式声明（defining declaration）*/</span></span><br><span class="line"><span class="type">double</span> Up[<span class="number">100</span>];    <span class="comment">/* 外部定义的数组 ，定义式声明（defining declaration）*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> Coal;  <span class="comment">/* 如果Coal被定义在另一个文件，引用式声明（referencing declaration） */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> Errupt;　　 <span class="comment">/* 可选的重复声明，引用式声明（referencing declaration）*/</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">double</span> Up[];　　<span class="comment">/* 可选的重复声明，引用式声明（referencing declaration）*/</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部变量只能初始化一次，且必须在定义该变量时进行，只有定义式声明才能初始化变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file1.c */</span></span><br><span class="line"><span class="type">int</span> Errupt = <span class="number">1</span>; <span class="comment">/* 定义式声明（defining declaration）+ 初始化 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* file2.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//以下声明错误：</span></span><br><span class="line"><span class="comment">//extern int Errupt = 1; /* 引用式声明（referencing declaration），不能初始化*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Errupt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Errupt = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Errupt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储类别说明符"><a href="#存储类别说明符" class="headerlink" title="存储类别说明符"></a>存储类别说明符</h2><p>C语言有6个关键字作为存储类别说明符：<code>auto</code>、<code>register</code>、<code>static</code>、<code>extern</code>、<code>_Thread_local</code>和<code>typedef</code>。</p>
<p>下面用一个简短的程序使用了5种存储类别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parta.c --- 不同的存储类别</span></span><br><span class="line"><span class="comment">// 与 partb.c 一起编译</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">report_count</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">accumulate</span><span class="params">(<span class="type">int</span> k)</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;     <span class="comment">// 文件作用域，外部链接</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> value;     <span class="comment">// 自动变量</span></span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> i;  <span class="comment">// 寄存器变量</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter a positive integer (0 to quit): &quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;value) == <span class="number">1</span> &amp;&amp; value &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++count;   <span class="comment">// 使用文件作用域变量</span></span><br><span class="line">		<span class="keyword">for</span> (i = value; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">			accumulate(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter a positive integer (0 to quit): &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	report_count();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">report_count</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Loop executed %d times\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partb.c -- 程序的其余部分</span></span><br><span class="line"><span class="comment">// 与 parta.c 一起编译</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;        <span class="comment">// 引用式声明，外部链接</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> total = <span class="number">0</span>;    <span class="comment">// 静态定义，内部链接</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">accumulate</span><span class="params">(<span class="type">int</span> k)</span>;  <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">accumulate</span><span class="params">(<span class="type">int</span> k)</span>   <span class="comment">// k具有块作用域，无链接</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> subtotal = <span class="number">0</span>;  <span class="comment">// 静态，无链接</span></span><br><span class="line">	<span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;loop cycle: %d\n&quot;</span>, count);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;subtotal: %d; total: %d\n&quot;</span>, subtotal, total);</span><br><span class="line">		subtotal = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		subtotal += k;</span><br><span class="line">		total += k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储类别和函数"><a href="#存储类别和函数" class="headerlink" title="存储类别和函数"></a>存储类别和函数</h2><p>函数也有存储类别，可以是外部函数（默认）或静态函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">gamma</span><span class="params">(<span class="type">double</span>)</span>;　　　<span class="comment">/* 该函数默认为外部函数 */</span></span><br><span class="line"><span class="type">static</span>　<span class="type">double</span>　<span class="title function_">beta</span><span class="params">(<span class="type">int</span>,　<span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span>　<span class="type">double</span>　<span class="title function_">delta</span><span class="params">(<span class="type">double</span>,　<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在同一个程序中，其他文件中的函数可以调用gamma()和delta()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。</p>
<p>通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，否则一般函数声明都默认为extern。</p>
<h2 id="随机数函数和静态变量"><a href="#随机数函数和静态变量" class="headerlink" title="随机数函数和静态变量"></a>随机数函数和静态变量</h2><p>ANSI C库提供了<code>rand()</code>函数生成随机数。生成随机数有多种算法，ANSI C允许C实现针对特定机器使用最佳算法。然而，ANSI  C标准还提供了一个可移植的标准算法，在不同系统中生成相同的随机数。实际上，<code>rand(</code>)是“伪随机数生成器”，意思是可预测生成数字的实际序列。但是，数字在其取值范围内均匀分布。</p>
<p>可移植版本的方案开始于一个“种子”数字。该函数使用该种子生成新的数，这个新数又成为新的种子。然后，新种子可用于生成更新的种子，以此类推。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rand0.c --生成随机数*/</span></span><br><span class="line"><span class="comment">/* 使用 ANSI C 可移植算法 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> next = <span class="number">1</span>; <span class="comment">/* 种子 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rand0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 生成伪随机数的魔术公式 */</span></span><br><span class="line">	next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(next / <span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* r_drive0.c -- 测试 rand0()函数 */</span></span><br><span class="line"><span class="comment">/* 与 rand0.c 一起编译*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rand0</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">5</span>; count++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand0());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：伪随机，每次运行的结果都相同。<br>改进：可以引入另一个函数srand1()重置种子来解决这个问题。关键是要让next成为只供rand1()和srand1()访问的内部链接静态变量（srand1()相当于C库中的srand()函数）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* s_and_r.c -- 包含 rand1() 和 srand1() 的文件 */</span></span><br><span class="line"><span class="comment">/*      使用 ANSI C 可移植算法  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> next = <span class="number">1</span>; <span class="comment">/* 种子 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*生成伪随机数的魔术公式*/</span></span><br><span class="line">	next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(next / <span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">srand1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span><br><span class="line">&#123;</span><br><span class="line">	next = seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* r_drive1.c -- 测试 rand1() 和 srand1() */</span></span><br><span class="line"><span class="comment">/* 与 s_and_r.c 一起编译 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">srand1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rand1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">unsigned</span> seed;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter your choice for seed.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;seed) == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		srand1(seed); <span class="comment">/* 重置种子 */</span></span><br><span class="line">		<span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">5</span>; count++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand1());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please enter next seed (q to quit):\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 C 实现允许访问一些可变的量（如，时钟系统），可以用这些值（可能会被截断）初始化种子值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> <span class="comment">/* 提供time()的ANSI原型*/</span></span></span><br><span class="line">srand1((<span class="type">unsigned</span> <span class="type">int</span>) time(<span class="number">0</span>)); <span class="comment">/* 初始化种子 */</span></span><br></pre></td></tr></table></figure>

<h2 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//diceroll.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">/* 提供rand()的原型 */</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> roll_count;</span><br><span class="line"><span class="type">int</span> <span class="title function_">roll_n_dice</span><span class="params">(<span class="type">int</span> dice, <span class="type">int</span> sides)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> rollem</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rollem</span><span class="params">(<span class="type">int</span> sides)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> roll;</span><br><span class="line">	roll = rand() % sides + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> roll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* diceroll.c -- 掷骰子模拟程序 */</span></span><br><span class="line"><span class="comment">/* 与 mandydice.c 一起编译 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;diceroll.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">/* 提供库函数 rand()的原型 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> roll_count = <span class="number">0</span>;      <span class="comment">/* 外部链接 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rollem</span><span class="params">(<span class="type">int</span> sides)</span> <span class="comment">/* 该函数属于该文件私有 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> roll;</span><br><span class="line">	roll = rand() % sides + <span class="number">1</span>;</span><br><span class="line">	++roll_count;       <span class="comment">/* 计算函数调用次数 */</span></span><br><span class="line">	<span class="keyword">return</span> roll;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">roll_n_dice</span><span class="params">(<span class="type">int</span> dice, <span class="type">int</span> sides)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">	<span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sides &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Need at least 2 sides.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">-2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dice &lt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Need at least 1 die.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (d = <span class="number">0</span>; d &lt; dice; d++)</span><br><span class="line">		total += rollem(sides);</span><br><span class="line">	<span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* manydice.c -- 多次掷骰子的模拟程序 */</span></span><br><span class="line"><span class="comment">/* 与 diceroll.c 一起编译*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>    <span class="comment">/* 为库函数 srand() 提供原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>     <span class="comment">/* 为 time() 提供原型      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;diceroll.h&quot;</span>   <span class="comment">/* 为roll_n_dice()提供原型，为roll_count变量提供声明 */</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> dice, roll;</span><br><span class="line">	<span class="type">int</span> sides;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="number">0</span>)); <span class="comment">/* 随机种子 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the number of sides per die, 0 to stop.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sides) == <span class="number">1</span> &amp;&amp; sides &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;How many dice?\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> ((status = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dice)) != <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (status == EOF)</span><br><span class="line">				<span class="keyword">break</span>;      <span class="comment">/* 退出循环 */</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;You should have entered an integer.&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; Let&#x27;s begin again.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">					<span class="keyword">continue</span>;   <span class="comment">/* 处理错误的输入 */</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;How many sides? Enter 0 to stop.\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;      <span class="comment">/* 进入循环的下一轮迭代 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		roll = roll_n_dice(dice, sides);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;You have rolled a %d using %d %d-sided dice.\n&quot;</span>,</span><br><span class="line">			roll, dice, sides);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;How many sides? Enter 0 to stop.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The rollem() function was called %d times.\n&quot;</span>,</span><br><span class="line">		roll_count);    <span class="comment">/* 使用外部变量 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;GOOD FORTUNE TO YOU!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分配内存：malloc-和free"><a href="#分配内存：malloc-和free" class="headerlink" title="分配内存：malloc()和free()"></a>分配内存：malloc()和free()</h2><p>malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。从ANSI C标准开始，<strong>C使用一个新的类型：指向void的指针。该类型相当于一个“通用指针”。</strong>malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被<strong>强制转换</strong>为匹配的类型。在ANSI  C中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向  void的指针赋给任意类型的指针完全不用考虑类型匹配的问题。如果 malloc()分配内存失败，将返回空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> * ptd;</span><br><span class="line">ptd = (<span class="type">double</span> *) <span class="built_in">malloc</span>(<span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"><span class="built_in">free</span>(ptd);</span><br></pre></td></tr></table></figure>

<p>通常，malloc()要与free()配套使用。free()函数的参数是之前malloc()返回的地址，该函数释放之前malloc()分配的内存。</p>
<p>设想malloc()和free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用free()把内存归还内存池中，这样便可重复使用这些内存。free()的参数应该是一个指针，指向由 malloc()分配的一块内存。<br>不能用 free()释放通过其他方式（如，声明一个数组）分配的内存。malloc()和free()的原型都在stdlib.h头文件中。</p>
<h3 id="calloc-函数"><a href="#calloc-函数" class="headerlink" title="calloc()函数"></a>calloc()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> * newmem;</span><br><span class="line">newmem = (<span class="type">long</span> *)<span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span> (<span class="type">long</span>));</span><br><span class="line"><span class="built_in">free</span>(newmem);</span><br></pre></td></tr></table></figure>

<h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span>* pi;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">pi = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//变长数组</span></span><br><span class="line"><span class="type">int</span> ar[n];<span class="comment">// 变长数组：编译错误</span></span><br></pre></td></tr></table></figure>

<h3 id="变长二位数组"><a href="#变长二位数组" class="headerlink" title="变长二位数组"></a>变长二位数组</h3><p>正确的做法是先分配行，再分配列。</p>
<p>释放内存的时候，要先释放列，再释放行。</p>
<p>注意，顺序反了的话，会把列的地址擦除，导致释放列时内存时找不到地址，程序崩溃。</p>
<p>正确的分配空间代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">5</span>, m = <span class="number">6</span>;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>** arr = (<span class="type">int</span>**)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		arr[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">			arr[i][j] = ++num;</span><br><span class="line">			offset += <span class="built_in">sprintf</span>(str + offset, <span class="string">&quot;%d,&quot;</span>, arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	str[offset - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//正确的释放空间代码如下：</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">free</span>(arr[i]);<span class="comment">/*释放列*/</span></span><br><span class="line">	<span class="built_in">free</span>(arr);<span class="comment">/*释放行*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种分配方式得到的其实并不是真正意义上的二维数组，因为其行与行之间的内存并不连续，虽然可以用下标arr[i][j]的方式访问，但当用指向该二维数组的指针来访问时候，不能通过指针值的增加来跨行获取元素，不过这种情况一般用的也不多，因此上述分配方式在大多数情况下的操作都能得到正确的结果。</p>
<h2 id="ANSI-C类型限定符"><a href="#ANSI-C类型限定符" class="headerlink" title="ANSI C类型限定符"></a>ANSI C类型限定符</h2><h3 id="const类型限定符"><a href="#const类型限定符" class="headerlink" title="const类型限定符"></a>const类型限定符</h3><p>以const关键字声明的对象，其值不能通过赋值或递增、递减来修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> nochange = <span class="number">12</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> days1[<span class="number">12</span>] = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> * pf; <span class="comment">/* pf 指向一个float类型的const值 */</span></span><br><span class="line"><span class="type">float</span> * <span class="type">const</span> pt; <span class="comment">/* pt 是一个const指针 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> * <span class="type">const</span> ptr;  <span class="comment">/* 表明ptr既不能指向别处，它所指向的值也不能改变。 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="type">const</span> * pfc; <span class="comment">// 与const float * pfc;相同</span></span><br></pre></td></tr></table></figure>

<p>就近原则：const 跟 float 还是 * 更近。<br>创建了 pf 指向的值不能被改变，而 pf 本身的值可以改变。<br>创建的指针pt本身的值不能更改。pt必须指向同一个地址，但是它所指向的值可以改变。</p>
<p><strong>const放在<em>左侧任意位置，限定了指针指向的数据不能改变；const放在</em>的右侧，限定了指针本身不能改变。</strong></p>
<h3 id="volatile类型限定符"><a href="#volatile类型限定符" class="headerlink" title="volatile类型限定符"></a>volatile类型限定符</h3><p><strong>1、为什么用volatile？</strong></p>
<p>volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及<strong>在其他程序或同时运行的线程中共享数据</strong>。例如，一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算机传入的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vall = x;</span><br><span class="line"><span class="comment">/* 一些不使用 x 的代码*/</span></span><br><span class="line">val2　=　x;</span><br></pre></td></tr></table></figure>

<p>现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但<strong>并未改变它的值</strong>。于是编译器把 x的值临时储存在<strong>寄存器</strong>中，然后在val2需要使用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时间。这个过程被称为<strong>高速缓存（caching）</strong>。</p>
<p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="type">int</span> b = i;</span><br></pre></td></tr></table></figure>

<p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 <strong>i的地址中（内存）读取</strong>，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。volatile 可以保证对特殊地址的稳定访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, a);</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov dword ptr[ebp - <span class="number">4</span>], <span class="number">20</span>h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般说来，volatile用在如下的几个地方：</p>
<ul>
<li><ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</li>
</ol>
</li>
<li><ol start="2">
<li>多任务环境下各任务间共享的标志应该加 volatile；</li>
</ol>
</li>
<li><ol start="3">
<li>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
</li>
</ul>
<p>可以同时用const和volatile限定一个值。例如，通常用const把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">const</span> <span class="type">int</span> loc;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> * ploc;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">C&#x2F;C++ 中 volatile 关键字详解</a></p>
<h3 id="restrict类型限定符"><a href="#restrict类型限定符" class="headerlink" title="restrict类型限定符"></a>restrict类型限定符</h3><p>restrict  关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ar[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> * <span class="keyword">restrict</span> restar = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> * par = ar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>　(n　=　<span class="number">0</span>;　n　&lt;　<span class="number">10</span>;　n++)</span><br><span class="line">&#123;</span><br><span class="line">	par[n]　+=　<span class="number">5</span>;</span><br><span class="line">	restar[n]　+=　<span class="number">5</span>;</span><br><span class="line">	ar[n] *= <span class="number">2</span>;</span><br><span class="line">	par[n]　+=　<span class="number">3</span>;</span><br><span class="line">	restar[n]　+=　<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式，编译器可以把涉及 restar的两条语句替换成下面这条语句，效果相同：<br><code>restar[n] += 8; /* 可以进行替换 */</code></p>
<p>restrict  限定符还可用于函数形参中的指针。这意味着编译器可以假定<strong>在函数体内其他标识符不会修改该指针指向的数据</strong>，而且编译器可以尝试对其优化，使其不做别的用途。例如，C 库有两个函数用于把一个位置上的字节拷贝到另一个位置。在C99中，这两个函数的原型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">void</span> * <span class="keyword">restrict</span> s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">memmove</span><span class="params">(<span class="type">void</span> * s1, <span class="type">const</span> <span class="type">void</span> * s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Atomic类型限定符（C11）"><a href="#Atomic类型限定符（C11）" class="headerlink" title="_Atomic类型限定符（C11）"></a>_Atomic类型限定符（C11）</h3><p>并发程序设计把程序执行分成可以同时执行的多个线程。这给程序设计带来了新的挑战，包括如何管理访问相同数据的不同线程。C11通过包含可选的头文件stdatomic.h和threads.h，提供了一些可选的（不是必须实现的）管理方法。值得注意的是，要通过各种宏函数来访问原子类型。当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_Atomic</span> <span class="type">int</span> hogs;　　　　　　<span class="comment">// hogs 是一个原子类型的变量</span></span><br><span class="line"><span class="type">atomic_store</span>(&amp;hogs, <span class="number">12</span>);　<span class="comment">// stdatomic.h中的宏</span></span><br></pre></td></tr></table></figure>

<h1 id="文件输入-x2F-输出"><a href="#文件输入-x2F-输出" class="headerlink" title="文件输入&#x2F;输出"></a>文件输入&#x2F;输出</h1><p>函数：fopen()、getc()、putc()、exit()、fclose()<br>fprintf()、fscanf()、fgets()、fputs()<br>rewind()、fseek()、ftell()、fflush()<br>fgetpos()、fsetpos()、feof()、ferror()<br>ungetc()、setvbuf()、fread()、fwrite()</p>
<p>C程序把输入看作是字节流(文本流或二进制流)，<strong>输入流</strong>来源于文件、输入设备（如键盘），或者甚至是另一个程序的输出。类似地，C程序把输出也看作是字节流，<strong>输出流</strong>的目的地可以是文件、视频显示等。</p>
<h2 id="与文件进行通信"><a href="#与文件进行通信" class="headerlink" title="与文件进行通信"></a>与文件进行通信</h2><h3 id="二进制模式和文本模式"><a href="#二进制模式和文本模式" class="headerlink" title="二进制模式和文本模式"></a>二进制模式和文本模式</h3><p>C 提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式中，程序所见的内容和文件的实际内容不同。</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%205.png"></p>
<h3 id="I-x2F-O的级别"><a href="#I-x2F-O的级别" class="headerlink" title="I&#x2F;O的级别"></a>I&#x2F;O的级别</h3><p>可以选择I&#x2F;O的两个级别（即处理文件访问的两个级别）。底层I&#x2F;O（low-level I&#x2F;O）使用操作系统提供的<br>基本I&#x2F;O服务。标准高级I&#x2F;O（standard  high-level  I&#x2F;O）使用C库的标准包和stdio.h头文件定义。因为无法保证所有的操作系统都使用相同的底层I&#x2F;O模型，C标准只支持标准I&#x2F;O包。有些实现会提供底层库，但是C标准建立了可移植的I&#x2F;O模型，我们主要讨论这些I&#x2F;O。</p>
<h3 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h3><p>C程序会自动打开3个文件，它们被称为标准输入（standard input）、标准输出（standard output）和标准错误输出（standard error output）。在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。</p>
<p>通常，标准输入为程序提供输入，它是 getchar()和 scanf()使用的文件。程序通常输出到标准输出，它是putchar()、puts()和printf()使用的文件。</p>
<h2 id="标准I-x2F-O"><a href="#标准I-x2F-O" class="headerlink" title="标准I&#x2F;O"></a>标准I&#x2F;O</h2><p>与底层I&#x2F;O相比，标准I&#x2F;O包除了可移植以外还有两个好处。第一，标准I&#x2F;O有许多专门的函数简化了处理不同I&#x2F;O的问题。例如，printf()把不同形式的数据转换成与终端相适应的字符串输出。第二，输入和输出都是缓冲的。也就是说，一次转移一大块信息而不是一字节信息（通常至少512字节）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* count.c -- 使用标准 I/O */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">// 提供 exit()的原型</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ch;<span class="comment">// 读取文件时，储存每个字符的地方</span></span><br><span class="line">	FILE* fp;<span class="comment">// “文件指针”</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> ((ch = getc(fp)) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		putc(ch, <span class="built_in">stdout</span>);<span class="comment">// 与 putchar(ch); 相同</span></span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;File %s has %lu characters\n&quot;</span>, argv[<span class="number">1</span>], count);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%206.png"></p>
<h3 id="getc-和putc-函数"><a href="#getc-和putc-函数" class="headerlink" title="getc()和putc()函数"></a>getc()和putc()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch = getchar();     <span class="comment">//“从标准输入中获取一个字符”：</span></span><br><span class="line">ch = getc(fp);      <span class="comment">//“从fp指定的文件中获取一个字符”：</span></span><br><span class="line"><span class="built_in">putchar</span>(ch);        <span class="comment">//“把字符ch放入标准输出中”：</span></span><br><span class="line">putc(ch,<span class="built_in">stdout</span>);</span><br><span class="line">putc(ch, fpout);    <span class="comment">//“把字符ch放入FILE指针fpout指定的文件中”：</span></span><br></pre></td></tr></table></figure>

<h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><p>getc()函数在读取一个字符时发现是文件结尾，它将返回一个特殊值EOF。</p>
<h3 id="fclose-函数"><a href="#fclose-函数" class="headerlink" title="fclose()函数"></a>fclose()函数</h3><p>如果成功关闭，fclose()函数返回0，否则返回EOF：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Error in closing file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="指向标准文件的指针"><a href="#指向标准文件的指针" class="headerlink" title="指向标准文件的指针"></a>指向标准文件的指针</h3><p>stdio.h头文件把3个文件指针与3个标准文件相关联，C程序会自动打开这3个标准文件。</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%207.png"></p>
<p>这些文件指针都是指向FILE的指针，所以它们可用作标准I&#x2F;O函数的参数，如fclose(fp)中的fp。</p>
<h2 id="一个简单的文件压缩程序"><a href="#一个简单的文件压缩程序" class="headerlink" title="一个简单的文件压缩程序"></a>一个简单的文件压缩程序</h2><p>问题描述：把一个文件中选定的数据拷贝到另一个文件中。该程序同时打开了两个文件，以”r”模式打开一个，以”w”模式打开另一个。以保留每3个字符中的第1个字符的方式压缩第1个文件的内容。最后，把压缩后的文本存入第2个文件。第2个文件的名称是第1个文件名加上.red后缀。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducto.c –把文件压缩成原来的1/3！</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">// 提供 exit()的原型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span><span class="comment">// 提供 strcpy()、strcat()的原型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 40</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* in, * out;<span class="comment">// 声明两个指向 FILE 的指针</span></span><br><span class="line">	<span class="type">int</span> ch;</span><br><span class="line">	<span class="type">char</span> name[LEN];<span class="comment">// 储存输出文件名</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 检查命令行参数</span></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置输入</span></span><br><span class="line">	<span class="keyword">if</span> ((in = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;I couldn&#x27;t open the file \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">			argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置输出</span></span><br><span class="line">	<span class="built_in">strncpy</span>(name, argv[<span class="number">1</span>], LEN - <span class="number">5</span>);<span class="comment">// 拷贝文件名</span></span><br><span class="line">	name[LEN - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">strcat</span>(name, <span class="string">&quot;.red&quot;</span>);<span class="comment">// 在文件名后添加.red</span></span><br><span class="line">	<span class="keyword">if</span> ((out = fopen(name, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;<span class="comment">// 以写模式打开文件</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t create output file.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 拷贝数据</span></span><br><span class="line">	<span class="keyword">while</span> ((ch = getc(in)) != EOF)</span><br><span class="line">		<span class="keyword">if</span> (count++ % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">			putc(ch, out);<span class="comment">// 打印3个字符中的第1个字符</span></span><br><span class="line">			<span class="comment">// 收尾工作</span></span><br><span class="line">	<span class="keyword">if</span> (fclose(in) != <span class="number">0</span> || fclose(out) != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in closing files\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件I-x2F-O：fprintf-、fscanf-、fgets-和fputs"><a href="#文件I-x2F-O：fprintf-、fscanf-、fgets-和fputs" class="headerlink" title="文件I&#x2F;O：fprintf()、fscanf()、fgets()和fputs()"></a>文件I&#x2F;O：fprintf()、fscanf()、fgets()和fputs()</h2><p>I&#x2F;O函数都类似于文件I&#x2F;O函数。它们的主要区别是，文件I&#x2F;O函数要用FILE指针指定待处理的文件。与  getc()、putc()类似，这些函数都要求用指向 FILE 的指针（如，stdout）指定一个文件，或者使用fopen()的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Can&#x27;t open \&quot;wordy\&quot; file.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s\n&quot;</span>, words);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, words) == <span class="number">1</span>)</span><br><span class="line">	<span class="built_in">puts</span>(words);</span><br></pre></td></tr></table></figure>

<p><code>fgets(buf, STLEN, fp);</code><br>输入函数，读操作，buf是char类型数组的名称，STLEN是字符串的大小，fp是指向FILE的指针。</p>
<p><code>fputs(buf, fp);</code><br>输出函数，写操作，这里，buf是字符串的地址，fp用于指定目标文件。</p>
<p>ch &#x3D; getc(fp);      &#x2F;&#x2F;输入流→输入缓冲区<br>putchar(ch);<br>putc(ch,stdout);  &#x2F;&#x2F;输出缓冲区→输出流</p>
<h2 id="随机访问：fseek-和ftell"><a href="#随机访问：fseek-和ftell" class="headerlink" title="随机访问：fseek()和ftell()"></a>随机访问：fseek()和ftell()</h2><p>有了 fseek()函数，便可把文件看作是数组，在 fopen()打开的文件中直接移动到任意字节处。</p>
<p><code>fseek(fp, offset, SEEK_MODE);</code></p>
<p>fseek()的第1个参数是FILE指针，指向待查找的文件，fopen()应该已打开该文件。</p>
<p>fseek()的第2个参数是偏移量（offset）。该参数表示从起始点开始要移动的距离（参见表13.3列出的起始点模式）。该参数必须是一个long类型的值，可以为正（前移）、负（后移）或0（保持不动）</p>
<p>fseek()的第3个参数是模式，该参数确定起始点。</p>
<p>如果一切正常，fseek()的返回值为0；如果出现错误（如试图移动的距离超出文件的范围），其返回值为-1。</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%208.png"></p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%209.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET); <span class="comment">// 定位至文件开始处</span></span><br><span class="line">fseek(fp, <span class="number">10L</span>, SEEK_SET); <span class="comment">// 定位至文件中的第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR); <span class="comment">// 从文件当前位置前移2个字节</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END); <span class="comment">// 定位至文件结尾</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END); <span class="comment">// 从文件结尾处回退10个字节</span></span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END); <span class="comment">// 把当前位置设置为距文件末尾 0 字节偏移量。</span></span><br><span class="line"><span class="type">long</span> last = ftell(fp);        <span class="comment">// 把从文件开始处到文件结尾的字节数赋给last。</span></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">1L</span>; count &lt;= last; count++)</span><br><span class="line">&#123;</span><br><span class="line">	fseek(fp, -count, SEEK_END); <span class="comment">/* go backward */</span></span><br><span class="line">	ch = getc(fp);   <span class="comment">// 从后往前输出字符到fp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fgetpos-和fsetpos-函数"><a href="#fgetpos-和fsetpos-函数" class="headerlink" title="fgetpos()和fsetpos()函数"></a>fgetpos()和fsetpos()函数</h2><p>ANSI  C新增了两个处理较大文件的新定位函数：fgetpos()和 fsetpos()。这两个函数不使用 long 类型的值表示位置，它们使用一种新类型：fpos_t（代表file, position, type，文件定位类型）。fpos_t类型不是基本类型，它根据其他类型来定义。</p>
<p><code>int fgetpos(FILE * restrict stream, fpos_t * restrict pos);</code></p>
<p>调用该函数时，它把fpos_t类型的值放在pos指向的位置上，该值描述了文件中的一个位置。如果成功，fgetpos()函数返回0；如果失败，返回非0。</p>
<p><code>int fsetpos(FILE *stream, const fpos_t *pos);</code></p>
<p>调用该函数时，使用pos指向位置上的fpos_t类型值来设置文件指针指向该值指定的位置。如果成功，fsetpos()函数返回0；如果失败，则返回非0。fpos_t类型的值应通过之前调用fgetpos()获得。</p>
<h2 id="标准I-x2F-O的机理"><a href="#标准I-x2F-O的机理" class="headerlink" title="标准I&#x2F;O的机理"></a>标准I&#x2F;O的机理</h2><h3 id="调用fopen-打开文件"><a href="#调用fopen-打开文件" class="headerlink" title="调用fopen()打开文件"></a>调用fopen()打开文件</h3><p>fopen()函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen()返回一个指向该结构的指针，以便其他函数知道如何找到该结构。</p>
<h3 id="文件输入：调用fscanf-、getc-或-fgets-将输入流拷贝到输入缓冲区"><a href="#文件输入：调用fscanf-、getc-或-fgets-将输入流拷贝到输入缓冲区" class="headerlink" title="文件输入：调用fscanf()、getc()或 fgets()将输入流拷贝到输入缓冲区"></a>文件输入：调用fscanf()、getc()或 fgets()将输入流拷贝到输入缓冲区</h3><p>调用这些函数，文件中的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而异，一般是512字节或是它的倍数，如4096。最初调用函数，除了填充缓冲区外，还要设置fp所指向的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从字节0开始。</p>
<p>当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中。</p>
<h3 id="文件输出：调用fprinf-、putc-或-fputs-将输出缓冲区拷贝到输出流"><a href="#文件输出：调用fprinf-、putc-或-fputs-将输出缓冲区拷贝到输出流" class="headerlink" title="文件输出：调用fprinf()、putc()或 fputs()将输出缓冲区拷贝到输出流"></a>文件输出：调用fprinf()、putc()或 fputs()将输出缓冲区拷贝到输出流</h3><p>输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。</p>
<h2 id="ungetc-、fllush-、setvbuf-函数"><a href="#ungetc-、fllush-、setvbuf-函数" class="headerlink" title="ungetc()、fllush()、setvbuf()函数"></a>ungetc()、fllush()、setvbuf()函数</h2><p>int ungetc()函数把c指定的字符放回输入流中。如果把一个字符放回输入流，下次调用标准输入函数时将读取该字符。</p>
<p><code>int ungetc(int c, FILE *fp);</code></p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2010.png"></p>
<p><code>int fflush(FILE *fp);</code></p>
<p>调用fflush()函数引起输出缓冲区中所有的未写入数据被发送到fp指定的输出文件。这个过程称为刷新缓冲区。只要最近一次操作不是输入操作，就可以用该函数来更新流（任何读写模式）。</p>
<p><code>int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);</code></p>
<p>setvbuf()函数创建了一个供标准I&#x2F;O函数替换使用的缓冲区。在打开文件后且未对流进行其他操作之前，调用该函数。</p>
<p>假设一个程序要储存一种数据对象，每个数据对象的大小是3000字节。可以使用setvbuf()函数创建一个缓冲区，其大小是该数据对象大小的倍数。</p>
<h2 id="二进制I-x2F-O：fread-和fwrite"><a href="#二进制I-x2F-O：fread-和fwrite" class="headerlink" title="二进制I&#x2F;O：fread()和fwrite()"></a>二进制I&#x2F;O：fread()和fwrite()</h2><h3 id="为什么需要用二进制文件存储？"><a href="#为什么需要用二进制文件存储？" class="headerlink" title="为什么需要用二进制文件存储？"></a>为什么需要用二进制文件存储？</h3><p>之前用到的标准I&#x2F;O函数都是面向文本的，用于处理字符和字符串。如何要在文件中保存数值数据？用 fprintf()函数和%f转换说明只是把数值保存为字符串。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> num = <span class="number">1.</span>/<span class="number">3.</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%f&quot;</span>, num);</span><br></pre></td></tr></table></figure>

<p>把num储存为8个字符：0.333333。</p>
<p>为保证数值在储存前后一致，最精确的做法是使用与计算机相同的位组合来储存。因此，double 类型的值应该储存在一个 double 大小的单元中。如果以程序所用的表示法把数据储存在文件中，则称以二进制形式储存数据。这样就不存在从数值形式到字符串的转换过程。</p>
<p>实际上，所有的数据都是以二进制形式储存的，甚至连字符都以字符码的二进制表示来储存。如果文件中的所有数据都被解释成字符码，则称该文件包含文本数据。如果部分或所有的数据都被解释成二进制形式的数值数据，则称该文件包含二进制数据（另外，用数据表示机器语言指令的文件都是二进制文件）</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2011.png"></p>
<h3 id="fwrite-函数"><a href="#fwrite-函数" class="headerlink" title="fwrite()函数"></a>fwrite()函数</h3><p><code>size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp);</code></p>
<p>fwrite()函数把二进制数据写入文件。fwrite()函数返回成功写入项的数量。正常情况下，该返回值就是nmemb，但如果出现写入错误，返回值会比nmemb小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">fwrite(buffer, <span class="number">256</span>, <span class="number">1</span>, fp);</span><br><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fwrite(earnings, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">10</span>, fp);</span><br></pre></td></tr></table></figure>

<p>fwrite()原型中的const void * restrict ptr声明。fwrite()的一个问题是，它的第1个参数不是固定的类型。例如，第1个例子中使用buffer，其类型是指向char的指针；而第2个例子中使用earnings，其类型是指向double的指针。在ANSI  C函数原型中，这些实际参数都被转换成指向void的指针类型，这种指针可作为一种通用类型指针（在ANSI C之前，这些参数使用char*类型，需要把实参强制转换成char *类型）。</p>
<h3 id="fread-函数"><a href="#fread-函数" class="headerlink" title="fread()函数"></a>fread()函数</h3><p><code>size_t fread(void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp);</code></p>
<p>fwrite()函数把文件中的二进制数据读入数据指针。ffread()函数返回成功读取项的数量。正常情况下，该返回值就是nmemb，但如果出现读取错误或读到文件结尾，该返回值就会比nmemb小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fread(earnings, <span class="keyword">sizeof</span> (<span class="type">double</span>), <span class="number">10</span>, fp); <span class="comment">// 该调用把10个double大小的值拷贝进earnings数组中</span></span><br></pre></td></tr></table></figure>

<p>如果标准输入函数返回 EOF，则通常表明函数已到达文件结尾。然而，出现读取错误时，函数也会返回EOF。feof()和ferror()函数用于区分这两种情况。当上一次输入调用检测到文件结尾时，feof()函数返回一个非零值，否则返回0。当读或写出现错误，ferror()函数返回一个非零值，否则返回0。</p>
<h3 id="程序：使用fread-和fwrite-函数进行拷贝"><a href="#程序：使用fread-和fwrite-函数进行拷贝" class="headerlink" title="程序：使用fread()和fwrite()函数进行拷贝"></a>程序：使用fread()和fwrite()函数进行拷贝</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* append.c -- 把文件附加到另一个文件末尾 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEN 81</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">append</span><span class="params">(FILE* source, FILE* dest)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span>* st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE* fa, * fs;<span class="comment">// fa 指向目标文件，fs 指向源文件</span></span><br><span class="line">	<span class="type">int</span> files = <span class="number">0</span>;<span class="comment">// 附加的文件数量</span></span><br><span class="line">	<span class="type">char</span> file_app[SLEN];<span class="comment">// 目标文件名</span></span><br><span class="line">	<span class="type">char</span> file_src[SLEN];<span class="comment">// 源文件名</span></span><br><span class="line">	<span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Enter name of destination file:&quot;</span>);</span><br><span class="line">	s_gets(file_app, SLEN);</span><br><span class="line">	<span class="keyword">if</span> ((fa = fopen(file_app, <span class="string">&quot;a+&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, file_app);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (setvbuf(fa, <span class="literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">&quot;Can&#x27;t create output buffer\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Enter name of first source file (empty line to quit):&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (s_gets(file_src, SLEN) &amp;&amp; file_src[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(file_src, file_app) == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">fputs</span>(<span class="string">&quot;Can&#x27;t append file to itself\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((fs = fopen(file_src, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, file_src);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (setvbuf(fs, <span class="literal">NULL</span>, _IOFBF, BUFSIZE) != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fputs</span>(<span class="string">&quot;Can&#x27;t create input buffer\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			append(fs, fa);</span><br><span class="line">			<span class="keyword">if</span> (ferror(fs) != <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in reading file %s.\n&quot;</span>,</span><br><span class="line">					file_src);</span><br><span class="line">			<span class="keyword">if</span> (ferror(fa) != <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in writing file %s.\n&quot;</span>,</span><br><span class="line">					file_app);</span><br><span class="line">			fclose(fs);</span><br><span class="line">			files++;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;File %s appended.\n&quot;</span>, file_src);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Next file (empty line to quit):&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Done appending.%d files appended.\n&quot;</span>, files);</span><br><span class="line">	rewind(fa);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s contents:\n&quot;</span>, file_app);</span><br><span class="line">	<span class="keyword">while</span> ((ch = getc(fa)) != EOF)</span><br><span class="line">		<span class="built_in">putchar</span>(ch);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Done displaying.&quot;</span>);</span><br><span class="line">	fclose(fa);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">append</span><span class="params">(FILE* source, FILE* dest)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> bytes;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> temp[BUFSIZE]; <span class="comment">// 只分配一次</span></span><br><span class="line">	<span class="keyword">while</span> ((bytes = fread(temp, <span class="keyword">sizeof</span>(<span class="type">char</span>), BUFSIZE, source)) &gt; <span class="number">0</span>)</span><br><span class="line">		fwrite(temp, <span class="keyword">sizeof</span>(<span class="type">char</span>), bytes, dest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span>* st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* ret_val;</span><br><span class="line">	<span class="type">char</span>* find;</span><br><span class="line">	ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">		find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);<span class="comment">// 查找换行符</span></span><br><span class="line">		<span class="keyword">if</span> (find)<span class="comment">// 如果地址不是NULL，</span></span><br><span class="line">			*find = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">// 在此处放置一个空字符</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="程序：用二进制I-x2F-O进行随机访问"><a href="#程序：用二进制I-x2F-O进行随机访问" class="headerlink" title="程序：用二进制I&#x2F;O进行随机访问"></a>程序：用二进制I&#x2F;O进行随机访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* randbin.c -- 用二进制I/O进行随机访问 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARSIZE 1000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> numbers[ARSIZE];</span><br><span class="line">	<span class="type">double</span> value;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* file = <span class="string">&quot;numbers.dat&quot;</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">long</span> pos;</span><br><span class="line">	FILE* iofile;</span><br><span class="line">	<span class="comment">// 创建一组 double类型的值</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARSIZE; i++)</span><br><span class="line">		numbers[i] = <span class="number">100.0</span> * i + <span class="number">1.0</span> / (i + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 尝试打开文件</span></span><br><span class="line">	<span class="keyword">if</span> ((iofile = fopen(file, <span class="string">&quot;wb&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not open %s for output.\n&quot;</span>, file);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以二进制格式把数组写入文件</span></span><br><span class="line">	fwrite(numbers, <span class="keyword">sizeof</span>(<span class="type">double</span>), ARSIZE, iofile);</span><br><span class="line">	fclose(iofile);</span><br><span class="line">	<span class="keyword">if</span> ((iofile = fopen(file, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">			<span class="string">&quot;Could not open %s for random access.\n&quot;</span>, file);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从文件中读取选定的内容</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter an index in the range 0-%d.\n&quot;</span>, ARSIZE - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i) == <span class="number">1</span> &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; i &lt; ARSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		pos = (<span class="type">long</span>)i * <span class="keyword">sizeof</span>(<span class="type">double</span>);<span class="comment">// 计算偏移量</span></span><br><span class="line">		fseek(iofile, pos, SEEK_SET);<span class="comment">// 定位到此处</span></span><br><span class="line">		fread(&amp;value, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">1</span>, iofile);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;The value there is %f.\n&quot;</span>, value);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Next index (out of range to quit):\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 完成</span></span><br><span class="line">	fclose(iofile);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构和其他数据形式"><a href="#结构和其他数据形式" class="headerlink" title="结构和其他数据形式"></a>结构和其他数据形式</h1><p>关键字：struct、union、typedef<br>运算符：.和-&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* book.c -- 一本书的图书目录 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span>* st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTITL 41<span class="comment">/* 书名的最大长度 + 1*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXAUTL 31<span class="comment">/* 作者姓名的最大长度 + 1*/</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span><span class="comment">/* 结构模版：标记是 book */</span></span><br><span class="line">	<span class="type">char</span> title[MAXTITL];</span><br><span class="line">	<span class="type">char</span> author[MAXAUTL];</span><br><span class="line">	<span class="type">float</span> value;</span><br><span class="line">&#125;;<span class="comment">/* 结构模版结束*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span><span class="comment">/* 把 library 声明为一个 book 类型的变量 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter the book title.\n&quot;</span>);</span><br><span class="line">	s_gets(library.title, MAXTITL);<span class="comment">/* 访问title部分*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now enter the author.\n&quot;</span>);</span><br><span class="line">	s_gets(library.author, MAXAUTL);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now enter the value.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;library.value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s by %s: $%.2f\n&quot;</span>, library.title,</span><br><span class="line">		library.author, library.value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s: \&quot;%s\&quot; ($%.2f)\n&quot;</span>, library.author,</span><br><span class="line">		library.title, library.value);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Done.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span>* st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* ret_val;</span><br><span class="line">	<span class="type">char</span>* find;</span><br><span class="line">	ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">		find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);<span class="comment">// 查找换行符</span></span><br><span class="line">		<span class="keyword">if</span> (find)<span class="comment">// 如果地址不是 NULL,</span></span><br><span class="line">			*find = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">// 在此处放置一个空字符</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">//处理输入行中剩余的字符</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。<br>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fgets.html">C 库函数 - fgets()</a></p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2012.png"></p>
<h2 id="定义结构变量"><a href="#定义结构变量" class="headerlink" title="定义结构变量"></a>定义结构变量</h2><h3 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h3><p>初始化变量和数组如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> fibo[<span class="number">7</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>结构变量是否也可以这样初始化？是的，可以。初始化一个结构变量与初始化数组的语法类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span><span class="comment">/* 结构模版：标记是 book */</span></span><br><span class="line">	<span class="type">char</span> title[MAXTITL];</span><br><span class="line">	<span class="type">char</span> author[MAXAUTL];</span><br><span class="line">	<span class="type">float</span> value;</span><br><span class="line">&#125;;<span class="comment">/* 结构模版结束*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> =</span> &#123;</span><br><span class="line"><span class="string">&quot;The Pious Pirate and the Devious Damsel&quot;</span>,</span><br><span class="line"><span class="string">&quot;Renee Vivotte&quot;</span>,</span><br><span class="line"><span class="number">1.95</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">bill</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,bill.value);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">newt</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,bill-&gt;value);</span><br></pre></td></tr></table></figure>

<h2 id="其他结构特性"><a href="#其他结构特性" class="headerlink" title="其他结构特性"></a>其他结构特性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o_data = n_data; <span class="comment">// 把一个结构赋值给另一个结构</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">right_field</span> =</span> &#123;<span class="string">&quot;Ruthie&quot;</span>, <span class="string">&quot;George&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">captain</span> =</span> right_field; <span class="comment">// 把一个结构初始化为另一个结构</span></span><br></pre></td></tr></table></figure>

<p>结构中的字符数组和字符指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 20</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line"><span class="type">char</span> first[LEN];</span><br><span class="line"><span class="type">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line"><span class="type">char</span> * first;</span><br><span class="line"><span class="type">char</span> * last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">veep</span> =</span> &#123;<span class="string">&quot;Talia&quot;</span>, <span class="string">&quot;Summers&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">treas</span> =</span> &#123;<span class="string">&quot;Brad&quot;</span>, <span class="string">&quot;Fallingjaw&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s and %s\n&quot;</span>, veep.first, treas.first);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, attorney.last);　　<span class="comment">/* 这里有一个潜在的危险 */</span></span><br></pre></td></tr></table></figure>

<p>对于struct names类型的结构变量veep，以上字符串都储存在结构内部，结构总共要分配40字节储存姓名。然而，对于struct pnames类型的结构变量treas，以上字符串储存在编译器储存常量的地方。结构本身只储存了两个地址，在我们的系统中共占16字节（一个指针在64位的计算机上，占8个字节；一个指针在32位的计算机上，占4个字节）。<br>如果要用结构储存字符串，用字符数组作为成员比较简单。用指向 char 的指针也行，但是误用会导致严重的问题。</p>
<p>如果使用malloc()分配内存并使用指针储存该地址，那么在结构中使用指针处理字符串就比较合理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">namect</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> * fname; <span class="comment">// 用指针代替数组</span></span><br><span class="line">	<span class="type">char</span> * lname;</span><br><span class="line">	<span class="type">int</span> letters;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getinfo</span> <span class="params">(<span class="keyword">struct</span> namect * pst)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> temp[SLEN];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter your first name.\n&quot;</span>);</span><br><span class="line">	s_gets(temp, SLEN);</span><br><span class="line">	<span class="comment">// 分配内存储存名</span></span><br><span class="line">	pst-&gt;fname = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(temp) + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 把名拷贝到已分配的内存</span></span><br><span class="line">	<span class="built_in">strcpy</span>(pst-&gt;fname, temp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please enter your last name.\n&quot;</span>);</span><br><span class="line">	s_gets(temp, SLEN);</span><br><span class="line">	pst-&gt;lname = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(temp) + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(pst-&gt;lname, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="keyword">struct</span> namect * pst)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(pst-&gt;fname);</span><br><span class="line">	<span class="built_in">free</span>(pst-&gt;lname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复合字面量"><a href="#复合字面量" class="headerlink" title="复合字面量"></a>复合字面量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">struct</span> book) &#123;<span class="string">&quot;The Idiot&quot;</span>, <span class="string">&quot;Fyodor Dostoyevsky&quot;</span>, <span class="number">6.99</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伸缩型数组成员（flexible-array-member）"><a href="#伸缩型数组成员（flexible-array-member）" class="headerlink" title="伸缩型数组成员（flexible array member）"></a>伸缩型数组成员（flexible array member）</h3><p>利用这项特性声明的结构，其最后一个数组成员具有一些特性。第1个特性是，该数组不会立即存在。第2个特性是，使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">double</span> average;</span><br><span class="line"><span class="type">double</span> scores[];　<span class="comment">// 伸缩型数组成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flex</span> * <span class="title">pf</span>;</span> <span class="comment">// 声明一个指针</span></span><br><span class="line"><span class="comment">// 请求为一个结构和一个数组分配存储空间</span></span><br><span class="line">pf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> flex) + <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure>

<p>带伸缩型数组成员的结构确实有一些特殊的处理要求。第一，不能用结构进行赋值或拷贝：</p>
<p><code>*pf2 = *pf1;　// 不要这样做</code></p>
<p>这样做只能拷贝除伸缩型数组成员以外的其他成员。确实要进行拷贝，应使用memcpy()函数。</p>
<p>第二，不要以按值方式把这种结构传递给结构。原因相同，按值传递一个参数与赋值类似。要把结构的地址传递给函数。<br>第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员。</p>
<h3 id="匿名结构（C11）"><a href="#匿名结构（C11）" class="headerlink" title="匿名结构（C11）"></a>匿名结构（C11）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">char</span> first[<span class="number">20</span>]; <span class="type">char</span> last[<span class="number">20</span>];&#125;; <span class="comment">// 匿名结构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">ted</span> =</span> &#123;<span class="number">8483</span>, &#123;<span class="string">&quot;Ted&quot;</span>, <span class="string">&quot;Grass&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">puts</span>(ted.first);</span><br></pre></td></tr></table></figure>

<h3 id="把结构内容保存到文件中"><a href="#把结构内容保存到文件中" class="headerlink" title="把结构内容保存到文件中"></a>把结构内容保存到文件中</h3><p>储存记录最没效率的方法是用fprintf()</p>
<p><code>fprintf(pbooks, &quot;%s %s %.2f\n&quot;, primer.title,primer.author, primer.value);</code></p>
<p>更好的方案是使用fread()和fwrite()函数读写结构大小的单元。这两个函数使用与程序相同的二进制表示法。</p>
<p><code>fwrite(&amp;primer, sizeof(struct book), 1, pbooks);</code></p>
<p>缺点移植性较差。以二进制表示法储存数据的缺点是，不同的系统可能使用不同的二进制表示法，所以数据文件可能不具可移植性。甚至同一个系统，不同编译器设置也可能导致不同的二进制布局。</p>
<h2 id="联合简介"><a href="#联合简介" class="headerlink" title="联合简介"></a>联合简介</h2><p>联合（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。</p>
<p>根据以下形式声明的结构可以储存一个int类型、一个double类型和char类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的值或char类型的值。</p>
<p>声明时，编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。其中double类型占64位，即8字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//联合定义</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> digit;</span><br><span class="line">	<span class="type">double</span> bigfl;</span><br><span class="line">	<span class="type">char</span> letter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联合声明</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">fit</span>;</span>　　　　<span class="comment">// hold类型的联合变量</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">save</span>[10];</span>　<span class="comment">// 内含10个联合变量的数组</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> * <span class="title">pu</span>;</span>　　　<span class="comment">// 指向hold类型联合变量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//联合初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valA</span>;</span></span><br><span class="line">valA.letter = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valB</span> =</span> valA;　　　　　　<span class="comment">// 用另一个联合来初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valC</span> =</span> &#123;<span class="number">88</span>&#125;;　　　　　　<span class="comment">// 初始化联合的digit 成员</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valD</span> =</span> &#123;.bigfl = <span class="number">118.2</span>&#125;; <span class="comment">// 指定初始化器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//联合使用</span></span><br><span class="line">fit.digit = <span class="number">23</span>; <span class="comment">//把 23 储存在 fit，占2字节</span></span><br><span class="line">fit.bigfl = <span class="number">2.0</span>; <span class="comment">// 清除23，储存 2.0，占8字节</span></span><br><span class="line">fit.letter = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// 清除2.0，储存h，占1字节</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名联合（C11）"><a href="#匿名联合（C11）" class="headerlink" title="匿名联合（C11）"></a>匿名联合（C11）</h3><p>匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的无名联合成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">owner</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> socsecurity[<span class="number">12</span>];</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">40</span>];</span><br><span class="line">	<span class="type">char</span> headquarters[<span class="number">40</span>];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car_data</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> make[<span class="number">15</span>];</span><br><span class="line">	<span class="type">int</span> status; <span class="comment">/* 私有为0，租赁为1 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">owner</span> <span class="title">owncar</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">leasecompany</span> <span class="title">leasecar</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果flits是car_data类型的结构变量，通过以下方式访问</p>
<p><code>flits.owncar.socsecurity</code></p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>可以用枚举类型（enumerated type）声明符号名称来表示整型常量。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如，可以这样声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet&#125;; <span class="comment">//0~5</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> <span class="title">color</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span> (color == yellow)</span><br><span class="line">...;</span><br><span class="line"><span class="keyword">for</span> (color = red; color &lt;= violet; color++)</span><br><span class="line">...;</span><br></pre></td></tr></table></figure>

<p>C枚举的一些特性并不适用于C++。例如，C允许枚举变量使用++运算符，但是C++标准不允许。</p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">levels</span> &#123;</span>low = <span class="number">100</span>, medium = <span class="number">500</span>, high = <span class="number">2000</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">feline</span> &#123;</span>cat, lynx = <span class="number">10</span>, puma, tiger&#125;; <span class="comment">//cat = 0; lynx = 10, puma = 11, tiger = 12</span></span><br></pre></td></tr></table></figure>

<p>枚举类型的目的是为了提高程序的可读性和可维护性。</p>
<p>因为枚举类型是整数类型，所以可以在表达式中以使用整数变量的方式使用enum变量。它们用在case语句中很方便。</p>
<h2 id="共享名称空间"><a href="#共享名称空间" class="headerlink" title="共享名称空间"></a>共享名称空间</h2><p>C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来识别。作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲突；两个相同作用域的同名变量冲突。</p>
<p>在特定作用域中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称空间与普通变量使用的空间不同。这意味着在相同作用域中<strong>变量</strong>和<strong>标记的名称</strong>可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span> &#123;</span> <span class="type">double</span> x; <span class="type">double</span> y; &#125;;</span><br><span class="line"><span class="type">int</span> rect; <span class="comment">// 在C中不会产生冲突</span></span><br></pre></td></tr></table></figure>

<p>尽管如此，以两种不同的方式使用相同的标识符会造成混乱。另外，C++不允许这样做，因为它把标记名和变量名放在相同的名称空间中。</p>
<h2 id="typedef简介"><a href="#typedef简介" class="headerlink" title="typedef简介"></a>typedef简介</h2><p>利用typedef可以为某一类型自定义名称。这方面与#define类似，但是两者有3处不同：</p>
<ol>
<li>与#define不同，typedef创建的符号名只受限于类型，不能用于值。</li>
<li>typedef由编译器解释，不是预处理器。</li>
<li>在其受限范围内，typedef比#define更灵活。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE;</span><br><span class="line">BYTE x, y[<span class="number">10</span>], * z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * STRING;</span><br><span class="line">STRING name, sign;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line"><span class="type">float</span> real;</span><br><span class="line"><span class="type">float</span> imag;</span><br><span class="line">&#125; COMPLEX;</span><br><span class="line"><span class="comment">//然后便可使用COMPLEX类型代替complex结构来表示复数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="type">double</span> x; <span class="type">double</span> y;&#125; rect;</span><br></pre></td></tr></table></figure>

<p>使用typedef的第1个原因是：为经常出现的类型创建一个方便、易识别的类型名。</p>
<p>使用typedef的第2个原因是：typedef常用于给复杂的类型命名。</p>
<p>通过结构、联合和typedef，C提供了有效处理数据的工具和处理可移植数据的工具。</p>
<h2 id="其他复杂的声明"><a href="#其他复杂的声明" class="headerlink" title="其他复杂的声明"></a>其他复杂的声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> board[<span class="number">8</span>][<span class="number">8</span>];　　　<span class="comment">// 声明一个内含int数组的数组</span></span><br><span class="line"><span class="type">int</span> ** ptr;　　　　　<span class="comment">// 声明一个指向指针的指针，被指向的指针指向int</span></span><br><span class="line"><span class="type">int</span> * risks[<span class="number">10</span>];　　　<span class="comment">// 声明一个内含10个元素的数组，每个元素都是一个指向int的指针</span></span><br><span class="line"><span class="type">int</span> (* rusks)[<span class="number">10</span>];　　<span class="comment">// 声明一个指向数组的指针，该数组内含10个int类型的值</span></span><br><span class="line"><span class="type">int</span> * oof[<span class="number">3</span>][<span class="number">4</span>];　　　<span class="comment">// 声明一个3×4 的二维数组，每个元素都是指向int的指针</span></span><br><span class="line"><span class="type">int</span> (* uuf)[<span class="number">3</span>][<span class="number">4</span>];　　<span class="comment">// 声明一个指向3×4二维数组的指针，该数组中内含int类型值</span></span><br><span class="line"><span class="type">int</span> (* uof[<span class="number">3</span>])[<span class="number">4</span>];　　<span class="comment">// 声明一个内含3个指针元素的数组，其中每个指针都指向一个内含4个int类型元素的数组</span></span><br></pre></td></tr></table></figure>

<ol>
<li>数组名后面的[]和函数名后面的()具有相同的优先级。它们比*（解引用运算符）的优先级高。</li>
<li>[]和()的优先级相同，且都是从左往右结合</li>
</ol>
<h3 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ToUpper</span><span class="params">(<span class="type">char</span> *)</span>; <span class="comment">// 把字符串中的字符转换成大写字符</span></span><br><span class="line"><span class="type">void</span> (*pf)(<span class="type">char</span> *);　<span class="comment">// (*pf)是一个参数列表为(char *)、返回类型为void的函数。</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pf</span><span class="params">(<span class="type">char</span> *)</span>; <span class="comment">// pf 是一个返回字符指针的函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ToUpper</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ToLower</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span>)</span>;</span><br><span class="line"><span class="type">void</span> (*pf)(<span class="type">char</span> *);</span><br><span class="line">pf = ToUpper;　　<span class="comment">// 有效，ToUpper是该类型函数的地址</span></span><br><span class="line">pf = ToLower;　　<span class="comment">//有效，ToUpper是该类型函数的地址</span></span><br><span class="line">pf = round;　　　<span class="comment">// 无效，round与指针类型不匹配</span></span><br><span class="line">pf = ToLower();　<span class="comment">// 无效，ToLower()不是地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ToUpper</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ToLower</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">void</span> (*pf)(<span class="type">char</span> *);</span><br><span class="line"><span class="type">char</span> mis[] = <span class="string">&quot;Nina Metier&quot;</span>;</span><br><span class="line">pf = ToUpper;</span><br><span class="line">(*pf)(mis);　<span class="comment">// 把ToUpper 作用于（语法1），相当于ToUpper(mis)</span></span><br><span class="line">pf = ToLower;</span><br><span class="line">pf(mis);　　　<span class="comment">// 把ToLower 作用于（语法2）</span></span><br></pre></td></tr></table></figure>

<h1 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h1><p>运算符：～、&amp;、|、^、<br>&lt;&lt;、&gt;&gt;<br>&amp;&#x3D;、|&#x3D;、^&#x3D;、&gt;&gt;&#x3D;、&lt;&lt;&#x3D;</p>
<p>处理一个值中的位的两个C工具：位运算符和位字段</p>
<p>关键字：_Alignas、_Alignof</p>
<h2 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h2><p>逻辑运算符、移位运算符</p>
<h3 id="按位逻辑运算符"><a href="#按位逻辑运算符" class="headerlink" title="按位逻辑运算符"></a>按位逻辑运算符</h3><ol>
<li><p>二进制反码或按位取反：~</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newval = ~val;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按位与：&amp;（1&amp;1&#x3D;1，其余为0）</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val &amp;= <span class="number">0377</span>;</span><br><span class="line">val = val &amp; <span class="number">0377</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按位或： |（0|0&#x3D;0，其余为1）</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val |= <span class="number">0377</span>;</span><br><span class="line">val = val | <span class="number">0377</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按位异或：^（0^1&#x3D;1; 1^0&#x3D;1）</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ^= <span class="number">0377</span>;</span><br><span class="line">val = val ^ <span class="number">0377</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="用法：掩码-amp"><a href="#用法：掩码-amp" class="headerlink" title="用法：掩码&amp;"></a>用法：掩码&amp;</h3><p>按位<strong>与（&amp;）</strong>运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合。</p>
<p>例如，假设定义符号常量MASK为2 （即，二进制形式为00000010）,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flags = flags &amp; MASK;　<span class="comment">//把flags中除1号位以外的所有位都设置为0（值小于MASK、flags）</span></span><br><span class="line">flags &amp;= MASK;</span><br><span class="line"></span><br><span class="line">ch &amp;= <span class="number">0xff</span>; <span class="comment">/* 或者 ch &amp;= 0377; oxff的二进制形式是11111111，八进制形式是0377。*/</span></span><br></pre></td></tr></table></figure>

<p>把掩码中的0看作不透明，1看作透明。表达式<code>flags&amp;MASK</code>相当于用掩码覆盖在flags的位组合上，只有MASK为1的位才可见。</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2013.png"></p>
<h3 id="用法：打开位（设置位）"><a href="#用法：打开位（设置位）" class="headerlink" title="用法：打开位（设置位）|"></a>用法：打开位（设置位）|</h3><p>有时，需要<strong>打开一个值中的特定位</strong>，同时保持其他位不变。例如，一台IBM PC 通过向端口发送值来控制硬件。例如，为了打开内置扬声器，必须打开  1  号位，同时保持其他位不变。这种情况可以使用按位或运算符（|）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags = flags | MASK; <span class="comment">//把flags的1号位设置为1，且其他位不变。（值大于MASK、flags）</span></span><br><span class="line">flags |= MASK;</span><br></pre></td></tr></table></figure>

<h3 id="用法：关闭位（清空位）-amp"><a href="#用法：关闭位（清空位）-amp" class="headerlink" title="用法：关闭位（清空位）&amp;~"></a>用法：关闭位（清空位）&amp;~</h3><p>和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的位。假设<strong>要关闭变量flags中的1号位</strong>。同样，MASK只有1号位为1（即，打开）。可以这样做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags = flags &amp; ~MASK;</span><br></pre></td></tr></table></figure>

<p>例如：假设flags是00001111，MASK是10110110。<br>~MASK&#x3D;01001001，<code>flags &amp; ~MASK = 00001001</code></p>
<h3 id="用法：切换位"><a href="#用法：切换位" class="headerlink" title="用法：切换位^"></a>用法：切换位^</h3><p>切换位指的是<strong>打开已关闭的位</strong>，<strong>或关闭已打开的位</strong>。可以使用按位<strong>异或</strong>运算符（^）切换位。</p>
<p>如果使用^组合一个值和一个掩码，将<strong>切换</strong>该值与<strong>MASK为1</strong>的位相对应的位，该值与<strong>MASK为0</strong>的位相对应的位<strong>不变</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags = flags ^ MASK;</span><br><span class="line">flags ^= MASK;</span><br></pre></td></tr></table></figure>

<p>例如：(00001111) ^ (10110110)　&#x2F;&#x2F; 表达式<br>其结果为：(10111001)　　　　　&#x2F;&#x2F; 结果值</p>
<h3 id="用法：检查位的值"><a href="#用法：检查位的值" class="headerlink" title="用法：检查位的值"></a>用法：检查位的值</h3><p>有时，需要检查某位的值。例如，flags中1号位是否被设置为1？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((flags &amp; MASK) == MASK)</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Wow!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h2><h3 id="左移：-lt-lt"><a href="#左移：-lt-lt" class="headerlink" title="左移：&lt;&lt;"></a>左移：&lt;&lt;</h3><p>左移运算符（&lt;&lt;）将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。左侧运算对象移出左末端位的值丢失，用0填充空出的位置。</p>
<p>1000 1000&lt;&lt;1 &#x3D; 0010 000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stonk = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> onkoo;</span><br><span class="line"></span><br><span class="line">onkoo = stonk &lt;&lt; <span class="number">2</span>;　<span class="comment">/* 把4赋给onkoo */</span></span><br><span class="line">stonk &lt;&lt;= <span class="number">2</span>;　　　　<span class="comment">/* 把stonk的值改为4 *</span></span><br></pre></td></tr></table></figure>

<h3 id="右移：-gt-gt"><a href="#右移：-gt-gt" class="headerlink" title="右移：&gt;&gt;"></a>右移：&gt;&gt;</h3><p>右移运算符（&gt;&gt;）将其左侧运算对象每一位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢。对于无符号类型，用0填充空出的位置；对于有符号类型，其结果取决于机器（空出的位置可用0填充，或者用符号位的副本填充）。</p>
<p>下面是有符号值的例子：<br>(10001010) &gt;&gt; 2　　　　&#x2F;&#x2F; 表达式，有符号值<br>(00100010)　　　　　　&#x2F;&#x2F; 在某些系统中的结果值<br>(10001010) &gt;&gt; 2　　　　&#x2F;&#x2F; 表达式，有符号值<br>(11100010)　　　　　　&#x2F;&#x2F; 在另一些系统上的结果值</p>
<p>下面是无符号值的例子：<br>(10001010) &gt;&gt; 2　　　　&#x2F;&#x2F; 表达式，无符号值<br>(00100010)　　　　　　&#x2F;&#x2F; 所有系统都得到该结果值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sweet = <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> ooosw;</span><br><span class="line">ooosw = sweet &gt;&gt; <span class="number">3</span>;　　<span class="comment">// ooosw = 2，sweet的值仍然为16</span></span><br><span class="line">sweet &gt;&gt;=<span class="number">3</span>;　　　　　　<span class="comment">// sweet的值为2</span></span><br></pre></td></tr></table></figure>

<h3 id="用法：移位运算符"><a href="#用法：移位运算符" class="headerlink" title="用法：移位运算符"></a>用法：移位运算符</h3><p>移位运算符针对2的幂提供快速有效的乘法和除法：<br>number &lt;&lt; n　　　number乘以2的n次幂<br>number &gt;&gt; n　　　如果number为非负，则用number除以2的n次幂</p>
<h2 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h2><p>操控位的第2种方法是位字段（bit field）。位字段是一个signed int或unsigned int类型变量中的一组相邻的位（C99和C11新增了**_Bool类型**的位字段）。位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> autfd : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bldfc : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> undln : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> itals : <span class="number">1</span>;</span><br><span class="line">&#125; prnt;</span><br><span class="line"></span><br><span class="line">prnt.itals = <span class="number">0</span>;</span><br><span class="line">prnt.undln = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> code1 : <span class="number">2</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> code2 : <span class="number">2</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> code3 : <span class="number">8</span>; <span class="comment">//8位</span></span><br><span class="line">&#125; prcode;</span><br><span class="line"></span><br><span class="line">prcode.code1 = <span class="number">0</span>;</span><br><span class="line">prcode.code2 = <span class="number">3</span>;</span><br><span class="line">prcode.code3 = <span class="number">102</span>;</span><br></pre></td></tr></table></figure>

<p>如果声明的总位数超过了一个unsigned int类型的大小会怎样？</p>
<p>会用到下一个unsigned int类型的存储位置。一个字段不允许跨越两个unsigned int之间的边界。编译器会自动移动跨界的字段，保持unsigned int的边界对齐。一旦发生这种情况，第1个unsigned int中会留下一个未命名的“洞”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> field1 : <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> : <span class="number">2</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> field2 : <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> : <span class="number">0</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> field3 : <span class="number">1</span>;</span><br><span class="line">	&#125; stuff;</span><br></pre></td></tr></table></figure>

<p>这里，在stuff.field1和stuff.field2之间，有一个2位的空隙；stuff.field3将储存在下一个unsigned int中。</p>
<h3 id="位字段示例"><a href="#位字段示例" class="headerlink" title="位字段示例"></a>位字段示例</h3><p>我们假设方框具有如下属性：<br>方框是透明的或不透明的；<br>方框的填充色选自以下调色板：黑色、红色、绿色、黄色、蓝色、紫色、青色或白色；<br>边框可见或隐藏；<br>边框颜色与填充色使用相同的调色板；<br>边框可以使用实线、点线或虚线样式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box_props</span> &#123;</span></span><br><span class="line">		<span class="type">bool</span> opaque : <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> fill_color : <span class="number">3</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> : <span class="number">4</span>;</span><br><span class="line">		<span class="type">bool</span> show_border : <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> border_color : <span class="number">3</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> border_style : <span class="number">2</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> : <span class="number">2</span>;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>加上未命名的字段，该结构共占用 16 位。如果不使用填充，该结构占用 10 位。C语言以unsigned int作为位字段结构的基本布局单元。（unsigned int是32位）</p>
<h2 id="对齐特性（C11）"><a href="#对齐特性（C11）" class="headerlink" title="对齐特性（C11）"></a>对齐特性（C11）</h2><p>C11 的对齐特性比用位填充字节更自然，它们还代表了C在处理硬件相关问题上的能力。在这种上下文中，对齐指的是如何安排对象在内存中的位置。</p>
<p>例如，把数据从一个硬件位置转移到另一个位置，或者调用指令同时操作多个数据项。</p>
<p><code>_Alignof</code>运算符给出一个类型的对齐要求，在关键字_Alignof后面的圆括号中写上类型名即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> d_align = <span class="keyword">_Alignof</span>(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">_Alignas</span>(<span class="type">double</span>) <span class="type">char</span> c1;</span><br><span class="line"><span class="keyword">_Alignas</span>(<span class="number">8</span>) <span class="type">char</span> c2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="keyword">_Alignas</span>(<span class="type">long</span> <span class="type">double</span>) c_arr[<span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">double</span>)];</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> dx;</span><br><span class="line">	<span class="type">char</span> ca;</span><br><span class="line">	<span class="type">char</span> cx;</span><br><span class="line">	<span class="type">double</span> dz;</span><br><span class="line">	<span class="type">char</span> cb;</span><br><span class="line">	<span class="type">char</span> <span class="keyword">_Alignas</span>(<span class="type">double</span>) cz;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;char alignment:%zd\n&quot;</span>, <span class="keyword">_Alignof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;double alignment: %zd\n&quot;</span>, <span class="keyword">_Alignof</span>(<span class="type">double</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;dx: %p\n&quot;</span>, &amp;dx);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;ca: %p\n&quot;</span>, &amp;ca);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;cx: %p\n&quot;</span>, &amp;cx);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;dz: %p\n&quot;</span>, &amp;dz);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;cb: %p\n&quot;</span>, &amp;cb);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;cz: %p\n&quot;</span>, &amp;cz);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C11在stdlib.h库还添加了一个新的内存分配函数，用于对齐动态分配的内存。该函数的原型如下：<br><code>void *aligned_alloc(size_t alignment, size_t size);</code><br>第1个参数代表指定的对齐，第2个参数是所需的字节数，其值应是第1个参数的倍数。与其他内存分配函数一样，要使用free()函数释放之前分配的内存。</p>
<h1 id="C预处理器和C库"><a href="#C预处理器和C库" class="headerlink" title="C预处理器和C库"></a>C预处理器和C库</h1><p>预处理指令：#define、#include、#ifdef、#else、#endif、#ifndef、#if、#elif、#line、#error、#pragma<br>关键字：_Generic、_Noreturn、_Static_assert<br>函数&#x2F;宏：sqrt()、atan()、atan2()、exit()、atexit()、assert()、memcpy()、memmove()、va_start()、va_arg()、va_copy()、va_end()</p>
<p>C语言建立在适当的关键字、表达式、语句以及使用它们的规则上。然而，C标准不仅描述C语言，还描述如何执行C预处理器、C标准库有哪些函数，以及详述这些函数的工作原理。</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>预处理——编译——汇编——链接</p>
<p>使用C语编写test程序的源代码文件test.c过程：</p>
<p>首先进入GCC的<strong>预编译器</strong>进行预处理，<strong>对头文件、宏定义等进行展开</strong>，生成test.i文件；然后进入GCC的<strong>编译器</strong>，编译完<strong>生成汇编程序test.s</strong>；然后调用<strong>汇编器</strong>进行汇编，<strong>生成可重定位的目标程序test.o</strong>；最后调用<strong>链接器</strong>，将所有目标文件和C语言库链接成可执行的二进制文件。</p>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>C预处理器在程序执行之前查看程序。根据程序中的预处理器指令，预处理器把符号缩写替换成其表示的内容。</p>
<h3 id="翻译程序的第一步"><a href="#翻译程序的第一步" class="headerlink" title="翻译程序的第一步"></a>翻译程序的第一步</h3><p>在预处理之前，编译器必须对该程序进行一些翻译处理。</p>
<p>Step1: 编译器把源代码中出现的字符映射到源字符集。该过程处理多字节字符集或Unicode字符集——字符扩展让C更加国际化（要在编译器中设置相关选项才能激活这个特性）</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2014.png"></p>
<p>Step2:  编译器定位每个反斜杠后面跟着换行符的实例，并删除它们。也就是说，把下面两个物理行（physical line）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s wond\</span></span><br><span class="line"><span class="string">erful!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将变成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s wonderful\n!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Step3: 编译器把文本划分成预处理记号序列、空白序列和注释序列。编译器将用一个空格字符替换每一条注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span><span class="comment">/* 这看起来并不像一个空格*/</span>fox;</span><br></pre></td></tr></table></figure>

<p>将变成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fox;</span><br></pre></td></tr></table></figure>

<p>最后，程序已经准备好进入预处理阶段，预处理器查找一行中<strong>以#号开始的预处理指令</strong>。</p>
<h2 id="明示常量：-define"><a href="#明示常量：-define" class="headerlink" title="明示常量：#define"></a>明示常量：#define</h2><p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2015.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TWO 2　　　<span class="comment">/* 可以使用注释 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t = TWO;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将变为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记号"><a href="#记号" class="headerlink" title="记号"></a>记号</h3><p>从技术角度来看，可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串。</p>
<h3 id="重定义常量"><a href="#重定义常量" class="headerlink" title="重定义常量"></a>重定义常量</h3><p>假设先把LIMIT定义为20，稍后在该文件中又把它定义为25。这个过程称为重定义常量。</p>
<p>如果需要重定义宏，使用<code>#undef</code> 指令（稍后讨论）。</p>
<p>如果确实需要重定义常量，使用const关键字和作用域规则更容易些。</p>
<h3 id="在-define中使用参数"><a href="#在-define中使用参数" class="headerlink" title="在#define中使用参数"></a>在#define中使用参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR(X)　printf(<span class="string">&quot;The result is %d.\n&quot;</span>, X)</span></span><br></pre></td></tr></table></figure>

<h3 id="预处理器黏合剂：-运算符"><a href="#预处理器黏合剂：-运算符" class="headerlink" title="预处理器黏合剂：##运算符"></a>预处理器黏合剂：##运算符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XNAME(n) x ## n</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">XNAME</span><span class="params">(<span class="number">1</span>)</span> = <span class="number">14</span>;  <span class="comment">//将变成int x1 = 14;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变参宏：…和-VA-ARGS"><a href="#变参宏：…和-VA-ARGS" class="headerlink" title="变参宏：…和__VA_ARGS__"></a>变参宏：…和__VA_ARGS__</h3><p>一些函数（如 printf()）接受数量可变的参数。<code>stdvar.h</code> 头文件提供了工具，让用户自定义带可变参数的函数。C99&#x2F;C11也对宏提供了这样的工具。</p>
<p>通过把宏参数列表中最后的参数写成省略号（<code>...</code>）来实现这一功能。这样，预定义宏<code>__VA_ARGS__</code>可用在替换部分中，表明省略号代表什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PR(...) printf(_ _VA_ARGS_ _)</span></span><br><span class="line"></span><br><span class="line">PR(<span class="string">&quot;Howdy&quot;</span>);</span><br><span class="line">PR(<span class="string">&quot;weight = %d, shipping = $%.2f\n&quot;</span>, wt, sp);</span><br></pre></td></tr></table></figure>

<p>程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR(X, ...) printf(<span class="string">&quot;Message &quot;</span> #X <span class="string">&quot;: &quot;</span> __VA_ARGS__)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> x = <span class="number">48</span>;</span><br><span class="line">	<span class="type">double</span> y;</span><br><span class="line">	y = <span class="built_in">sqrt</span>(x);</span><br><span class="line">	PR(<span class="number">1</span>, <span class="string">&quot;x = %g\n&quot;</span>, x);</span><br><span class="line">	PR(<span class="number">2</span>, <span class="string">&quot;x = %.2f, y = %.4f\n&quot;</span>, x, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="宏和函数的选择"><a href="#宏和函数的选择" class="headerlink" title="宏和函数的选择"></a>宏和函数的选择</h3><p>宏的一个优点是，不用担心变量类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(X,Y) ((X) &gt; (Y) ? (X) : (Y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS(X) ((X) &lt; 0 ? -(X) : (X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISSIGN(X) ((X) == <span class="string">&#x27;+&#x27;</span> || (X) == <span class="string">&#x27;-&#x27;</span> ? 1 : 0)</span></span><br></pre></td></tr></table></figure>

<h2 id="文件包含：-include"><a href="#文件包含：-include" class="headerlink" title="文件包含：#include"></a>文件包含：#include</h2><p>当预处理器发现<code>#include</code> 指令时，会查看后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的#include指令。</p>
<p>这相当于把被包含文件的全部内容输入到源文件<code>#include</code>指令所在的位置。<code>#include</code>指令有两种形式：<code>#include &lt;stdio.h&gt;</code>　　　　   ←查找系统目录<br><code>#include &quot;hot.h&quot;</code>　　　　　   ←查找当前工作目录<br><code>#include &quot;/usr/biff/p.h&quot;</code>        ←查找&#x2F;usr&#x2F;biff目录</p>
<p>头文件中最常用的形式如下。</p>
<ol>
<li>明示常量——例如，stdio.h中定义的EOF、NULL和BUFSIZE（标准I&#x2F;O缓冲区大小）。</li>
<li>宏函数——例如，getc(stdin)通常用getchar()定义，而getc()经常用于定义较复杂的宏，头文件ctype.h通常包含ctype系列函数的宏定义。</li>
<li>函数声明——例如，string.h头文件（一些旧的系统中是strings.h）包含字符串函数系列的函数声明。在ANSI  C和后面的标准中，函数声明都是函数原型形式。</li>
<li>结构模版定义——标准I&#x2F;O函数使用FILE结构，该结构中包含了文件和与文件缓冲区相关的信息。FILE结构在头文件stdio.h中。</li>
<li>类型定义——标准 I&#x2F;O 函数使用指向 FILE 的指针作为参数。通常，stdio.h 用#define 或typedef把FILE定义为指向结构的指针。类似地，size_t和time_t类型也定义在头文件中。</li>
<li>外部变量——还可以使用头文件声明外部变量供其他文件共享。</li>
</ol>
<h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><p>程序员可能要为不同的工作环境准备C程序和C库包。不同的环境可能使用不同的代码类型。预处理器提供一些指令，程序员通过修改#define的值即可生成可移植的代码。<code>#undef</code>指令取消之前的<code>#define</code>定义。<code>#if</code>、<code>#ifdef</code>、<code>#ifndef</code>、<code>#else</code>、<code>#elif</code>和<code>#endif</code>指令用于指定什么情况下编写哪些代码。<code>#line</code>指令用于重置行和文件信息，<code>#error</code>指令用于给出错误消息，<code>#pragma</code>指令用于向编译器发出指令。</p>
<h3 id="undef指令"><a href="#undef指令" class="headerlink" title="#undef指令"></a>#undef指令</h3><p><code>#undef</code>指令用于“取消”已定义的<code>#define</code>指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT 400</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> LIMIT</span></span><br></pre></td></tr></table></figure>

<p><strong>从C预处理器角度看已定义</strong></p>
<p>当预处理器在预处理器指令中发现一个标识符时，它会把该标识符当作已定义的或未定义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT 1000　　　　   <span class="comment">// LIMIT是已定义的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GOOD　　　　　　　   <span class="comment">// GOOD 是已定义的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A(X) ((-(X))*(X))　 <span class="comment">// A 是已定义的</span></span></span><br><span class="line"><span class="type">int</span> q;　　　　　　　　　　　  <span class="comment">// q 不是宏，因此是未定义的</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> GOOD　　　　　　　　  <span class="comment">// GOOD 取消定义，是未定义的</span></span></span><br></pre></td></tr></table></figure>

<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>可以使用其他指令创建条件编译（conditinal compilation）。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息（或代码）块。</p>
<ol>
<li><p><code>#ifdef</code>、<code>#else</code>和<code>#endif</code>指令</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAVIS</span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;horse.h&quot;</span> <span class="comment">// 如果已经用#define定义了 MAVIS，则执行下面的指令</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> STABLES 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cow.h&quot;</span>   <span class="comment">//如果没有用#define定义 MAVIS，则执行下面的指令</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> STABLES 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>#ifndef</code>指令</p>
<p> #ifndef指令通常用于防止多次包含一个文件。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIZE</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;arrays.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p> SIZE则被设置为10。这里，当执行到#include  “arrays.h”这行，处理array.h中的代码时，由于SIZE是已定义的，所以跳过了#define SIZE 100这行代码。</p>
</li>
</ol>
<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2016.png"></p>
<p>C99 标准提供一个名为<code>__func__</code>的预定义标识符，它展开为一个代表函数名的字符串（该函数包含该标识符）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// predef.c -- 预定义宏和预定义标识符</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">why_me</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The file is %s.\n&quot;</span>, __FILE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The date is %s.\n&quot;</span>, __DATE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The time is %s.\n&quot;</span>, __TIME__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The version is %ld.\n&quot;</span>,__STDC_VERSION__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is line %d.\n&quot;</span>, __LINE__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This function is %s\n&quot;</span>, __func__);</span><br><span class="line">	why_me();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">why_me</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This function is %s\n&quot;</span>, __func__);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is line %d.\n&quot;</span>, __LINE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="line和-error"><a href="#line和-error" class="headerlink" title="#line和#error"></a>#line和#error</h3><p><code>#line</code>指令重置<code>__LINE__</code>和<code>__FILE__</code>宏报告的行号和文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 1000　　　　　　<span class="comment">// 把当前行号重置为1000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 10 <span class="string">&quot;cool.c&quot;</span>　　　<span class="comment">// 把行号重置为10，把文件名重置为cool.c</span></span></span><br></pre></td></tr></table></figure>

<p><code>#error</code>指令让预处理器发出一条错误消息，该消息包含指令中的文本。如果可能的话，编译过程应该中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  newish.c文件</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STDC_VERSION__ != 201112L</span></span><br><span class="line">	<span class="meta">#<span class="keyword">error</span> Not C11</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>编译以上代码生成后，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc newish.c</span><br><span class="line">newish.c:14:2: error: <span class="comment">#error Not C11</span></span><br><span class="line">$ gcc -std=c11 newish.c</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>如果编译器只支持旧标准，则会编译失败，如果支持C11标准，就能成功编译。</p>
<h3 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h3><p>在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些设置。#pragma把编译器指令放入源代码中。</p>
<p>例如，在开发C99时，标准被称为C9X，可以使用下面的<strong>编译指示（pragma）</strong>让编译器支持C9X：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> c9x on</span></span><br></pre></td></tr></table></figure>

<p>一般而言，编译器都有自己的编译指示集。例如，编译指示可能用于控制分配给自动变量的内存量，或者设置错误检查的严格程度，或者启用非标准语言特性等。</p>
<p>C99还提供_Pragma预处理器运算符，该运算符把字符串转换成普通的编译指示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_Pragma</span>(<span class="string">&quot;nonstandardtreatmenttypeB on&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> nonstandardtreatmenttypeB on</span></span><br></pre></td></tr></table></figure>

<p>由于该运算符不使用#符号，所以可以把它作为宏展开的一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRAGMA(X) <span class="keyword">_Pragma</span>(#X)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X)</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型选择（C11）"><a href="#泛型选择（C11）" class="headerlink" title="泛型选择（C11）"></a>泛型选择（C11）</h3><p>在程序设计中，<strong>泛型编程（generic  programming）</strong>指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。</p>
<p>C++在模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码。C没有这种功能。C11新增了一种表达式，叫作<strong>泛型选择表达式（generic selection expression）</strong>，可根据表达式的类型（即表达式的类型是int、double  还是其他类型）选择一个值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_Generic</span>(x, <span class="type">int</span>: <span class="number">0</span>, <span class="type">float</span>: <span class="number">1</span>, <span class="type">double</span>: <span class="number">2</span>, <span class="keyword">default</span>: <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><code>_Generic</code>是C11的关键字。_Generic后面的圆括号中包含多个用逗号分隔的项。第1个项是一个表达式，后面的每个项都由一个类型、一个冒号和一个值组成，如float: 1。如果x的类型匹配是float:标签，那么整个表达式的值就是1。</p>
<p>下面的例子为：对泛型选择表达式求值得字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MYTYPE(X) _Generic((X),\</span></span><br><span class="line"><span class="meta">int: <span class="string">&quot;int&quot;</span>,\</span></span><br><span class="line"><span class="meta">float : <span class="string">&quot;float&quot;</span>,\</span></span><br><span class="line"><span class="meta">double: <span class="string">&quot;double&quot;</span>,\</span></span><br><span class="line"><span class="meta">default: <span class="string">&quot;other&quot;</span>\</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>通常，函数调用都有一定的开销，因为函数的调用过程包括<strong>建立调用、传递参数、跳转到函数代码并返回</strong>。<strong>使用宏使代码内联</strong>，可以避免这样的开销。C99还提供另一种方法：<strong>内联函数（inline function）</strong>。</p>
<p>其实C99和C11标准中叙述的是：“把函数变成内联函数建议尽可能快地调用该函数，其具体效果由实<br>现定义”。因此，把函数变成内联函数，编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。</p>
<p>标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。因此，最简单的方法是使用函数说明符  inline  和存储类别说明符static。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">eatline</span><span class="params">()</span> <span class="comment">// 内联函数定义/原型</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	eatline();      <span class="comment">// 函数调用</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器</strong>查看内联函数的定义（也是原型），可能会用函数体中的代码替换 eatline()函数调用。也就是说，效果相当于在函数调用的位置输入函数体中的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">eatline</span><span class="params">()</span> <span class="comment">// 内联函数定义/原型</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于并未给内联函数预留单独的代码块，所以<strong>无法获得内联函数的地址</strong>（实际上可以获得地址，不过这样做之后，编译器会生成一个非内联函数）。另外，内联函数无法在调试器中显示。</p>
<p>编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。鉴于此，一般情况下内联函数都具有内部链接。因此，如果程序有多个文件都要使用某个内联函数，那么这些文件中都必须包含该内联函数的定义。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eatline.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EATLINE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATLINE_H_</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">eatline</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。</p>
<h2 id="Noreturn函数（C11）"><a href="#Noreturn函数（C11）" class="headerlink" title="_Noreturn函数（C11）"></a>_Noreturn函数（C11）</h2><p>C99新增inline关键字时，它是唯一的<strong>函数说明符</strong>（关键字extern和static是<strong>存储类别说明符</strong>，可应用于数据对象和函数）。</p>
<p>C11新增了第2个函数说明符<code>_Noreturn</code>，表明调用完成后函数不返回主调函数。</p>
<p><code>exit()</code>函数是<code>_Noreturn</code>函数的一个示例，一旦调用<code>exit()</code>，它不会再返回主调函数。void类型的函数在执行完毕后返回主调函数，只是它不提供返回值。</p>
<h2 id="C库"><a href="#C库" class="headerlink" title="C库"></a>C库</h2><h3 id="使用库表述"><a href="#使用库表述" class="headerlink" title="使用库表述"></a>使用库表述</h3><p>C99&#x2F;C11标准提供了下面的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> * <span class="keyword">restrict</span> ptr, <span class="type">size_t</span> size,<span class="type">size_t</span> nmemb, FILE * <span class="keyword">restrict</span> stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>size_t</code> 类型被定义为 sizeof 运算符的返回值类型——无符号整数类型，通常是unsignedint或unsigned long。stddef.h文件中包含了size_t类型的typedef或#define定义。其他文件（包括stdio.h）通过包含stddef.h来包含这个定义。许多函数（包括fread()）的实际参数中都要使用sizeof运算符，形式参数的size_t类型中正好匹配这种常见的情况。</p>
<p><code>restrict</code>关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。</p>
<h3 id="数学库-include-lt-math-h-gt"><a href="#数学库-include-lt-math-h-gt" class="headerlink" title="数学库#include &lt;math.h&gt;"></a>数学库#include &lt;math.h&gt;</h3><p><code>#include &lt;math.h&gt;</code></p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2017.png"></p>
<p>利用C11新增的泛型选择表达式<code>_Generic</code>定义一个泛型宏，根据参数类型选择最合适的数学函数版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型平方根函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQRT(X) _Generic((X),\</span></span><br><span class="line"><span class="meta">long double: sqrtl, \</span></span><br><span class="line"><span class="meta">default: sqrt, \</span></span><br><span class="line"><span class="meta">float: sqrtf)(X)</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> y = SQRT(x);</span><br></pre></td></tr></table></figure>

<p><code>&lt;tgmath.h&gt;</code>定义 <code>sqrt()</code>宏展开为sqrtf()、sqrt()或 sqrtl()函数。</p>
<h2 id="通用工具库"><a href="#通用工具库" class="headerlink" title="通用工具库"></a>通用工具库</h2><p><code>rand()</code>、<code>srand()</code>、<code>malloc()</code>和<code>free()</code>函数。在ANSI C标准中，这些函数的原型都在<code>&lt;stdlib.h&gt;</code>头文件中。</p>
<h3 id="exit-和atexit-函数"><a href="#exit-和atexit-函数" class="headerlink" title="exit()和atexit()函数"></a>exit()和atexit()函数</h3><p>在main()返回系统时将自动调用<code>exit()</code>函数。</p>
<p><code>atexit()</code>函数通过退出时注册被调用的函数提供这种功能，<code>atexit()</code>函数接受一个函数指针作为参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* byebye.c -- atexit()示例 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sign_off</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">too_bad</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	atexit(sign_off);  <span class="comment">/* 注册 sign_off()函数 */</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Enter an integer:&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;That&#x27;s no integer!&quot;</span>);</span><br><span class="line">		atexit(too_bad); <span class="comment">/* 注册 too_bad()函数 */</span></span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d is %s.\n&quot;</span>, n, (n % <span class="number">2</span> == <span class="number">0</span>) ? <span class="string">&quot;even&quot;</span> : <span class="string">&quot;odd&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sign_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Thus terminates another magnificent program from&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;SeeSaw Software!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">too_bad</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;SeeSaw Software extends its heartfelt condolences&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;to you upon the failure of your program.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在IDE中运行，可能看不到最后4行。</p>
<ol>
<li><p>atexit()函数的用法</p>
<p> 这个函数使用函数指针。要使用  atexit()函数，只需把退出时要调用的函数地址传递给  atexit()即可。函数名作为函数参数时相当于该函数的地址，所以该程序中把sign_off或too_bad作为参数。然后，atexit()注册函数列表中的函数，当调用exit()时就会执行这些函数。ANSI保证，在这个列表中至少可以放 32 个函数。最后调用 exit()函数时，exit()会执行这些函数<strong>（执行顺序与列表中的函数顺序相反，即最后添加的函数最先执行）</strong>。</p>
</li>
<li><p>exit()函数的用法</p>
<p> exit()执行完atexit()指定的函数后，会完成一些清理工作：刷新所有输出流、关闭所有打开的流和关闭由标准I&#x2F;O函数tmpfile()创建的临时文件。然后exit()把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。在main()以外的函数中使用exit()也会终止整个程序。</p>
</li>
</ol>
<h3 id="qsort-函数"><a href="#qsort-函数" class="headerlink" title="qsort()函数"></a>qsort()函数</h3><p>对较大型的数组而言，“<strong>快速排序</strong>”方法是最有效的排序算法之一。</p>
<p>它把数组不断分成更小的数组，直到变成单元素数组。首先，把数组分成两部分，一部分的值都小于另一部分的值。这个过程一直持续到数组完全排序好为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*))</span>;</span><br></pre></td></tr></table></figure>

<p>第1个参数是指针，指向待排序数组的首元素。ANSI C允许把指向任何数据类型的指针强制转换成指向void的指针，因此，qsort()的第1个实际参数可以引用任何类型的数组。</p>
<p>第2个参数是待排序项的数量。函数原型把该值转换为size_t类型。前面提到过，size_t定义在标准头文件中，是sizeof运算符返回的整数类型。</p>
<p>由于qsort()把第1个参数转换为void指针，所以qsort()不知道数组中每个元素的大小。为此，函数原型用第 3 个参数补偿这一信息，显式指明待排序数组中每个元素的大小。例如，如果排序 double类型的数组，那么第3个参数应该是sizeof(double)。</p>
<p>最后，qsort()还需要一个指向函数的指针，这个被指针指向的比较函数用于确定排序的顺序。该函数应接受两个参数：分别指向待比较两项的指针。如果第1项的值大于第2项，比较函数则返回正数；如果两项相同，则返回0；如果第1项的值小于第2项，则返回负数。qsort()根据给定的其他信息计算出两个指针的值，然后把它们传递给比较函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* qsorter.c -- 用 qsort()排序一组数字 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 40</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fillarray</span><span class="params">(<span class="type">double</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showarray</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mycomp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> vals[NUM];</span><br><span class="line">	fillarray(vals, NUM);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Random list:&quot;</span>);</span><br><span class="line">	showarray(vals, NUM);</span><br><span class="line">	qsort(vals, NUM, <span class="keyword">sizeof</span>(<span class="type">double</span>), mycomp);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\nSorted list:&quot;</span>);</span><br><span class="line">	showarray(vals, NUM);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fillarray</span><span class="params">(<span class="type">double</span> ar[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; n; index++)</span><br><span class="line">		ar[index] = (<span class="type">double</span>)rand() / ((<span class="type">double</span>)rand() + <span class="number">0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showarray</span><span class="params">(<span class="type">const</span> <span class="type">double</span> ar[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; n; index++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%9.4f &quot;</span>, ar[index]);</span><br><span class="line">		<span class="keyword">if</span> (index % <span class="number">6</span> == <span class="number">5</span>)</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index % <span class="number">6</span> != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 按从小到大的顺序排序 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mycomp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 要使用指向double的指针来访问这两个值 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">double</span>* a1 = (<span class="type">const</span> <span class="type">double</span>*)p1;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span>* a2 = (<span class="type">const</span> <span class="type">double</span>*)p2;</span><br><span class="line">	<span class="keyword">if</span> (*a1 &lt; *a2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (*a1 == *a2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string-h库中的memcpy-和-memmove"><a href="#string-h库中的memcpy-和-memmove" class="headerlink" title="string.h库中的memcpy()和 memmove()"></a>string.h库中的memcpy()和 memmove()</h2><p>不能把一个数组赋给另一个数组，所以要通过循环把数组中的每个元素赋给另一个数组相应的元素。有一个例外的情况是：使用<code>strcpy()</code>和<code>strncpy()</code>函数来处理字符数组。<code>memcpy()</code>和<code>memmove()</code>函数提供类似的方法处理任意类型的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> * <span class="keyword">restrict</span> s1, <span class="type">const</span> <span class="type">void</span> * <span class="keyword">restrict</span> s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数都从 s2 指向的位置拷贝 n 字节到 s1 指向的位置，而且都返回 s1 的值。</p>
<p>所不同的是， <code>memcpy()</code>的参数带关键字<code>restrict</code>，即<code>memcpy()</code>假设两个内存区域之间没有重叠；而<code>memmove()</code>不作这样的假设，所以拷贝过程类似于先把所有字节拷贝到一个临时缓冲区，然后再拷贝到最终目的地。</p>
<h2 id="可变参数：stdarg-h"><a href="#可变参数：stdarg-h" class="headerlink" title="可变参数：stdarg.h"></a>可变参数：stdarg.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//varargs.c -- use variable number of arguments</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> s, t;</span><br><span class="line">	s = sum(<span class="number">3</span>, <span class="number">1.1</span>, <span class="number">2.5</span>, <span class="number">13.3</span>);</span><br><span class="line">	t = sum(<span class="number">6</span>, <span class="number">1.1</span>, <span class="number">2.1</span>, <span class="number">13.1</span>, <span class="number">4.1</span>, <span class="number">5.1</span>, <span class="number">6.1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;return value for &quot;</span></span><br><span class="line">		<span class="string">&quot;sum(3, 1.1, 2.5, 13.3): %g\n&quot;</span>, s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;return value for &quot;</span></span><br><span class="line">		<span class="string">&quot;sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): %g\n&quot;</span>, t);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> lim, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	va_list ap;          <span class="comment">// 声明一个对象储存参数</span></span><br><span class="line">	<span class="type">double</span> tot = <span class="number">0</span>;</span><br><span class="line">	va_start(ap, lim);    <span class="comment">// 把ap初始化为参数列表</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i++)</span><br><span class="line">		tot += va_arg(ap, <span class="type">double</span>); <span class="comment">// 访问参数列表中的每一项</span></span><br><span class="line">	va_end(ap);          <span class="comment">// 清理工作</span></span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高级数据表示"><a href="#高级数据表示" class="headerlink" title="高级数据表示"></a>高级数据表示</h1><h2 id="从数组到链表"><a href="#从数组到链表" class="headerlink" title="从数组到链表"></a>从数组到链表</h2><p>使用数组分配内存空间：</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2018.png"></p>
<p>一种方法是调用malloc()一次，为5个movies结构请求分配足够的空间；另一种方法是调用malloc()5次，分别为每个movies结构请求分配足够的空间。</p>
<p>如果用不完500个指针，这种方法节约了大量的内存，因为内含500个指针的数组比内含500个结构的数组所占的内存少得多。尽管如此，如果用不到 500 个指针，还是浪费了不少空间。而且，这样还是有500个结构的限制。</p>
<p>还有一种更好的方法。每次使用 malloc()为新结构分配空间时，也为新指针分配空间。但是，还得需要另一个指针来跟踪新分配的指针，用于跟踪新指针的指针本身，也需要一个指针来跟踪，以此类推。要重新定义结构才能解决这个潜在的问题，即每个结构中包含指向 next 结构的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TSIZE 45 <span class="comment">/* 储存片名的数组大小*/</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">film</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> title[TSIZE];</span><br><span class="line">	<span class="type">int</span> rating;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">film</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然结构不能含有与本身类型相同的结构，但是可以含有指向同类型结构的指针。这种定义是定义链表（linked list）的基础，链表中的每一项都包含着在何处能找到下一项的信息。</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2019.png"></p>
<p>假设要显示这个链表，每显示一项，就可以根据该项中已储存的地址来定位下一个待显示的项。然而，这种方案能正常运行，还需要一个指针储存链表中第1项的地址，因为链表中没有其他项储存该项的地址。此时，头指针就派上了用场。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* films2.c -- 使用结构链表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>    <span class="comment">/* 提供malloc()原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">/* 提供strcpy()原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSIZE 45    <span class="comment">/* 储存片名的数组大小 */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">film</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> title[TSIZE];</span><br><span class="line">	<span class="type">int</span> rating;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">film</span>* <span class="title">next</span>;</span>  <span class="comment">/* 指向链表中的下一个结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span>* st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">film</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">film</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>, * current;</span><br><span class="line">	<span class="type">char</span> input[TSIZE];</span><br><span class="line">	<span class="comment">/* 收集并储存信息 */</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Enter first movie title:&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (s_gets(input, TSIZE) != <span class="literal">NULL</span> &amp;&amp; input[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		current = (<span class="keyword">struct</span> film*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> film));</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">NULL</span>)   <span class="comment">/* 第1个结构 */</span></span><br><span class="line">			head = current;</span><br><span class="line">		<span class="keyword">else</span>         <span class="comment">/* 后续的结构 */</span></span><br><span class="line">			prev-&gt;next = current;</span><br><span class="line">		current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">strcpy</span>(current-&gt;title, input);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Enter your rating &lt;0-10&gt;:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;current-&gt;rating);</span><br><span class="line">		<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Enter next movie title (empty line to stop):&quot;</span>);</span><br><span class="line">		prev = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 显示电影列表 */</span></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No data entered. &quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Here is the movie list:\n&quot;</span>);</span><br><span class="line">	current = head;</span><br><span class="line">	<span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Movie: %s Rating: %d\n&quot;</span>,</span><br><span class="line">			current-&gt;title, current-&gt;rating);</span><br><span class="line">		current = current-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 完成任务，释放已分配的内存 */</span></span><br><span class="line">	<span class="keyword">for</span> (current = head; current != <span class="literal">NULL</span>; current = current-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(current);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;free\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span>* st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* ret_val;</span><br><span class="line">	<span class="type">char</span>* find;</span><br><span class="line">	ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">		find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);  <span class="comment">// 查找换行符</span></span><br><span class="line">		<span class="keyword">if</span> (find)        <span class="comment">// 如果地址不是 NULL，</span></span><br><span class="line">			*find = <span class="string">&#x27;\0&#x27;</span>;     <span class="comment">// 在此处放置一个空字符</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">				<span class="keyword">continue</span>;   <span class="comment">// 处理剩余输入行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象数据类型（ADT）"><a href="#抽象数据类型（ADT）" class="headerlink" title="抽象数据类型（ADT）"></a>抽象数据类型（ADT）</h2><p>计算机科学领域已开发了一种定义新类型的好方法，用3个步骤完成从抽象到具体的过程。</p>
<ol>
<li>提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种正式的抽象描述被称为抽象数据类型（ADT）。</li>
<li>开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执行所需操作的函数。例如在 C中，可以提供结构定义和操控该结构的函数原型。这些作用于用户定义类型的函数相当于作用于  C基本类型的内置运算符。需要使用该新类型的程序员可以使用这个接口进行编程。</li>
<li>编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无需了解具体的实现细节。</li>
</ol>
<p>链表的ADT：</p>
<p>类型名：　　　　简单链表<br>类型属性：　　　可以储存一系列项<br>类型操作：　　　初始化链表为空<br>确定链表为空<br>确定链表已满<br>确定链表中的项数<br>在链表末尾添加项<br>遍历链表，处理链表中的项<br>清空链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* list.h -- 简单链表类型的头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span> <span class="comment">/* C99特性      */</span></span></span><br><span class="line"><span class="comment">/* 特定程序的声明 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TSIZE  45 <span class="comment">/* 储存电影名的数组大小 */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">film</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> title[TSIZE];</span><br><span class="line">	<span class="type">int</span> rating;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 一般类型定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">film</span> <span class="title">Item</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Item item;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> Node* List;</span><br><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="comment">/*  操作：   初始化一个链表                        */</span></span><br><span class="line"><span class="comment">/*  前提条件： plist指向一个链表                   */</span></span><br><span class="line"><span class="comment">/*  后置条件： 链表初始化为空                      */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitializeList</span><span class="params">(List* plist)</span>;</span><br><span class="line"><span class="comment">/*  操作：   确定链表是否为空定义，plist指向一个已初始化的链表     */</span></span><br><span class="line"><span class="comment">/*  后置条件： 如果链表为空，该函数返回true；否则返回false         */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListIsEmpty</span><span class="params">(<span class="type">const</span> List* plist)</span>;</span><br><span class="line"><span class="comment">/*  操作：   确定链表是否已满，plist指向一个已初始化的链表         */</span></span><br><span class="line"><span class="comment">/*  后置条件： 如果链表已满，该函数返回真；否则返回假              */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListIsFull</span><span class="params">(<span class="type">const</span> List* plist)</span>;</span><br><span class="line"><span class="comment">/*  操作：   确定链表中的项数,  plist指向一个已初始化的链表        */</span></span><br><span class="line"><span class="comment">/*  后置条件： 该函数返回链表中的项数                              */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ListItemCount</span><span class="params">(<span class="type">const</span> List* plist)</span>;</span><br><span class="line"><span class="comment">/*  操作：   在链表的末尾添加项                                    */</span></span><br><span class="line"><span class="comment">/*  前提条件： item是一个待添加至链表的项, plist指向一个已初始化的链表    */</span></span><br><span class="line"><span class="comment">/*  后置条件： 如果可以，该函数在链表末尾添加一个项，且返回true；否则返回false */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">AddItem</span><span class="params">(Item item, List* plist)</span>;</span><br><span class="line"><span class="comment">/*  操作：   把函数作用于链表中的每一项               */</span></span><br><span class="line"><span class="comment">/*      plist指向一个已初始化的链表                   */</span></span><br><span class="line"><span class="comment">/*      pfun指向一个函数，该函数接受一个Item类型的参数，且无返回值   */</span></span><br><span class="line"><span class="comment">/*  后置条件： pfun指向的函数作用于链表中的每一项一次                */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(<span class="type">const</span> List* plist, <span class="type">void</span>(*pfun)(Item item))</span>;</span><br><span class="line"><span class="comment">/*  操作：   释放已分配的内存（如果有的话）                  */</span></span><br><span class="line"><span class="comment">/*      plist指向一个已初始化的链表                          */</span></span><br><span class="line"><span class="comment">/*  后置条件： 释放了为链表分配的所有内存，链表设置为空      */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EmptyTheList</span><span class="params">(List* plist)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="接口函数的实现"><a href="#接口函数的实现" class="headerlink" title="接口函数的实现"></a>接口函数的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* list.c -- 支持链表操作的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt; stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 局部函数原型 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CopyToNode</span><span class="params">(Item item, Node * pnode)</span>;</span><br><span class="line"><span class="comment">/* 接口函数 */</span></span><br><span class="line"><span class="comment">/* 把链表设置为空 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitializeList</span><span class="params">(List* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">	*plist = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果链表为空，返回true */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListIsEmpty</span><span class="params">(<span class="type">const</span> List* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*plist == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果链表已满，返回true */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListIsFull</span><span class="params">(<span class="type">const</span> List* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* pt;</span><br><span class="line">	<span class="type">bool</span> full;</span><br><span class="line">	pt = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (pt == <span class="literal">NULL</span>)</span><br><span class="line">		full = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		full = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">free</span>(pt);</span><br><span class="line">	<span class="keyword">return</span> full;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回节点的数量 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">ListItemCount</span><span class="params">(<span class="type">const</span> List* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	Node* pnode = *plist; <span class="comment">/* 设置链表的开始 */</span></span><br><span class="line">	<span class="keyword">while</span> (pnode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++count;</span><br><span class="line">		pnode = pnode-&gt;next; <span class="comment">/* 设置下一个节点 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建储存项的节点，并将其添加至由plist指向的链表末尾（较慢的实</span></span><br><span class="line"><span class="comment">现） */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">AddItem</span><span class="params">(Item item, List* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* pnew;</span><br><span class="line">	Node* scan = *plist;</span><br><span class="line">	pnew = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">/* 失败时退出函数 */</span></span><br><span class="line">	CopyToNode(item, pnew);</span><br><span class="line">	pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (scan == <span class="literal">NULL</span>)    <span class="comment">/* 空链表，所以把 */</span></span><br><span class="line">		*plist = pnew;   <span class="comment">/* pnew放在链表的开头 */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (scan-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">			scan = scan-&gt;next; <span class="comment">/* 找到链表的末尾 */</span></span><br><span class="line">		scan-&gt;next = pnew;  <span class="comment">/* 把pnew添加到链表的末尾 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 访问每个节点并执行pfun指向的函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traverse</span><span class="params">(<span class="type">const</span> List* plist, <span class="type">void</span>(*pfun)(Item item))</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* pnode = *plist; <span class="comment">/* 设置链表的开始 */</span></span><br><span class="line">	<span class="keyword">while</span> (pnode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		(*pfun)(pnode-&gt;item); <span class="comment">/* 把函数应用于链表中的项 */</span></span><br><span class="line">		pnode = pnode-&gt;next; <span class="comment">/* 前进到下一项 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 释放由malloc()分配的内存 */</span></span><br><span class="line"><span class="comment">/* 设置链表指针为NULL   */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EmptyTheList</span><span class="params">(List* plist)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node* psave;</span><br><span class="line">	<span class="keyword">while</span> (*plist != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		psave = (*plist)-&gt;next;  <span class="comment">/* 保存下一个节点的地址 */</span></span><br><span class="line">		<span class="built_in">free</span>(*plist);       <span class="comment">/* 释放当前节点    */</span></span><br><span class="line">		*plist = psave;      <span class="comment">/* 前进至下一个节点   */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 局部函数定义 */</span></span><br><span class="line"><span class="comment">/* 把一个项拷贝到节点中 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CopyToNode</span><span class="params">(Item item, Node* pnode)</span></span><br><span class="line">&#123;</span><br><span class="line">	pnode-&gt;item = item; <span class="comment">/* 拷贝结构 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* films3.c -- 使用抽象数据类型（ADT）风格的链表 */</span></span><br><span class="line"><span class="comment">/* 与list.c一起编译           */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">/* 提供exit()的原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.h&quot;</span>  <span class="comment">/* 定义List、Item */</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">showmovies</span><span class="params">(Item item)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span>* st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	List movies;</span><br><span class="line">	Item temp;</span><br><span class="line">	<span class="comment">/* 初始化   */</span></span><br><span class="line">	InitializeList(&amp;movies);</span><br><span class="line">	<span class="keyword">if</span> (ListIsFull(&amp;movies))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;No memory available! Bye!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 获取用户输入并储存 */</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Enter first movie title:&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (s_gets(temp.title, TSIZE) != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">		temp.title[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Enter your rating &lt;0-10&gt;:&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp.rating);</span><br><span class="line">		<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (AddItem(temp, &amp;movies) == <span class="literal">false</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Problem allocating memory\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ListIsFull(&amp;movies))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;The list is now full.&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;Enter next movie title (empty line to stop):&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 显示    */</span></span><br><span class="line">	<span class="keyword">if</span> (ListIsEmpty(&amp;movies))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;No data entered. &quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Here is the movie list:\n&quot;</span>);</span><br><span class="line">		Traverse(&amp;movies, showmovies);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You entered %d movies.\n&quot;</span>, ListItemCount(&amp;movies));</span><br><span class="line">	<span class="comment">/* 清理   */</span></span><br><span class="line">	EmptyTheList(&amp;movies);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">showmovies</span><span class="params">(Item item)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Movie: %s Rating: %d\n&quot;</span>, item.title,</span><br><span class="line">		item.rating);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span>* st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span>* ret_val;</span><br><span class="line">	<span class="type">char</span>* find;</span><br><span class="line">	ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret_val)</span><br><span class="line">	&#123;</span><br><span class="line">		find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);  <span class="comment">// 查找换行符</span></span><br><span class="line">		<span class="keyword">if</span> (find)           <span class="comment">// 如果地址不是NULL，</span></span><br><span class="line">			*find = <span class="string">&#x27;\0&#x27;</span>;     <span class="comment">// 在此处放置一个空字符</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">				<span class="keyword">continue</span>;      <span class="comment">// 处理输入行的剩余内容</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种“先进先出”（first in,first out，缩写为FIFO）的数据形式</p>
<p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2020.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Item;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Item item;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Node* front; <span class="comment">/* 指向队列首项的指针 */</span></span><br><span class="line">	Node* rear; <span class="comment">/*指向队列尾项的指针*/</span></span><br><span class="line">	<span class="type">int</span> items;    <span class="comment">/* 队列中的项数*/</span></span><br><span class="line">&#125; Queue;</span><br></pre></td></tr></table></figure>

<h2 id="链表和数组"><a href="#链表和数组" class="headerlink" title="链表和数组"></a>链表和数组</h2><p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2021.png"></p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p><img src="/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/Untitled%2022.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* Item;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Item item;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">trnode</span>* <span class="title">left</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">trnode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125; Trnode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Trnode* root;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125; Tree;</span><br></pre></td></tr></table></figure>
      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《C Primer Plus》笔记" target="_blank" rel="external">https://azreallem.github.io/2021/07/26/《C-Primer-Plus》笔记/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">昵称</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/07/30/EOF/" title="EOF"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/07/15/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="Hexo搭建个人博客"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>