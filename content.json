{"meta":{"title":"Azreallem's Blog","subtitle":"做一个纯粹的人","description":"路漫漫其修远兮，吾将上下而求索","author":"Azreallem","url":"https://azreallem.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-07-12T07:35:16.989Z","updated":"2022-07-12T07:35:16.989Z","comments":false,"path":"about/index.html","permalink":"https://azreallem.github.io/about/index.html","excerpt":"","text":"linux内核开发，C&#x2F;C++"},{"title":"分类","date":"2022-07-12T07:30:38.309Z","updated":"2022-07-11T07:46:12.084Z","comments":false,"path":"categories/index.html","permalink":"https://azreallem.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-12T07:30:45.273Z","updated":"2022-07-11T07:46:12.084Z","comments":false,"path":"tags/index.html","permalink":"https://azreallem.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Memory Layout of C programs","slug":"Memory Layout of C Programs","date":"2022-04-23T02:21:10.000Z","updated":"2022-08-18T07:41:09.839Z","comments":true,"path":"2022/04/23/Memory Layout of C Programs/","link":"","permalink":"https://azreallem.github.io/2022/04/23/Memory%20Layout%20of%20C%20Programs/","excerpt":"Memory Layout of C Programs 这篇文章主要讲C程序中的内存布局。","text":"Memory Layout of C Programs 这篇文章主要讲C程序中的内存布局。 mainA typical memory representation of a C program consists of the following sections. Text segment (i.e. instructions) frequently executed programs read-only Initialized data segment the global variables and static variables that are initialized by the programmer This segment can be further classified into the initialized read-only area and the initialized read-write area. Uninitialized data segment (bss) global variables and static variables that are initialized to zero or do not have explicit initialization in source code Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executing uninitialized data. HeapThe Heap area is managed by malloc, realloc, and free StackStack, where automatic variables are stored, along with information that is saved each time a function is called. Each time a function is called, the address of where to return to and certain information about the caller’s environment, such as some of the machine registers, are saved on the stack. The newly called function then allocates room on the stack for its automatic and temporary variables. 局部变量、函数调用信息、中断现场保留信息 test1234567891011#include &lt;stdio.h&gt; int global; /* Uninitialized variable stored in bss*/ int main(void)&#123; //static int i; /* Uninitialized static variable stored in bss */ static int i = 0; /* Uninitialized static variable stored in bss */ //static int j = 10; /* Initialized static variable stored in Initialized data segmemt */ return 0;&#125; 1234# gaoliang @ gaoliang-pc in ~/work/leetcode/test on git:master x [10:50:29]$ size memory_test text data bss dec hex filename 1418 544 16 1978 7ba memory_test 1objdump -s -d memory_layout &gt; memory_layout_obj.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316memory_layout: file format elf64-x86-64Contents of section .interp: 0318 2f6c6962 36342f6c 642d6c69 6e75782d /lib64/ld-linux- 0328 7838362d 36342e73 6f2e3200 x86-64.so.2. Contents of section .note.gnu.property: 0338 04000000 10000000 05000000 474e5500 ............GNU. 0348 020000c0 04000000 03000000 00000000 ................Contents of section .note.gnu.build-id: 0358 04000000 14000000 03000000 474e5500 ............GNU. 0368 bdd76df2 2293d5b4 75a2dacb a2c2891a ..m.&quot;...u....... 0378 a049839d .I.. Contents of section .note.ABI-tag: 037c 04000000 10000000 01000000 474e5500 ............GNU. 038c 00000000 03000000 02000000 00000000 ................Contents of section .gnu.hash: 03a0 02000000 05000000 01000000 06000000 ................ 03b0 00008100 00000000 05000000 00000000 ................ 03c0 d165ce6d .e.m Contents of section .dynsym: 03c8 00000000 00000000 00000000 00000000 ................ 03d8 00000000 00000000 38000000 20000000 ........8... ... 03e8 00000000 00000000 00000000 00000000 ................ 03f8 1a000000 12000000 00000000 00000000 ................ 0408 00000000 00000000 54000000 20000000 ........T... ... 0418 00000000 00000000 00000000 00000000 ................ 0428 63000000 20000000 00000000 00000000 c... ........... 0438 00000000 00000000 0b000000 22000000 ............&quot;... 0448 00000000 00000000 00000000 00000000 ................Contents of section .dynstr: 0458 006c6962 632e736f 2e36005f 5f637861 .libc.so.6.__cxa 0468 5f66696e 616c697a 65005f5f 6c696263 _finalize.__libc 0478 5f737461 72745f6d 61696e00 474c4942 _start_main.GLIB 0488 435f322e 322e3500 5f49544d 5f646572 C_2.2.5._ITM_der 0498 65676973 74657254 4d436c6f 6e655461 egisterTMCloneTa 04a8 626c6500 5f5f676d 6f6e5f73 74617274 ble.__gmon_start 04b8 5f5f005f 49544d5f 72656769 73746572 __._ITM_register 04c8 544d436c 6f6e6554 61626c65 00 TMCloneTable. Contents of section .gnu.version: 04d6 00000000 02000000 00000200 ............ Contents of section .gnu.version_r: 04e8 01000100 01000000 10000000 00000000 ................ 04f8 751a6909 00000200 2c000000 00000000 u.i.....,.......Contents of section .rela.dyn: 0508 f03d0000 00000000 08000000 00000000 .=.............. 0518 20110000 00000000 f83d0000 00000000 ........=...... 0528 08000000 00000000 e0100000 00000000 ................ 0538 08400000 00000000 08000000 00000000 .@.............. 0548 08400000 00000000 d83f0000 00000000 .@.......?...... 0558 06000000 01000000 00000000 00000000 ................ 0568 e03f0000 00000000 06000000 02000000 .?.............. 0578 00000000 00000000 e83f0000 00000000 .........?...... 0588 06000000 03000000 00000000 00000000 ................ 0598 f03f0000 00000000 06000000 04000000 .?.............. 05a8 00000000 00000000 f83f0000 00000000 .........?...... 05b8 06000000 05000000 00000000 00000000 ................Contents of section .init: 1000 f30f1efa 4883ec08 488b05d9 2f000048 ....H...H.../..H 1010 85c07402 ffd04883 c408c3 ..t...H.... Contents of section .plt: 1020 ff35a22f 0000f2ff 25a32f00 000f1f00 .5./....%./.....Contents of section .plt.got: 1030 f30f1efa f2ff25bd 2f00000f 1f440000 ......%./....D..Contents of section .text: 1040 f30f1efa 31ed4989 d15e4889 e24883e4 ....1.I..^H..H.. 1050 f050544c 8d055601 0000488d 0ddf0000 .PTL..V...H..... 1060 00488d3d c1000000 ff15722f 0000f490 .H.=......r/.... 1070 488d3d99 2f000048 8d05922f 00004839 H.=./..H.../..H9 1080 f8741548 8b054e2f 00004885 c07409ff .t.H..N/..H..t.. 1090 e00f1f80 00000000 c30f1f80 00000000 ................ 10a0 488d3d69 2f000048 8d35622f 00004829 H.=i/..H.5b/..H) 10b0 fe4889f0 48c1ee3f 48c1f803 4801c648 .H..H..?H...H..H 10c0 d1fe7414 488b0525 2f000048 85c07408 ..t.H..%/..H..t. 10d0 ffe0660f 1f440000 c30f1f80 00000000 ..f..D.......... 10e0 f30f1efa 803d252f 00000075 2b554883 .....=%/...u+UH. 10f0 3d022f00 00004889 e5740c48 8b3d062f =./...H..t.H.=./ 1100 0000e829 ffffffe8 64ffffff c605fd2e ...)....d....... 1110 0000015d c30f1f00 c30f1f80 00000000 ...]............ 1120 f30f1efa e977ffff fff30f1e fa554889 .....w.......UH. 1130 e5b80000 00005dc3 0f1f8400 00000000 ......]......... 1140 f30f1efa 41574c8d 3da32c00 00415649 ....AWL.=.,..AVI 1150 89d64155 4989f541 544189fc 55488d2d ..AUI..ATA..UH.- 1160 942c0000 534c29fd 4883ec08 e88ffeff .,..SL).H....... 1170 ff48c1fd 03741f31 db0f1f80 00000000 .H...t.1........ 1180 4c89f24c 89ee4489 e741ff14 df4883c3 L..L..D..A...H.. 1190 014839dd 75ea4883 c4085b5d 415c415d .H9.u.H...[]A\\A] 11a0 415e415f c366662e 0f1f8400 00000000 A^A_.ff......... 11b0 f30f1efa c3 ..... Contents of section .fini: 11b8 f30f1efa 4883ec08 4883c408 c3 ....H...H.... Contents of section .rodata: 2000 01000200 .... Contents of section .eh_frame_hdr: 2004 011b033b 38000000 06000000 1cf0ffff ...;8........... 2014 6c000000 2cf0ffff 94000000 3cf0ffff l...,.......&lt;... 2024 54000000 25f1ffff ac000000 3cf1ffff T...%.......&lt;... 2034 cc000000 acf1ffff 14010000 ............ Contents of section .eh_frame: 2040 14000000 00000000 017a5200 01781001 .........zR..x.. 2050 1b0c0708 90010000 14000000 1c000000 ................ 2060 e0efffff 2f000000 00440710 00000000 ..../....D...... 2070 24000000 34000000 a8efffff 10000000 $...4........... 2080 000e1046 0e184a0f 0b770880 003f1a3a ...F..J..w...?.: 2090 2a332422 00000000 14000000 5c000000 *3$&quot;........\\... 20a0 90efffff 10000000 00000000 00000000 ................ 20b0 1c000000 74000000 71f0ffff 0f000000 ....t...q....... 20c0 00450e10 8602430d 06460c07 08000000 .E....C..F...... 20d0 44000000 94000000 68f0ffff 65000000 D.......h...e... 20e0 00460e10 8f02490e 188e0345 0e208d04 .F....I....E. .. 20f0 450e288c 05440e30 8606480e 38830747 E.(..D.0..H.8..G 2100 0e406e0e 38410e30 410e2842 0e20420e .@n.8A.0A.(B. B. 2110 18420e10 420e0800 10000000 dc000000 .B..B........... 2120 90f0ffff 05000000 00000000 00000000 ................Contents of section .init_array: 3df0 20110000 00000000 ....... Contents of section .fini_array: 3df8 e0100000 00000000 ........ Contents of section .dynamic: 3e00 01000000 00000000 01000000 00000000 ................ 3e10 0c000000 00000000 00100000 00000000 ................ 3e20 0d000000 00000000 b8110000 00000000 ................ 3e30 19000000 00000000 f03d0000 00000000 .........=...... 3e40 1b000000 00000000 08000000 00000000 ................ 3e50 1a000000 00000000 f83d0000 00000000 .........=...... 3e60 1c000000 00000000 08000000 00000000 ................ 3e70 f5feff6f 00000000 a0030000 00000000 ...o............ 3e80 05000000 00000000 58040000 00000000 ........X....... 3e90 06000000 00000000 c8030000 00000000 ................ 3ea0 0a000000 00000000 7d000000 00000000 ........&#125;....... 3eb0 0b000000 00000000 18000000 00000000 ................ 3ec0 15000000 00000000 00000000 00000000 ................ 3ed0 03000000 00000000 c03f0000 00000000 .........?...... 3ee0 07000000 00000000 08050000 00000000 ................ 3ef0 08000000 00000000 c0000000 00000000 ................ 3f00 09000000 00000000 18000000 00000000 ................ 3f10 1e000000 00000000 08000000 00000000 ................ 3f20 fbffff6f 00000000 01000008 00000000 ...o............ 3f30 feffff6f 00000000 e8040000 00000000 ...o............ 3f40 ffffff6f 00000000 01000000 00000000 ...o............ 3f50 f0ffff6f 00000000 d6040000 00000000 ...o............ 3f60 f9ffff6f 00000000 03000000 00000000 ...o............ 3f70 00000000 00000000 00000000 00000000 ................ 3f80 00000000 00000000 00000000 00000000 ................ 3f90 00000000 00000000 00000000 00000000 ................ 3fa0 00000000 00000000 00000000 00000000 ................ 3fb0 00000000 00000000 00000000 00000000 ................Contents of section .got: 3fc0 003e0000 00000000 00000000 00000000 .&gt;.............. 3fd0 00000000 00000000 00000000 00000000 ................ 3fe0 00000000 00000000 00000000 00000000 ................ 3ff0 00000000 00000000 00000000 00000000 ................Contents of section .data: 4000 00000000 00000000 08400000 00000000 .........@......Contents of section .comment: 0000 4743433a 20285562 756e7475 20392e34 GCC: (Ubuntu 9.4 0010 2e302d31 7562756e 7475317e 32302e30 .0-1ubuntu1~20.0 0020 342e3129 20392e34 2e3000 4.1) 9.4.0. Disassembly of section .init:0000000000001000 &lt;_init&gt;: 1000: f3 0f 1e fa endbr64 1004: 48 83 ec 08 sub $0x8,%rsp 1008: 48 8b 05 d9 2f 00 00 mov 0x2fd9(%rip),%rax # 3fe8 &lt;__gmon_start__&gt; 100f: 48 85 c0 test %rax,%rax 1012: 74 02 je 1016 &lt;_init+0x16&gt; 1014: ff d0 callq *%rax 1016: 48 83 c4 08 add $0x8,%rsp 101a: c3 retq Disassembly of section .plt:0000000000001020 &lt;.plt&gt;: 1020: ff 35 a2 2f 00 00 pushq 0x2fa2(%rip) # 3fc8 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt; 1026: f2 ff 25 a3 2f 00 00 bnd jmpq *0x2fa3(%rip) # 3fd0 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt; 102d: 0f 1f 00 nopl (%rax)Disassembly of section .plt.got:0000000000001030 &lt;__cxa_finalize@plt&gt;: 1030: f3 0f 1e fa endbr64 1034: f2 ff 25 bd 2f 00 00 bnd jmpq *0x2fbd(%rip) # 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt; 103b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1)Disassembly of section .text:0000000000001040 &lt;_start&gt;: 1040: f3 0f 1e fa endbr64 1044: 31 ed xor %ebp,%ebp 1046: 49 89 d1 mov %rdx,%r9 1049: 5e pop %rsi 104a: 48 89 e2 mov %rsp,%rdx 104d: 48 83 e4 f0 and $0xfffffffffffffff0,%rsp 1051: 50 push %rax 1052: 54 push %rsp 1053: 4c 8d 05 56 01 00 00 lea 0x156(%rip),%r8 # 11b0 &lt;__libc_csu_fini&gt; 105a: 48 8d 0d df 00 00 00 lea 0xdf(%rip),%rcx # 1140 &lt;__libc_csu_init&gt; 1061: 48 8d 3d c1 00 00 00 lea 0xc1(%rip),%rdi # 1129 &lt;main&gt; 1068: ff 15 72 2f 00 00 callq *0x2f72(%rip) # 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt; 106e: f4 hlt 106f: 90 nop0000000000001070 &lt;deregister_tm_clones&gt;: 1070: 48 8d 3d 99 2f 00 00 lea 0x2f99(%rip),%rdi # 4010 &lt;__TMC_END__&gt; 1077: 48 8d 05 92 2f 00 00 lea 0x2f92(%rip),%rax # 4010 &lt;__TMC_END__&gt; 107e: 48 39 f8 cmp %rdi,%rax 1081: 74 15 je 1098 &lt;deregister_tm_clones+0x28&gt; 1083: 48 8b 05 4e 2f 00 00 mov 0x2f4e(%rip),%rax # 3fd8 &lt;_ITM_deregisterTMCloneTable&gt; 108a: 48 85 c0 test %rax,%rax 108d: 74 09 je 1098 &lt;deregister_tm_clones+0x28&gt; 108f: ff e0 jmpq *%rax 1091: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 1098: c3 retq 1099: 0f 1f 80 00 00 00 00 nopl 0x0(%rax)00000000000010a0 &lt;register_tm_clones&gt;: 10a0: 48 8d 3d 69 2f 00 00 lea 0x2f69(%rip),%rdi # 4010 &lt;__TMC_END__&gt; 10a7: 48 8d 35 62 2f 00 00 lea 0x2f62(%rip),%rsi # 4010 &lt;__TMC_END__&gt; 10ae: 48 29 fe sub %rdi,%rsi 10b1: 48 89 f0 mov %rsi,%rax 10b4: 48 c1 ee 3f shr $0x3f,%rsi 10b8: 48 c1 f8 03 sar $0x3,%rax 10bc: 48 01 c6 add %rax,%rsi 10bf: 48 d1 fe sar %rsi 10c2: 74 14 je 10d8 &lt;register_tm_clones+0x38&gt; 10c4: 48 8b 05 25 2f 00 00 mov 0x2f25(%rip),%rax # 3ff0 &lt;_ITM_registerTMCloneTable&gt; 10cb: 48 85 c0 test %rax,%rax 10ce: 74 08 je 10d8 &lt;register_tm_clones+0x38&gt; 10d0: ff e0 jmpq *%rax 10d2: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 10d8: c3 retq 10d9: 0f 1f 80 00 00 00 00 nopl 0x0(%rax)00000000000010e0 &lt;__do_global_dtors_aux&gt;: 10e0: f3 0f 1e fa endbr64 10e4: 80 3d 25 2f 00 00 00 cmpb $0x0,0x2f25(%rip) # 4010 &lt;__TMC_END__&gt; 10eb: 75 2b jne 1118 &lt;__do_global_dtors_aux+0x38&gt; 10ed: 55 push %rbp 10ee: 48 83 3d 02 2f 00 00 cmpq $0x0,0x2f02(%rip) # 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt; 10f5: 00 10f6: 48 89 e5 mov %rsp,%rbp 10f9: 74 0c je 1107 &lt;__do_global_dtors_aux+0x27&gt; 10fb: 48 8b 3d 06 2f 00 00 mov 0x2f06(%rip),%rdi # 4008 &lt;__dso_handle&gt; 1102: e8 29 ff ff ff callq 1030 &lt;__cxa_finalize@plt&gt; 1107: e8 64 ff ff ff callq 1070 &lt;deregister_tm_clones&gt; 110c: c6 05 fd 2e 00 00 01 movb $0x1,0x2efd(%rip) # 4010 &lt;__TMC_END__&gt; 1113: 5d pop %rbp 1114: c3 retq 1115: 0f 1f 00 nopl (%rax) 1118: c3 retq 1119: 0f 1f 80 00 00 00 00 nopl 0x0(%rax)0000000000001120 &lt;frame_dummy&gt;: 1120: f3 0f 1e fa endbr64 1124: e9 77 ff ff ff jmpq 10a0 &lt;register_tm_clones&gt;0000000000001129 &lt;main&gt;: 1129: f3 0f 1e fa endbr64 112d: 55 push %rbp 112e: 48 89 e5 mov %rsp,%rbp 1131: b8 00 00 00 00 mov $0x0,%eax 1136: 5d pop %rbp 1137: c3 retq 1138: 0f 1f 84 00 00 00 00 nopl 0x0(%rax,%rax,1) 113f: 00 0000000000001140 &lt;__libc_csu_init&gt;: 1140: f3 0f 1e fa endbr64 1144: 41 57 push %r15 1146: 4c 8d 3d a3 2c 00 00 lea 0x2ca3(%rip),%r15 # 3df0 &lt;__frame_dummy_init_array_entry&gt; 114d: 41 56 push %r14 114f: 49 89 d6 mov %rdx,%r14 1152: 41 55 push %r13 1154: 49 89 f5 mov %rsi,%r13 1157: 41 54 push %r12 1159: 41 89 fc mov %edi,%r12d 115c: 55 push %rbp 115d: 48 8d 2d 94 2c 00 00 lea 0x2c94(%rip),%rbp # 3df8 &lt;__do_global_dtors_aux_fini_array_entry&gt; 1164: 53 push %rbx 1165: 4c 29 fd sub %r15,%rbp 1168: 48 83 ec 08 sub $0x8,%rsp 116c: e8 8f fe ff ff callq 1000 &lt;_init&gt; 1171: 48 c1 fd 03 sar $0x3,%rbp 1175: 74 1f je 1196 &lt;__libc_csu_init+0x56&gt; 1177: 31 db xor %ebx,%ebx 1179: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 1180: 4c 89 f2 mov %r14,%rdx 1183: 4c 89 ee mov %r13,%rsi 1186: 44 89 e7 mov %r12d,%edi 1189: 41 ff 14 df callq *(%r15,%rbx,8) 118d: 48 83 c3 01 add $0x1,%rbx 1191: 48 39 dd cmp %rbx,%rbp 1194: 75 ea jne 1180 &lt;__libc_csu_init+0x40&gt; 1196: 48 83 c4 08 add $0x8,%rsp 119a: 5b pop %rbx 119b: 5d pop %rbp 119c: 41 5c pop %r12 119e: 41 5d pop %r13 11a0: 41 5e pop %r14 11a2: 41 5f pop %r15 11a4: c3 retq 11a5: 66 66 2e 0f 1f 84 00 data16 nopw %cs:0x0(%rax,%rax,1) 11ac: 00 00 00 00 00000000000011b0 &lt;__libc_csu_fini&gt;: 11b0: f3 0f 1e fa endbr64 11b4: c3 retq Disassembly of section .fini:00000000000011b8 &lt;_fini&gt;: 11b8: f3 0f 1e fa endbr64 11bc: 48 83 ec 08 sub $0x8,%rsp 11c0: 48 83 c4 08 add $0x8,%rsp 11c4: c3 retq","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://azreallem.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"link","slug":"link","permalink":"https://azreallem.github.io/tags/link/"},{"name":"OS","slug":"OS","permalink":"https://azreallem.github.io/tags/OS/"}]},{"title":"","slug":"linuxatemyram","date":"2022-04-16T02:20:11.000Z","updated":"2022-04-23T03:24:07.091Z","comments":true,"path":"2022/04/16/linuxatemyram/","link":"","permalink":"https://azreallem.github.io/2022/04/16/linuxatemyram/","excerpt":"Linux ate my arm!This is an interesting article.","text":"Linux ate my arm!This is an interesting article.","categories":[],"tags":[{"name":"link","slug":"link","permalink":"https://azreallem.github.io/tags/link/"}]},{"title":"linux-probe-note","slug":"linux-probe-note","date":"2022-04-13T14:33:18.000Z","updated":"2022-04-13T14:46:26.000Z","comments":true,"path":"2022/04/13/linux-probe-note/","link":"","permalink":"https://azreallem.github.io/2022/04/13/linux-probe-note/","excerpt":"","text":"Linux 就该这么学Linux_Probe.pdf 第2章 新手必须掌握的 Linux 命令EASY COMMAND12345678910echo [STRING]daterebootpoweroffwget http://www.baidu.comtoppidof [program]kill -9 [pid]killall [program]ps -aux 系统状态检测命令12345678ifconfigip addruname -auptime # 查看信息的负载情况free -h # 查看内存的使用量信息whoamilast # 查看所有系统的登录记录history [-c] # -c clear history 工作目录切换命令123456789101112131415161718pwdcdls -lt # 时间从大到小排序ls -ltr # 时间从小到大排序ls -ld # 显示目录属性信息ls -alhtrcat [filename]cat [filename] | lesscat [filename] | morecat &gt; 1.txt &lt;&lt; EOFEOFhead -n 20 [filename]tail -f [filename] # 实时刷新cat [filename] | tr [a-z] [A-Z] # 文本替换wc -lwc [filename] # 统计文件的行数，字数，字节数stat [filename] # 查看文件详情cut -d: -f1 /etc/passwd # 按列提取，分隔符:diff [-c] [filename1] [filename2] 文件目录管理命令1234567891011121314151617181920touch -d &quot;2017-05-04 01:12&quot; [filename] # 修改文件日期 # -a 读取日期 # -m 修改日期 # -d 同时修改读取日期和修改日期mkdir -p a/b/c/dcp [-p|-d|-r|-i|-a] [file1] [file2] # -p 保留原始文件属性 # -d 若对象为链接文件，则保留为链接文件 # -r 递归复制 # -i 询问是否覆盖 # -a 相当于-pdrmv [file1] [file2]rm -rf *dd if=/dev/zero of=560_file count=1 bs=560Mdd if=/dev/cdrom of=file_name.isotar -cvf [new_filename] [dir]tar -xvf [filename]tar -t [filename] # 查看压缩包有哪些文件grep -Iinr &quot;string&quot; [filename] # 查找关键字grep -v &quot;string&quot; [filename] # 去掉string的行find ./ -name &quot;1.txt&quot; 第3章 管道符、重定向与环境变量重定向 标准输入重定向（STDIN，文件描述符0）: 键盘、文件、命令中输入 标准输出重定向（STDOUT，文件描述符1）：输出到屏幕 错误输出重定向（STDERR，文件描述符2）：输出到屏幕1234ls xxx 1.txt &gt;&gt; 1.txt 2&gt;&amp;1 # 正确、错误都输出到文件1.txtls xxx 1.txt &amp;&gt;&gt; 1.txtls xxx 1.txt 2&gt;&gt; 1.txt # 仅输出错误到文件1.txt 管道命令1 ｜ 命令2 ｜ 命令3 命令行通配符123ls *.txtls 1.tx?ls [0-9].txt 转义字符 \\ ：转义字符 ‘’ ：转义所有变量变为字符串 “” : 不转义 `` ：命令执行后的返回结果 环境变量 HOME SHELL HISTSIZE HISTFILESIZE MAIL LANG RANDOM PS1 PATH EDITOR 第4章 Shell命令脚本shell传参例如$0 对应的是当前 Shell 脚本程序的名称，$#对应的是总共有几个参数，$*对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第 N 个位置的参数值。 1234#!/bin/bashecho &quot;当前脚本名称为$0&quot;echo &quot;总共有$#个参数，分别是$*&quot;echo &quot;第1个参数是$1,第5个参数是$5&quot; 判断参数条件表达式两边有一个空格 文件测试语句 逻辑测试语句 整数测试语句 字符串测试语句 运算符 作用 -d 测试文件是否为目录类型 -e 测试文件是否存在 -f 判断是否为一般文件 -r 测试当前用户是否有权限读取 -w 测试当前用户是否有权限写入 -x 测试当前用户是否有权限执行 0: 是， 1: 不是与C语言不同，C语言0代表false，非0代表true &amp;&amp;：表示当前指令执行成功后才会执行； ||：表示当前指令执行失败后才会执行； 12345678#!/bin/bash[ -d $1 ]echo “$1是否为目录（0:是，1:不是）：$?”[ -e $2 ] &amp;&amp; echo &quot;$2文件存在&quot; || &quot;$2文件不存在&quot;[ -f $2 ] &amp;&amp; echo &quot;$2为一般文件&quot;[ -r $3 ] &amp;&amp; echo &quot;当前用户对$3有read权限&quot;[ -w $4 ] &amp;&amp; echo &quot;当前用户对$4有write权限&quot;[ -x $4 ] &amp;&amp; echo &quot;当前用户对$4有execute权限&quot; 运算符 作用 -eq 是否等于 -ne 是否不等于 -gt 是否大于greater -lt 是否小于lesser -le 是否小于等于lesser equal -ge 是否大于等于greater equal 1234#!/bin/bashfree -m | grep Mem: | awk &#x27;&#123;print $4&#125;&#x27;FreeMem=$?[ $FreeMem -lt 1024 ] &amp;&amp; echo &quot;Insufficient Memory&quot; notes: awk &#123;print $4&#125;表示只保留第4列，FreeMem=$?赋值语句等号左右两边没有空格。 运算符 作用 &#x3D; 比较字符串内容是否相同 !&#x3D; 比较字符串内容是否不同 z 比较字符串内容是否为空 123#!/bin/bash[ -z $1 ] &amp;&amp; echo &quot;参数1为：$1&quot; || echo &quot;没有字符串传参&quot;[ $1 == $2 ] &amp;&amp; echo &quot;$1 == $2&quot; || echo &quot;$1 != $2&quot; 流程语句if 条件测试语句123456789if [ ... ]then......elif [ ... ]then......else......fi 1234567891011#!/bin/bashread -p &quot;Enter your score (0-100):&quot; GRADEif [ $GRADE -ge 85 ] &amp;&amp; [ $GRADE -le 100 ]then echo &quot;$GRADE is Excellent&quot;elif [ $GRADE -ge 70 ] &amp;&amp; [ $GRADE -lt 85 ]then echo &quot;$GRADE is Pass&quot;else echo &quot;$GRADE fall&quot;fi for 条件循环语句1234for ... in ...do......done 12345678910111213141516171819#!/bin/bashread -p &quot;Enter The Users Password : &quot; PASSWDfor UNAME in `cat users.txt`doid $UNAME &amp;&gt; /dev/nullif [ $? -eq 0 ]thenecho &quot;Already exists&quot;elseuseradd $UNAME &amp;&gt; /dev/nullecho &quot;$PASSWD&quot; | passwd --stdin $UNAME &amp;&gt; /dev/nullif [ $? -eq 0 ]thenecho &quot;$UNAME , Create success&quot;elseecho &quot;$UNAME , Create failure&quot;fifidone while 条件循环语句1234while ...do......done 1234567891011121314151617#!/bin/bashPRICE=$(expr $RANDOM % 1000)TIMES=0echo &quot;商品实际价格为 0-999 之间，猜猜看是多少?&quot;while truedoread -p &quot;请输入您猜测的价格数目:&quot; INTlet TIMES++if [ $INT -eq $PRICE ]then echo &quot;恭喜您答对了，实际价格是 $PRICE&quot; echo &quot;您总共猜 g $TIMES 次&quot;exit 0elif [ $INT -gt $PRICE ]then echo &quot;太高了!&quot;elseecho &quot;太低了!&quot;fidone case 条件测试语句12345678910case ... in[a-z][A-Z]).......;;[0-9]).......;;*).......esac 123456789101112#!/bin/bashread -p &quot;请输入一个字符，并按 Enter 键确认:&quot; KEYcase &quot;$KEY&quot; in[a-z]|[A-Z])echo &quot;您输入的是 字母。&quot;;;[0-9])echo &quot;您输入的是 数字。&quot;;;*)echo &quot;您输入的是 空格、功能键或其他控制字符。&quot;esac","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://azreallem.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"note","slug":"note","permalink":"https://azreallem.github.io/tags/note/"},{"name":"book","slug":"book","permalink":"https://azreallem.github.io/tags/book/"}]},{"title":"Linux中的软链接和硬链接","slug":"Linux中的软链接和硬链接","date":"2022-04-13T03:37:50.000Z","updated":"2022-04-14T01:11:12.000Z","comments":true,"path":"2022/04/13/Linux中的软链接和硬链接/","link":"","permalink":"https://azreallem.github.io/2022/04/13/Linux%E4%B8%AD%E7%9A%84%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/","excerpt":"","text":"硬链接在文件系统里，每一个文件都会有一个 索引节点(Inode Index) ，这个索引节点用来标识这个文件，硬链接就是通过这个索引节点进行链接。只有在同一文件系统中的文件之间才能创建硬链接，不能对目录进行创建。硬链接相当于创建了源文件的副本，如果硬链接文件的内容修改了，那么源文件的内容也会改变。 优点：源文件删除了，只要还有一个硬链接存在，该文件都还可以用。缺点：在Linux中包含很多的文件系统和分区，然而硬链接只能在同一个文件系统下创建。 1ln source.txt destination.txt 软链接在Linux系统下，软链接可以实现文件或者目录的共享，它就像Windows下的快捷方式一样。 当源文件删除时，软链接依旧存在，但是所指向的文件是空的。此时会输出No such file or directory 1ln -s source.txt destination.txt","categories":[{"name":"随手笔记","slug":"随手笔记","permalink":"https://azreallem.github.io/categories/%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://azreallem.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://azreallem.github.io/tags/shell/"},{"name":"quckily-note","slug":"quckily-note","permalink":"https://azreallem.github.io/tags/quckily-note/"}]},{"title":"组合问题算法题","slug":"组合问题算法题","date":"2022-04-03T08:57:18.000Z","updated":"2022-04-14T01:08:14.000Z","comments":true,"path":"2022/04/03/组合问题算法题/","link":"","permalink":"https://azreallem.github.io/2022/04/03/%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"","text":"题目00112223467899由以上数字组成7个数（如 08 , 12, 29等）要求最大的数字不超过35且至少有2个数不超过15，并且不能重复，请列出所有组合。 算法思想 关于组合问题的求解，可以使用回溯法，path[int]用来存储路径，res[int][int]用于存储结果集，对于去重，可以使用used[bool]来标记该层上一个相同结点的枝是否使用过。本题问题的难点在于如何处理”00112223467899”字符串，是在回溯递归的函数中逐一处理字符串中的字符，还是先将字符串转换为符合条件的int数组，采用后者的方法更为简洁便利。先将”00112223467899”字符串转换为两位数且小于等于35的全排列的int数组vec，然后对vec进行处理。但是还要知道字符串中0~9哪些使用过，所以还需要map&lt;char, int&gt;来标记0~9每个char还剩几个可以使用。 初始化 初始化map&lt;char, int&gt; map_str，用来表示”00112223467899”字符串中0～9出现的频率; 将”00112223467899”字符串转换为两位数且小于等于35的全排列数的数组vector&lt;int&gt; vec; 初始化vec长度的vector&lt;bool&gt; used数组作为backtracking()里的参数，用来判断和标记为同层的树枝是否使用过; vector&lt;vector&lt;int&gt;&gt; res 该二维数组表示组合结果; vector&lt;int&gt; path 该数组表示当前的单条路径; 回溯过程 void backtracking(const vector&lt;int&gt; vec, int n, int index, vector&lt;bool&gt;&amp; used)其中const vector&lt;int&gt; vec表示两位数且小于等于35的全排列数的数组，n为元素总个数，index为vec当前的索引号,vector&lt;bool&gt; used用来判断同层相同结点的树枝是否使用过; 接着就是回溯的过程；可以参考0040.组合总和II; 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;using namespace std;namespace std &#123; ostream&amp; operator&lt;&lt;(ostream&amp; os, vector&lt;int&gt; vec) &#123; os &lt;&lt; &quot;&#123;&quot;; for (int i = 0; i &lt; vec.size(); i++) &#123; os &lt;&lt; vec[i]; if (i != vec.size() -1) os &lt;&lt; &quot;, &quot;; &#125; os &lt;&lt; &quot;&#125;&quot;; return os; &#125;&#125;vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;unordered_map&lt;char, int&gt; map_str;bool is_valid(int n, int flag)&#123; string str = &quot;&quot;; if (n &lt; 10) str += &quot;0&quot;; str += to_string(n); if (flag == 1) &#123; map_str[str[0]]++; map_str[str[1]]++; return true; &#125; if ((str[0] != str[1] &amp;&amp; map_str[str[0]] &gt;= 1 \\ &amp;&amp; map_str[str[1]] &gt;= 1) \\ || str[0] == str[1]) &#123; if (str[0] == str[1] &amp;&amp; map_str[str[0]] &lt; 2) return false; map_str[str[0]]--; map_str[str[1]]--; return true; &#125; return false;&#125;bool is_repeat(vector&lt;int&gt; vec)&#123; set&lt;int&gt; s(vec.begin(),vec.end()); return s.size() == vec.size() ? false : true;&#125;int num_less(vector&lt;int&gt; vec, int n, int min)&#123; int count = 0; for (auto x : vec) if (x &lt; min) count++; return count;&#125;void backtracking(const vector&lt;int&gt; vec, int n, int index, vector&lt;bool&gt;&amp; used)&#123; if (path.size() == n) &#123; if (num_less(path, 2, 15) &gt;= 2 &amp;&amp; !is_repeat(path)) res.push_back(path); return; &#125; for (int i = index; i &lt; vec.size(); i++) &#123; if (i &gt; 0 &amp;&amp; used[i-1] == false &amp;&amp; vec[i] == vec[i-1]) continue; if (!is_valid(vec[i], 0)) continue; used[i] = true; path.push_back(vec[i]); backtracking(vec, n, i + 1, used); is_valid(vec[i], 1); used[i] = false; path.pop_back(); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(string str)&#123; res.clear(); path.clear(); map_str.clear(); string tmp; vector&lt;int&gt; vec; for (int i = 0; i &lt; str.size(); i++) map_str[str[i]]++; for (auto x : map_str) &#123; tmp = &quot;00&quot;; for (int t = 0; t &lt; x.second / 2; t++) &#123; tmp[0] = x.first; tmp[1] = x.first; if (stoi(tmp) &gt; 35) break; vec.push_back(stoi(tmp)); &#125; for (auto y : map_str) &#123; if (x.first == y.first) continue; int t = min(x.second, y.second); while (t--) &#123; tmp[0] = x.first; tmp[1] = y.first; if (stoi(tmp) &gt; 35) break; vec.push_back(stoi(tmp)); &#125; &#125; &#125; sort(vec.begin(), vec.end()); vector&lt;bool&gt; used(vec.size(), false); backtracking(vec, str.size() / 2, 0, used); return res;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; myres = combine(&quot;00112223467899&quot;); copy(begin(myres), end(myres), ostream_iterator&lt;vector&lt;int&gt;&gt;&#123;cout,&quot;\\n&quot;&#125;); return 0;&#125; gdb调试过程初始化后各数组的值 运行结果","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://azreallem.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://azreallem.github.io/tags/algorithm/"},{"name":"c++","slug":"c","permalink":"https://azreallem.github.io/tags/c/"},{"name":"combine","slug":"combine","permalink":"https://azreallem.github.io/tags/combine/"},{"name":"backtracking","slug":"backtracking","permalink":"https://azreallem.github.io/tags/backtracking/"}]},{"title":"iproute2 中 tc qdisc cbs源码分析","slug":"iproute2-中-tc-qdisc-cbs源码分析","date":"2022-03-29T14:27:26.000Z","updated":"2022-03-29T18:55:39.000Z","comments":true,"path":"2022/03/29/iproute2-中-tc-qdisc-cbs源码分析/","link":"","permalink":"https://azreallem.github.io/2022/03/29/iproute2-%E4%B8%AD-tc-qdisc-cbs%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"iproute2 用户空间Sched 与 iproute2 的通信，是典型的 Linux 内核模块和用户空间的进程之间的通信，这 种通信一般由 Netlink Socket 来提供这种双向的通信连接。这种连接由标准的提供给用户进程的 socket 和提供给内核模块的 API 组成，用户空间的接口简单的说就是创建一个 family 为 AF_NETLINK 的 socket，然后使用这个 socket 进行通信。 rtnl_open() 函数的作用是打开一个AF_NETLINK 的 socket，rtnl_close() 函数的作用是关闭一个AF_NETLINK 的 socket。 用户空间通信前的准备：填充 netlink 包；然后把 netlink 包发送到内核空间去。 tc.c 通过cbs_qdisc_util→cbs_parse_opt调用 q_cbs.c 中的cbs_parse_opt()函数。 q_cbs.c 最后通过rtnl_talk(&amp;rth, &amp;req.n, NULL)把 netlink 包发送到内核空间去，rtnl_talk()发送过程包括 sendmsg 和 recvmsg。 内核模块的初始化内核模块的初始化：在 net/sched/sch_api.c 文件中的 void __init pktsched_init (void)函数中，初始化了 link_rtnetlink_table 表，link_rtnetlink_table 是一张 struct rtnetlink_link的表。 1234struct rtnetlink_link &#123; int (*doit)(struct sk_buff *, struct nlmsghdr*, void *attr); int (*dumpit)(struct sk_buff *, struct netlink_callback *cb);&#125;; 1234567891011121314151617181920212223242526272829static int __init pktsched_init(void)&#123; int err; err = register_pernet_subsys(&amp;psched_net_ops); if (err) &#123; pr_err(&quot;pktsched_init: &quot; &quot;cannot initialize per netns operations\\n&quot;); return err; &#125; register_qdisc(&amp;pfifo_fast_ops); register_qdisc(&amp;pfifo_qdisc_ops); register_qdisc(&amp;bfifo_qdisc_ops); register_qdisc(&amp;pfifo_head_drop_qdisc_ops); register_qdisc(&amp;mq_qdisc_ops); register_qdisc(&amp;noqueue_qdisc_ops); rtnl_register(PF_UNSPEC, RTM_NEWQDISC, tc_modify_qdisc, NULL, 0); rtnl_register(PF_UNSPEC, RTM_DELQDISC, tc_get_qdisc, NULL, 0); rtnl_register(PF_UNSPEC, RTM_GETQDISC, tc_get_qdisc, tc_dump_qdisc, 0); rtnl_register(PF_UNSPEC, RTM_NEWTCLASS, tc_ctl_tclass, NULL, 0); rtnl_register(PF_UNSPEC, RTM_DELTCLASS, tc_ctl_tclass, NULL, 0); rtnl_register(PF_UNSPEC, RTM_GETTCLASS, tc_ctl_tclass, tc_dump_tclass, 0); return 0;&#125; struct rtnetlink_link 由函数指针 doit 和 dumpit 组成，这张表可以由需要执行的动作的宏定义 （例如：RTM_NEWQDISC，RTM_DELQDISC）来索引，以使得能通过这张表调动相应的函数。内核模块从用户空间收到的就是这些索引和参数，以此调用注册在此表中的函数。 在qdisc_create()中的opt→init调用sch_cbs.c的cbs_init()初始化函数。 12345678910111213141516171819static struct Qdisc *qdisc_create(struct net_device *dev, struct netdev_queue *dev_queue, struct Qdisc *p, u32 parent, u32 handle, struct nlattr **tca, int *errp, struct netlink_ext_ack *extack)&#123;// ...... rtnl_unlock(); request_module(&quot;sch_%s&quot;, name); rtnl_lock(); ops = qdisc_lookup_ops(kind);// ...... if (ops-&gt;init) &#123; err = ops-&gt;init(sch, tca[TCA_OPTIONS], extack); if (err != 0) goto err_out5; &#125;// ......&#125; sch_cbs.c gdb调试过程tc部分分析123/bin/tc qdisc replace dev eth1 parent 6666:2 handle 7777 cbs \\ idleslope 98688 sendslope -901312 hicredit 153 locredit -1389 \\ offload 1 设置断点。main()—&gt;do_cmd()—&gt;do_qdisc()—&gt;tc_qdisc_modify() tc_qdisc_modify() 首先解析参数eth1 …… cbs 找到cbs_qdisc_util 通过addttr_l()添加k到NETLINK包里。 执行cbs_qdisc_util→parse_qopt 通过cbs_parse_opt()解析参数idleslope …… offload 1 通过addattr_l()添加到NETLINK包里。 与内核通信。 此时内核运行完打印消息 rtnl_close()结束与内核的通信 内核部分 net&#x2F;sched&#x2F;sch_api.c断到tc_modify_qdisc()函数。 进入ops→init 解析到cbs_init()函数，初始化。 进入cbs_change() —&gt; csb_enable_offload() ops→ndo_setup_tc()开始进入驱动部分。 gmac网卡驱动部分调用stmmac_tc_setup_cbs() 在stmmac_config_cbs()中对寄存器进行读写配置。 对CBS相关的DMA寄存器进行读写操作。","categories":[{"name":"内核分析","slug":"内核分析","permalink":"https://azreallem.github.io/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://azreallem.github.io/tags/linux/"},{"name":"source code","slug":"source-code","permalink":"https://azreallem.github.io/tags/source-code/"},{"name":"iproute2","slug":"iproute2","permalink":"https://azreallem.github.io/tags/iproute2/"}]},{"title":"setup_arch()源码分析","slug":"setup-arch-源码分析","date":"2021-10-31T13:52:05.000Z","updated":"2022-03-29T18:51:11.000Z","comments":true,"path":"2021/10/31/setup-arch-源码分析/","link":"","permalink":"https://azreallem.github.io/2021/10/31/setup-arch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"setup_arch()start_kernel()中第一个重要的、体系结构密切相关的函数是 setup_arch()，定义在 arch/loongarch/kernel/setup.c中。 123456789101112131415161718192021222324252627void __init setup_arch(char **cmdline_p)&#123; cpu_probe(); early_init();#ifdef CONFIG_EARLY_PRINTK setup_early_printk();#endif bootcmdline_init(cmdline_p); init_initrd(); platform_init(); finalize_initrd(); cpu_report(); arch_mem_init(cmdline_p); resource_init();#ifdef CONFIG_SMP plat_smp_setup();#endif prefill_possible_map(); cpu_cache_init(); paging_init(); boot_cpu_trap_init();&#125; cpu_probe()用来探测 CPU 类型、ID号、版本等等。探测的主要依据是 PRID 寄存器，即协处理器 0 中的 15 号寄存器。PRID 是一个 32 位寄存器，最高 8 位保留，次高 8 位是公司 ID，第三个 8 位是处理器 ID，最后一个 8 位是修订号 ID。 early_init()123456void __init early_init(void)&#123; fw_init_cmdline(); fw_init_environ(); early_memblock_init();&#125; fw_init_cmdline()：还记得 kernel_entry 里面保存的 fw_arg0～fw_arg3 这几个变量吗？现在就要开始用了。prom_init_cmdline()中处理前两个变量，其中 fw_arg0 是参数的个数，fw_arg1 是参数的字符串数组。这个函数建立来自 BIOS 或 BootLoader 的内核命令行参数，以便给后面start_kernel()中的setup_command_line() 进 一 步 处 理 。 123456789101112131415void __init fw_init_cmdline(void)&#123; int i; fw_argc = fw_arg0; _fw_argv = (long *)fw_arg1; _fw_envp = (long *)fw_arg2; arcs_cmdline[0] = &#x27;\\0&#x27;; for (i = 1; i &lt; fw_argc; i++) &#123; strlcat(arcs_cmdline, fw_argv(i), COMMAND_LINE_SIZE); if (i &lt; (fw_argc - 1)) strlcat(arcs_cmdline, &quot; &quot;, COMMAND_LINE_SIZE); &#125;&#125; fw_init_environ()：用于初始化环境变量，环境变量来源于 fw_arg2。引入了类似于 UEFI 的 LEFI 接口，fw_arg2 仅仅提供一个地址，该地址指向 BIOS 中的一片数据区，数据区有着特定的结构，可以通过它获得丰富的接口信息。LEFI 接口规范所使用的各种数据结果定义在 arch/loongarch/include/asm/mach-loongson64/boot_param.h 中。 12345678910111213void __init fw_init_environ(void)&#123; efi_bp = (struct bootparamsinterface *)_fw_envp; loongson_sysconf.bpi_ver = get_bpi_version(&amp;efi_bp-&gt;signature); register_addrs_set(smp_group, TO_UNCAC(0x1fe01000), 16); register_addrs_set(loongson_chipcfg, TO_UNCAC(0x1fe00180), 16); register_addrs_set(loongson_chiptemp, TO_UNCAC(0x1fe0019c), 16); register_addrs_set(loongson_freqctrl, TO_UNCAC(0x1fe001d0), 16); if (list_find(efi_bp-&gt;extlist)) pr_warn(&quot;Scan bootparam failed\\n&quot;);&#125; 12345678910111213141516171819202122232425struct loongsonlist_mem_map &#123; /* 内存分布图 */ struct _extention_list_hdr header; /* &#123;&quot;M&quot;, &quot;E&quot;, &quot;M&quot;&#125; */ u8 map_count; struct loongson_mem_map &#123; u32 mem_type; u64 mem_start; u64 mem_size; &#125; __packed map[LOONGSON3_BOOT_MEM_MAP_MAX];&#125; __packed;struct loongson_system_configuration &#123; /* CPU信息 */ int bpi_ver; int nr_cpus; int nr_nodes; int nr_pch_pics; int boot_cpu_id; int cores_per_node; int cores_per_package; char *cpuname; u64 vgabios_addr;&#125;;extern struct loongsonlist_mem_map *loongson_mem_map;extern struct loongson_system_configuration loongson_sysconf;...... early_memblock_init()：对boot_param.h里定义声明的内存分布图进行初始化。 通常情况下我们使用的是支持 NUMA 的版本，它首先初始化 NUMA 节点的距离矩阵，然后逐个解析内存分布图并将最终结果保存于 loongson_memmap。 1234567891011121314151617181920212223void __init early_memblock_init(void)&#123; int i; u32 mem_type; u64 mem_start, mem_end, mem_size; /* parse memory information */ for (i = 0; i &lt; loongson_mem_map-&gt;map_count; i++) &#123; mem_type = loongson_mem_map-&gt;map[i].mem_type; mem_start = loongson_mem_map-&gt;map[i].mem_start; mem_size = loongson_mem_map-&gt;map[i].mem_size; mem_end = mem_start + mem_size; switch (mem_type) &#123; case ADDRESS_TYPE_SYSRAM: memblock_add(mem_start, mem_size); if (max_low_pfn &lt; (mem_end &gt;&gt; PAGE_SHIFT)) max_low_pfn = mem_end &gt;&gt; PAGE_SHIFT; break; &#125; &#125; memblock_set_current_limit(PFN_PHYS(max_low_pfn));&#125; Others bootcmdline_init(cmdline_p)：启动命令行的初始化； init_initrd()：初始化临时根文件系统，如果正常，则使用它们； Linux初始RAM磁盘（initrd）是在系统引导过程中挂载的一个临时根文件系统，用来支持两阶段的引导过程。 initrd文件中包含了各种可执行程序和驱动程序，它们可以用来挂载实际的根文件系统，然后再将这个 initrd RAM磁盘卸载，并释放内存。 platform_init()：控制台相关初始化 1234567891011121314151617181920212223242526272829void __init platform_init(void)&#123; /* init base address of io space */ set_io_port_base((unsigned long) ioremap(LOONGSON_LIO_BASE, LOONGSON_LIO_SIZE)); efi_init();#ifdef CONFIG_ACPI_TABLE_UPGRADE acpi_table_upgrade();#endif#ifdef CONFIG_ACPI acpi_gbl_use_default_register_widths = false; acpi_boot_table_init(); acpi_boot_init();#endif#ifndef CONFIG_NUMA fw_init_memory();#else fw_init_numa_memory();#endif dmi_setup(); smbios_parse(); pr_info(&quot;The BIOS Version: %s\\n&quot;, b_info.bios_version); efi_runtime_init(); register_smp_ops(&amp;loongson3_smp_ops);&#125; finalize_initrd():将 initrd&#x2F;initramfs 所在的内存段设置为保留。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static unsigned long __init init_initrd(void)&#123; /* * Board specific code or command line parser should have * already set up initrd_start and initrd_end. In these cases * perfom sanity checks and use them if all looks good. */ if (!initrd_start || initrd_end &lt;= initrd_start) goto disable; if (initrd_start &amp; ~PAGE_MASK) &#123; pr_err(&quot;initrd start must be page aligned\\n&quot;); goto disable; &#125; if (initrd_start &lt; PAGE_OFFSET) &#123; pr_err(&quot;initrd start &lt; PAGE_OFFSET\\n&quot;); goto disable; &#125; ROOT_DEV = Root_RAM0; return 0;disable: initrd_start = 0; initrd_end = 0; return 0;&#125;static void __init finalize_initrd(void)&#123; unsigned long size = initrd_end - initrd_start; if (size == 0) &#123; pr_info(&quot;Initrd not found or empty&quot;); goto disable; &#125; if (__pa(initrd_end) &gt; PFN_PHYS(max_low_pfn)) &#123; pr_err(&quot;Initrd extends beyond end of memory&quot;); goto disable; &#125; memblock_reserve(__pa(initrd_start), size); initrd_below_start_ok = 1; pr_info(&quot;Initial ramdisk at: 0x%lx (%lu bytes)\\n&quot;, initrd_start, size); return;disable: pr_cont(&quot; - disabling initrd\\n&quot;); initrd_start = 0; initrd_end = 0;&#125; cpu_report() arch_mem_init(char *cmdline_p)1234567891011121314151617181920212223242526272829303132333435363738394041/* * arch_mem_init - initialize memory management subsystem */static void __init arch_mem_init(char **cmdline_p)&#123; if (usermem) pr_info(&quot;User-defined physical RAM map overwrite\\n&quot;); check_kernel_sections_mem();#ifndef CONFIG_NUMA memblock_set_node(0, PHYS_ADDR_MAX, &amp;memblock.memory, 0);#endif /* * Prevent memblock from allocating high memory. * This cannot be done before max_low_pfn is detected, so up * to this point is possible to only reserve physical memory * with memblock_reserve; memblock_alloc* can be used * only after this point */ memblock_set_current_limit(PFN_PHYS(max_low_pfn)); /* * In order to reduce the possibility of kernel panic when failed to * get IO TLB memory under CONFIG_SWIOTLB, it is better to allocate * low memory as small as possible before plat_swiotlb_setup(), so * make sparse_init() using top-down allocation. */ memblock_set_bottom_up(false); sparse_init(); memblock_set_bottom_up(true);#ifdef CONFIG_64BIT plat_swiotlb_setup(); dma_contiguous_reserve(PFN_PHYS(max_low_pfn));#endif memblock_dump_all(); early_memtest(PFN_PHYS(ARCH_PFN_OFFSET), PFN_PHYS(max_low_pfn));&#125; sparse_init()：即稀疏内存模型初始化。内存模型指的是物理地址空间分布的模型，Linux 内核支持三种内存模型：平坦模型，非连续模型和稀疏模型。包括龙芯在内的现代体系结构大都采用了比较自由的稀疏模型。如果不采用稀疏模型，sparse_init()是空操作；如果采用稀疏模型，sparse_init()会初始化一些稀疏模型专有的数据结构（如全局区段描述符数组 mem_section[]及其附带的页描述符数组）。 plat_swiotlb_setup()：定义在 arch/loongarch/loongson64/dma.c 中。先我们简单介绍一下 SWIOTLB，这是一种 DMA API。龙芯 3 号的访存能力是 48 位，但是由于芯片组或者设备本身的限制，设备的访存能力往往没有这么大。比如龙芯的顶级 I&#x2F;O 总线（HT 总线）位宽只有 40 位，一部分 PCI 设备的访存能力只有 32 位，而 ISA&#x2F;LPC 设备的访问能力甚至只有 24 位。为了让任意设备能够对任意内存地址发起 DMA 访问，就必须在硬件上设置一个“DMA 地址-物理地址”翻译表，或者由内核在设备可访问的地址范围内预先准备一块内存做中转站。许多 X86 处理器在硬件上提供翻译表，称为 IOMMU；龙芯没有IOMMU，于是提供了软件中转站，也就是 SWIOTLB。plat_swiotlb_setup()调用 swiotlb_init()初始化 SWIOTLB 的元数据并在 32 位地址范围内分配中转缓冲区（缺省为 64MB），然后注册了一个 DMA API 操作集 loongson_linear_dma_map_ops。操作集里面的“物理地址-DMA地址”转换函数（即 loongson_linear_dma_map_ops 中的 phys_to_dma 和 dma_to_phys 两个函数指针）是同芯片组相关的： 12345678void __init plat_swiotlb_setup(void)&#123; swiotlb_init(1); node_id_offset = ((readl(LS7A_DMA_CFG) &amp; LS7A_DMA_NODE_MASK) &gt;&gt; LS7A_DMA_NODE_SHF) + 36; xlate_ops.phys_to_dma = loongson_phys_to_dma; xlate_ops.dma_to_phys = loongson_dma_to_phys;&#125; Others resource_init() plat_smp_setup() prefill_possible_map()：它会建立合理的逻辑 CPU 的 possible 值。prefill_possible_map()会通过 set_cpu_possible()来更新 cpu_possible_mask，最后将 possible 值赋给全局变量 nr_cpu_ids。 12345678910111213141516171819202122#ifdef CONFIG_SMPstatic void __init prefill_possible_map(void)&#123; int i, possible; possible = num_processors + disabled_cpus; if (possible &gt; nr_cpu_ids) possible = nr_cpu_ids; pr_info(&quot;SMP: Allowing %d CPUs, %d hotplug CPUs\\n&quot;, possible, max((possible - num_processors), 0)); for (i = 0; i &lt; possible; i++) set_cpu_possible(i, true); for (; i &lt; NR_CPUS; i++) set_cpu_possible(i, false); nr_cpu_ids = possible;&#125;#elsestatic inline void prefill_possible_map(void) &#123;&#125;#endif cpu_cache_init() 在龙芯处理器手册中，将 P-Cache 称之为一级 Cache，将 V-Cache 称之为二级 Cache，将 S-Cache 称之为三级 Cache。 12345678910void cpu_cache_init(void)&#123; probe_pcache();#ifdef CONFIG_64_BIT probe_vcache(); probe_scache();#endif shm_align_mask = PAGE_SIZE - 1;&#125; r4k_cache_init()通过调用 probe_pcache()、probe_vcache()和 setup_scache()完成各级 Cache的容量、行大小和相联度探测。然后给各个 Cache 刷新操作函数赋值（刷新即 Flush，对于指令 Cache 指的是作废，对于数据 Cache 指的是写回并作废）。 page_init()该函数初始化各个内存页面管理区（Zone）。页面管理区的类型包括 ZONE_DMA、ZONE_DMA32、ZONE_NORMAL 和 ZONE_HIGHME几种。ZONE_DMA 区包括所有物理地址为小于 16MB 的页面，设置这个区的目的是为ISA&#x2F;LPC 等 DMA 能力只有 24 位地址的设备服务。ZONE_DMA32 区包括所有 ZONE_DMA区之外的物理地址小于 4GB 的页面，设置这个区的目的是为 DMA 能力只有 32 位地址的 PCI设备服务。设置 ZONE_HIGHMEM 的目的是为物理地址超过线性地址表达能力的内存服务：对于 32 位的 MIPS 内核，线性地址表达能力只有 512M，因此 512M 以外的页面被放置到ZONE_HIGHMEM 区；对于 64 位的 MIPS 内核，物理地址暂时还没有超过线性地址的表达能力，因此通常不设置 ZONE_HIGHMEM 区。ZONE_NORMAL 区则包括了上述几个区以外的所有页面。在初始化每个 Zone 的时候，会调用 init_page_count()将每个页帧的初始引用计数设置为 1。因为此时此刻内存还处于 BootMem 管理器的控制下，这些页帧尚未转交到伙伴系统（内存页帧管理器），不是自由页帧（自由页帧的引用计数为 1），不可以被伙伴系统的页帧分配函数分配。 boot_cpu_trap_init()123456789101112131415161718192021222324void __init boot_cpu_trap_init(void)&#123; unsigned long size = (64 + 14) * vec_size; memblock_set_bottom_up(true); eentry = (unsigned long)memblock_alloc(size, 1 &lt;&lt; fls(size)); tlbrentry = (unsigned long)memblock_alloc(PAGE_SIZE, PAGE_SIZE); printk(&quot;eentry %lx, tlbrentry %lx\\n&quot;, eentry, tlbrentry); memblock_set_bottom_up(false); setup_vint_size(vec_size); configure_exception_vector(); if (!cpu_data[0].asid_cache) cpu_data[0].asid_cache = asid_first_version(0); mmgrab(&amp;init_mm); current-&gt;active_mm = &amp;init_mm; BUG_ON(current-&gt;mm); enter_lazy_tlb(&amp;init_mm, current); tlb_init(); TLBMISS_HANDLER_SETUP();&#125; vec_size：向量大小 eentry：通用例外入口地址 tlbrentry：tlb refill例外入口地址 configure_exception_vector()：配置例外向量 12345678910111213static void configure_exception_vector(void)&#123;#ifdef CONFIG_64BIT csr_writeq(eentry, LOONGARCH_CSR_EENTRY); csr_writeq(eentry, LOONGARCH_CSR_MERRENTRY); csr_writeq(tlbrentry, LOONGARCH_CSR_TLBRENTRY);#endif#ifdef CONFIG_32BIT csr_writel(eentry + 0x4000, LOONGARCH_CSR_EENTRY); csr_writel(tlbrentry, LOONGARCH_CSR_TLBRENTRY);#endif&#125; tlb_init()：主要做的事就是handle_tlb_refill 123456789101112131415161718192021222324252627void setup_tlb_handler(void)&#123; static int run_once = 0; setup_pw(); output_pgtable_bits_defines(); /* The tlb handlers are generated only once */ if (!run_once) &#123; memcpy((void *)tlbrentry, handle_tlb_refill, 0x80); local_flush_icache_range(tlbrentry, tlbrentry + 0x80); run_once++; &#125;&#125;void tlb_init(void)&#123; write_csr_pagesize(PS_DEFAULT_SIZE);#ifdef CONFIG_64BIT write_csr_stlbpgsize(PS_DEFAULT_SIZE);#endif if (read_csr_pagesize() != PS_DEFAULT_SIZE) panic(&quot;MMU doesn&#x27;t support PAGE_SIZE=0x%lx&quot;, PAGE_SIZE); setup_tlb_handler(); local_flush_tlb_all();&#125; handle_tlb_refill 12345678910111213141516171819202122232425262728293031323334353637SYM_FUNC_START(handle_tlb_refill) csrwr t0, LOONGARCH_CSR_KS0 csrwr t1, LOONGARCH_CSR_KS1 csrwr ra, EXCEPTION_KS2 csrrd t0, LOONGARCH_CSR_PGD csrrd t1, LOONGARCH_CSR_BADV srli.w t1, t1, 0x16 slli.w t1, t1, 0x2 add.w t0, t0, t1 ld.w t0, t0, 0 csrrd t1, LOONGARCH_CSR_BADV srli.w t1, t1, 0xa andi t1, t1, 0xff8 add.w t0, t0, t1 ld.w t1, t0, 0 srli.w ra, t1, 0xc slli.w ra, ra, 0x8 andi t1, t1, 0xff add.w t1, t1, ra csrwr t1, LOONGARCH_CSR_TLBELO0 ld.w t1, t0, 0x4 srli.w ra, t1, 0xc slli.w ra, ra, 0x8 andi t1, t1, 0xff add.w t1, t1, ra csrwr t1, LOONGARCH_CSR_TLBELO1 tlbfill csrrd t0, LOONGARCH_CSR_KS0 csrrd t1, LOONGARCH_CSR_KS1 csrrd ra, EXCEPTION_KS2 ertnSYM_FUNC_END(handle_tlb_refill) TLBMISS_HANDLER_SETUP()：主要工作是建立内核页全局目录的基地址。 trap_init()其余的例外在start_kernel()中的trap_init()中。 trap_init() 1234567891011121314151617181920212223242526272829303132333435363738394041void __init trap_init(void)&#123; long i; void *vec_start; /* Initialise exception handlers */ for (i = 0; i &lt; 64; i++) set_handler(i * vec_size, handle_reserved, vec_size); /* Set interrupt vector handler */ for (i = EXCCODE_INT_START; i &lt; EXCCODE_INT_END; i++) &#123; vec_start = vi_table[i - EXCCODE_INT_START]; set_handler(i * vec_size, vec_start, vec_size); &#125;#ifdef CONFIG_32BIT set_handler(EXCCODE_GENERIC * vec_size , except_vec_vi_handler, vec_size);#endif set_handler(EXCCODE_TLBL * vec_size, handle_tlb_load, vec_size); set_handler(EXCCODE_TLBS * vec_size, handle_tlb_store, vec_size); set_handler(EXCCODE_TLBI * vec_size, handle_tlb_load, vec_size); set_handler(EXCCODE_TLBM * vec_size, handle_tlb_modify, vec_size); set_handler(EXCCODE_TLBRI * vec_size, handle_tlb_rixi, vec_size); set_handler(EXCCODE_TLBXI * vec_size, handle_tlb_rixi, vec_size); set_handler(EXCCODE_ADE * vec_size, handle_ade, vec_size); set_handler(EXCCODE_ALE * vec_size, handle_ale, vec_size); set_handler(EXCCODE_SYS * vec_size, handle_syscall, vec_size); set_handler(EXCCODE_BP * vec_size, handle_bp, vec_size); set_handler(EXCCODE_INE * vec_size, handle_ri, vec_size); set_handler(EXCCODE_IPE * vec_size, handle_ri, vec_size); set_handler(EXCCODE_FPDIS * vec_size, handle_fpu, vec_size); set_handler(EXCCODE_LSXDIS * vec_size, handle_lsx, vec_size); set_handler(EXCCODE_LASXDIS * vec_size, handle_lasx, vec_size); set_handler(EXCCODE_FPE * vec_size, handle_fpe, vec_size); set_handler(EXCCODE_BTDIS * vec_size, handle_lbt, vec_size); set_handler(EXCCODE_WATCH * vec_size, handle_watch, vec_size); cache_error_setup(); local_flush_icache_range(eentry, eentry + 0x400);&#125; except_vec_vi_handler：32位LOONGARCH 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849SYM_FUNC_START(except_vec_vi_handler) csrwr t0, LOONGARCH_CSR_KS0 csrwr t1, LOONGARCH_CSR_KS1 csrrd t0, LOONGARCH_CSR_ESTAT srli.w t1, t0, 0x10 /* get Ecode */ andi t1, t1, 0x3f beq t1, zero, 1f /* if irq */ csrrd t0, LOONGARCH_CSR_EENTRY slli.w t1, t1, 0x9 /* get ex entry shift = Ecode * vec_size */ add.w t0, t0, t1 lu12i.w t1, 0x4 sub.w t0, t0, t1 jirl zero,t0 , 0 /* go to exception_handler */1: SAVE_ALL docfi=0 CLI TRACE_IRQS_OFF ld.w s0, tp, TI_REGS st.w sp, tp, TI_REGS move s1, sp csrrd t0, LOONGARCH_CSR_TMID la.abs t1, irq_stack slli.w t0, t0, LONGLOG ld.w t0, t1, 0 li t1, ~(_THREAD_SIZE-1) and t1, t1, sp beq t0, t1, 2f li t1, _IRQ_STACK_START add.w sp, t0, t1 st.w s1,sp, 02: la.abs t0, plat_irq_dispatch jirl ra, t0, 0 move sp, s1 la.abs t0, ret_from_irq jirl zero, t0, 0SYM_FUNC_END(except_vec_vi_handler) 中断请求相关start_kernel()中的init_IRQ() 123456789101112131415161718void __init init_IRQ(void)&#123; int i; unsigned int order = get_order(IRQ_STACK_SIZE); for (i = 0; i &lt; NR_IRQS; i++) irq_set_noprobe(i); arch_init_irq(); for_each_possible_cpu(i) &#123; void *s = (void *)__get_free_pages(GFP_KERNEL, order); per_cpu(irq_stack, i) = (unsigned long)s; pr_debug(&quot;CPU%d IRQ stack at 0x%lx - 0x%lx\\n&quot;, i, per_cpu(irq_stack, i), per_cpu(irq_stack, i) + IRQ_STACK_SIZE); &#125;&#125; 调用arch_init_irq() 123456789101112void __init arch_init_irq(void)&#123; clear_csr_ecfg(ECFG0_IM); clear_csr_estat(ESTATF_IP); setup_IRQ();#ifdef CONFIG_SMP set_vi_handler(EXCCODE_IPI, loongson3_ipi_interrupt);#endif set_csr_ecfg(ECFGF_IP0 | ECFGF_IP1 | ECFGF_IPI | ECFGF_PC);&#125; setup_IRQ()：这一步的主要工作就是初始化通过 Device-Tree描述的中断控制器（即“IRQ 芯片”，数据结构用 irq_chip 描述）。 1234void __init setup_IRQ(void)&#123; irqchip_init();&#125;","categories":[{"name":"内核分析","slug":"内核分析","permalink":"https://azreallem.github.io/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://azreallem.github.io/tags/linux/"},{"name":"source code","slug":"source-code","permalink":"https://azreallem.github.io/tags/source-code/"},{"name":"setup_arch","slug":"setup-arch","permalink":"https://azreallem.github.io/tags/setup-arch/"}]},{"title":"内核启动过程分析","slug":"内核启动过程分析","date":"2021-10-30T10:37:14.000Z","updated":"2022-03-29T18:46:42.000Z","comments":true,"path":"2021/10/30/内核启动过程分析/","link":"","permalink":"https://azreallem.github.io/2021/10/30/%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/","excerpt":"","text":"kernel_entry→start_kernel()vmlinux原始内核启动：内核的初始启动入口是位于arch&#x2F;loongarch&#x2F;kernel&#x2F;head.S中的kernel_entry → start_kernel() vmlinuxz压缩版内核启动：在解压前真正的执行入口是arch&#x2F;loongarch&#x2F;boot&#x2F;compressed&#x2F;head.S中的start →kernel_entry→start_kernel() 执行decompress_kernel()进行自解压，解压内容释放到内存里面形成一个原始内核。 第一入口：kernel_entry123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SYM_CODE_START(kernel_entry) # kernel entry point /* We might not get launched at the address the kernel is linked to, so we jump there. */ la.abs t0, 0f jirl zero, t0, 00: la t0, __bss_start # clear .bss PTR_S zero, t0, 0 la t1, __bss_stop - LONGSIZE1: PTR_ADDIU t0, t0, LONGSIZE PTR_S zero, t0, 0 bne t0, t1, 1b la t0, fw_arg0 PTR_S a0, t0, 0 # firmware arguments la t0, fw_arg1 PTR_S a1, t0, 0 la t0, fw_arg2 PTR_S a2, t0, 0 la t0, fw_arg3 PTR_S a3, t0, 0 /* Config direct window and set PG */ PTR_LI t0, 0xa0000011 csrwr t0, LOONGARCH_CSR_DMWIN0 PTR_LI t0, 0x80000001 csrwr t0, LOONGARCH_CSR_DMWIN1 /* Enable PG */ li.w t0, 0xb0 # PLV=0, IE=0, PG=1 csrwr t0, LOONGARCH_CSR_CRMD /* KScratch3 used for percpu base, initialized as 0 */ csrwr zero, PERCPU_BASE_KS /* GPR21 used for percpu base (runtime), initialized as 0 */ or x0, zero, zero la tp, init_thread_union /* Set the SP after an empty pt_regs. */ PTR_LI sp, (_THREAD_SIZE - 32 - PT_SIZE) PTR_ADDU sp, sp, tp set_saved_sp sp, t0, t1 PTR_ADDIU sp, sp, -4 * SZREG # init stack pointer b start_kernelSYM_CODE_END(kernel_entry) 通过一个循环来清零.bss 段中的全局数据； 将 a0～a3 寄存器中的值保存到 fw_arg0～fw_arg3四个内存变量，这四个变量包含 BIOS 或者引导程序传递给内核的参数； 配置DMWIN0和DMWIN1映射窗口地址； 打开PG&#x3D;1； 进行CPU类型相关的初始化； 使用init_thread_union的地址来初始化GP寄存器，GP是全局指针； 初始化SP寄存器，SP是堆栈指针； 最后的 b start_kernel 是跳转到第二入口处继续执行，第二入口即 start_kernel()函数； 处理器0的Status寄存器 IE：全局中断使能位，为 1 表示开中断，为 0 表示关中断； EXL：异常级别指示，为 1 表示 CPU 处于异常模式，异常模式表示发生了除复位、NMI和 Cache 错误以外的某种异常。 ERL：错误级别指示，为 1 表示 CPU 处于错误模式，错误模式表示发生了复位、NMI或者 Cache 错误之类的某种异常。 KSU：特权模式位：为 0 表示 CPU 处于核心态（内核态），为 1 表示 CPU 处于管理态，为 2 表示 CPU 处于用户态，为 3 表示未定义。核心态权限最高，可以执行任意指令（特权指令和非特权令），可以访问任意地址空间（核心空间、管理空间和用户空间）；管理态权限居中，不能执行特权指令，能访问管理地址空间和用户地址空间；用户态权限最低，不能执行特权指令，只能访问用户地址空间。另外，当 EXL 或者 ERL 置位时，不管 KSU 如何取值，CPU 自动处于核心态。 UX：为 1 表示启用 64 位用户地址空间段； SX：为 1 表示启用 64 位管理地址空间段； KX：为 1 表示启用 64 位核心地址空间段； IM7~IM0：中断掩码位，MIPS 在 CPU 层面一共有 8 个中断源，分别有 8 个掩码位与之对应，为 1 的位表示允许该中断触发，为 0 的位表示禁止该中断触发； NMI：为 1 表示发生了 NMI（不可屏蔽中断）； SR：为 1 表示发生了软件复位；BEV：控制异常向量的入口，为 1 表示使用启动时异常向量入口，为 0 表示使用运行时异常向量入口； PX：为 1 表示在用户态使能 64 位操作数指令（如 daddu、dsubu 等）； FR：浮点协处理器模式切换，为 1 表示有 32 个双精度浮点寄存器可用，为 0 表示只有16 个双精度浮点寄存器可用； CU3~CU0：标识四个协处理器是否可用，协处理器 0（CP0）是系统控制协处理器，在所有 MIPS 处理器上总是可用的；协处理器 1（CP1）通常是浮点协处理器（FPU），在所有龙芯处理器上总是可用的；协处理器 2（CP2）在龙芯 3 号上总是可用的，表示多媒体指令协处理器。 龙芯 3 号总是使用 64 位内核，所以 setup_c0_status_pri 实际上就是设置当前模式为内核态模（KSU），启用内核的 64 位地址段访问能力（KX），启用系统控制协处理器（CU0），启用多媒体指令协处理器（CU2），清除异常状态并禁止中断（清零 EXL、ERL、IE）。BEV等位保持 BIOS 设置的原值（内核尚未建立运行时异常向量）。 init_thread_union相关在 Linux 中，进程和线程都是运行的程序实体，进程有独立的地址空间，若干个线程共享同一个地址空间；也就是说，线程是一种特殊的进程。Linux 中线程的容器并不是进程，而是线程组。例如：一个运行中的多线程程序是一个线程组，里面包含多个线程；一个运行中的单线程程序也是一个线程组，里面包含一个线程。单线程程序的那个唯一线程，就是一般意义上的进程。内核本身也可以视为一个特殊的进程，它可以派生出很多共享地址空间的内核线程，因此这个拥有许多线程的内核又可以视为一个特殊的线程组。 线程相关的数据结构： 123456789101112union thread_union &#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(long)];&#125;; struct task_struct init_task = INIT_TASK(init_task);union thread_union init_thread_union = &#123; INIT_THREAD_INFO(init_task) &#125;;#define init_thread_info (init_thread_union.thread_info)#define init_stack (init_thread_union.stack)unsigned long kernelsp[NR_CPUS]; 每一个进程（包括普通进程和内核线程）用一个进程描述符 task_struct 表示；每一个进程都有一个体系结构相关的线程信息描述符，即 thread_info；每一个进程都有一个内核态栈，用于处理异常、中断或者系统调用。Linux 内核为每个进程分配一个大小为 THREAD_SIZE的内存区（大小通常就是一个页面），把 thread_info 和内核栈放在一起，即 thread_union。 thread_union 地址从低处开始往上是 thread_info，从高处开始往下是内核栈，task_struct 中的stack 指针指向 thread_union。这里的 init_task 就是 Linux 中 0 号进程的 task_struct，0 号进程一开始就是内核自身，在完成启动初始化以后，变身为 Idle 进程（空闲进程）。 第二入口：start_kernel()init&#x2F;main.c 1234asmlinkage __visible void __init __no_sanitize_address start_kernel(void)&#123; ......&#125; 虽然这棵树很庞大，但我们大致可以将整个 start_kernel()的过程分为三个大的阶段：关中断单线程阶段（从 start_kernel()头部开始直到 local_irq_enable()结束）；开中断单线程阶段（从local_irq_enable()开始直到 rest_init()前夕）；开中断多线程阶段（rest_init()的整个过程）。 第一阶段：关中断单线程阶段启动初期的初始化过程必须关中断进行（中断处理的基础设施尚未准备好），所以start_kernel()开始执行不久之后就通过 local_irq_disable()来关闭中断。 boot_cpu_init()，这个函数是设置启动 CPU（通常是 0 号 CPU）的存在性状态。 1234567891011121314void __init boot_cpu_init(void)&#123; int cpu = smp_processor_id(); /* Mark the boot cpu &quot;present&quot;, &quot;online&quot; etc for SMP and UP case */ set_cpu_online(cpu, true); set_cpu_active(cpu, true); set_cpu_present(cpu, true); set_cpu_possible(cpu, true); #ifdef CONFIG_SMP __boot_cpu_id = cpu;#endif &#125; 一个逻辑 CPU 有四种存在性状态：possible，表示物理上有可能存在；present，表示物理上确实存在；online，表示已经在线；active，表示已经在线并且处于活动状态。possible 和 present 的区别跟 CPU 物理热插拔有关，如果物理上移除一个 CPU，present 数目就会减少一个。present 和online 的区别是CPU 逻辑热插拔，在不改变硬件的情况下，可以对 &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpuN&#x2F;online 写 0来关闭一个 CPU，写 1 则重新打开。online 和 active 非常相似，前者表示这个 CPU 可以调度任务了，后者表示可以往这个 CPU 迁移任务了。两者的区别在于，在通过逻辑热插拔关闭一个 CPU 的过程中，被关闭的 CPU 首先必须退出 active 状态，然后才能退出 online 状态。 整个 boot_cpu_init()的功能，就是将启动核（在龙芯上面就是 0 号核）的状态设置成 possible 的，present 的，online 的并且是 active 的。 然后是一个重要函数 setup_arch()，这是根据体系结构进行相关的初始化，LOONGARCH的setup_arch()定义在 arch&#x2F;loongarch&#x2F;kernel&#x2F;setup.c 中。 接下来的 trap_init()异常初始化，这个函数都是体系结构相关的并且非常重要。 123456789101112131415161718192021222324252627void __init setup_arch(char **cmdline_p)&#123; cpu_probe(); early_init();#ifdef CONFIG_EARLY_PRINTK setup_early_printk();#endif bootcmdline_init(cmdline_p); init_initrd(); platform_init(); finalize_initrd(); cpu_report(); arch_mem_init(cmdline_p); resource_init();#ifdef CONFIG_SMP plat_smp_setup();#endif prefill_possible_map(); cpu_cache_init(); paging_init(); boot_cpu_trap_init();&#125; setup_command_line()，建立内核命令行参数。内核命令行参数可以写在启动配置文件（boot.cfg 或 grub.cfg）中，由 BIOS 或者启动器（BootLoader，如 Grub）传递给内核；或缺省参数。 setup_nr_cpu_ids()，它获取 cpu_possible_mask 中的最大 CPU 编号（所有 possible 状态的逻辑 CPU 的最大编号），并将其赋值给全局变量 nr_cpu_ids。 setup_per_cpu_areas()，建立每 CPU 变量区，每 CPU 变量用 DEFINE_PER_CPU(type, name)语句定义，在功能上等价于用 type name[NR_CPUS]定义一个数组。 smp_prepare_boot_cpu()是一个体系结构相关的函数，在 LOONGARCH 上主要是把 0 号逻辑 CPU设成 possible 的和 online 的，该函数在功能上和 boot_cpu_init()有所重复。 接下来的 trap_init()异常初始化，这个函数都是体系结构相关的并且非常重要。 随后的 mm_init()是内存管理初始化。体系结构相关的内存管理部分已经在 setup_arch()里面完成（其中会将 BIOS 传递的固件内存分布图转换成 BootMem 内存分布图），这里主要是调用mem_init()建立内存分布图（将 BootMem 内存分布图转换为伙伴系统的内存分布图，对其中的每个可用的页帧调用set_page_count()将其引用计数设为0），调用kmem_cache_init()完成 SLAB 内存对象管理器的初始化，以及调用 vmalloc_init()完成非连续内存区管理器的初始化。 sched_init()，调度器初始化，完成以后主核就可以进行任务调度了。sched_init()会通过for_each_possible_cpu()迭代器在初始化每个 CPU 的运行队列（运行队列 rq 用于进程组织和调度），其中包括将 CPU 负载水平（即 rq-&gt;cpu_load[]数组，记录了最近 5 个时钟节拍内的CPU 平均负载水平）初值设为 0。接下来，sched_init()里面还有几个比较重要的步骤就是对init_task 的操作：init_task 的大部分成员字段已经通过 INIT_TASK()在定义的时候就初始化好了，这里只需调用 set_load_weight()设置 init_task 的负荷权重（负荷权重跟基于优先级的进程调度有关，详见第 6 章），将其调度类设为 fair_sched_class（公平调度类，使用 CFS 调度策略对其进行调度），再调用 init_idle()将内核自己进程化（准备工作完成后，调度类会被重新设置为 idle_sched_class，使用专门的 IDLE 调度策略）。从现在开始内核也是一个“进程”了，即零号进程。 123456/* * Set up the scheduler prior starting any interrupts (such as the * timer interrupt). Full topology setup happens at smp_init() * time - but meanwhile we still have a functioning scheduler. */sched_init(); rcu_init()，RCU 是一种内核同步原语，全称 Read-Copy-Update（读-复制-更新），和自旋锁、信号量、读写锁等同步原语有类似的 API，但 RCU 本身并不是锁。 early_irq_init()，初始化中断描述符。中断描述符就是 irq_desc[NR_IRQS]数组，包含了每个中断号（IRQ）的芯片数据 irq_data 和中断处理程序 irqaction 等各种信息。本函数只是设置缺省信息，比如芯片数据都设成 no_irq_chip ，中断处理程序都设成handle_bad_irq()。真正有意义的信息由后面体系结构相关的 init_IRQ()函数完成。 init_timers()，基本定时器初始化；hrtimers_init()，高分辨率定时器初始化。 softirq_init()，软中断初始化。软中断和硬中断的概念来自于早期内核中的“上半部”和“下半部”。上半部是中断处理里面非常紧急、必须立即完成的那部分工作；下半部是不那么紧急，可以延迟完成的那部分工作。软中断在概念上基本上就是继承自下半部。当前内核中定义了 11 种软中断（优先级从高到低）： 123456789101112131415enum&#123; HI_SOFTIRQ=0, TIMER_SOFTIRQ, NET_TX_SOFTIRQ, NET_RX_SOFTIRQ, BLOCK_SOFTIRQ, IRQ_POLL_SOFTIRQ, TASKLET_SOFTIRQ, SCHED_SOFTIRQ, HRTIMER_SOFTIRQ, RCU_SOFTIRQ, /* Preferable RCU should always be the last softirq */ NR_SOFTIRQS&#125;; SCHED_SOFTIRQ 在之前的 sched_init()里面进行初始化，RCU_SOFTIRQ 在之前的rcu_init()里面进行初始化，TIMER_SOFTIRQ 和 HRTIMER_SOFTIRQ 在之前的 init_timers(和 hrtimers_init()中进行初始化，本函数主要完成 HI_SOFTIRQ 和 TASKLET_SOFTIRQ 的初始化，其他类型的软中断分布在各自的子系统里面完成。 timekeeping_init()，timekeeping 的意思是系统时间维护。该函数的作用主要是初始化各种时间相关的变量，如 jiffies，xtime 等等。Jiffies 记录了系统启动以来所经历的节拍数，而xtime 记录的时间可以精确到纳秒。随后的 time_init()是一个体系结构相关的函数，会进一步初始化计时系统。 PerfEvents 和 OProfile 是 Linux 内核中的两种性能剖析工具，perf_event_init()和profileinit()分别完成其初始化。 中断有关的初始化都已经完成，现在可以开中断了。开中断的函数是 local_irq_enable()，对于 LOONGARCH 来讲就是设置协处理器 0 中 Status 寄存器的 IE 位。 第二阶段：开中断单线程阶段第二阶段中断已经打开，所以虽然现在内核还是以单线程的方式执行，但是一旦产生断就会切换控制流。因此，这一阶段除了按顺序执行代码流程以外，还可能以交错方式执行中断处理的代码。 console_init()，控制台初始化。 numa_policy_init()，NUMA 内存分配策略初始化。 calibrate_delay()，用于计算 loops_per_jiffy 的值。loops_per_jiffy 的含义是每个时钟节拍对应的空循环数，这个值用于以后实现各种 delay()类的忙等函数。 fork_init()，Linux 用 fork()系统调用来创建新进程。本函数的作用是初始化 fork()所用到的一些数据结构，如创建名为”task_struct”的 SLAB 内存对象缓存，将最大线程数设置为MAXTHREADS，等等。 signals_init()，跟信号相关的数据结构初始化。信号之于进程，好比中断之于内核，用于打断当前的执行流程，去完成一些更重要的工作。 cgroup_init()，CGroup 全称 Contol Group，即控制组，是内核一种控制资源分配的机制。本函数完成控制组相关数据结构的初始化，并且创建相应的 sysfs 和 procfs 节点。 现在，所有调度有关的子系统已经全部初始化完成，接下来可以创建新的内核线程，以并发的方式继续内核启动了。因为显卡尚未初始化，所以第二阶段显示器上依然没有输出信息。 第三阶段：开中断多线程阶段rest_init()，顾名思义，第三阶段就是余下的初始化工作任务。函数 rest_init()的主要工作是通过 kernel_thread()创建了 1 号进程 kernel_init 和 2 号进程 kthreadd（实际上是两个内核线程）。1 号进程的执行体函数是 kernel_init()，它完成接下来的大部分初始化工作。2 号进程则是除 0、1、2 号进程以外其他所有内核线程的祖先（如果 1号进程在运行过程中需要创建新的内核线程，会委托 2 号进程来创建）。 1 号进程和 2 号进程创建以后，内核自己的初始化工作就基本完成了。但是别忘了，内核自己是 0 号进程，因此它也有必须持续进行的“工作”。内核初始化的最后一步是执行 cpu_startup_entry()，而后者的主要工作是调用cpu_idle_loop()。从名字可以看出，0 号进程现在成了空闲进程（即 IDLE 进程），它的工作就是“休息”（如果别的进程有事要做，就调度别的进程，反之意味着系统空闲，回到零号进程）。顺着调用链追踪下去，可以发现 0 号进程的核心过程是循环执行 arch_cpu_idle()，而具体到 LOONGARCH 处理器，则是 cpu_wait()。cpu_wait()可以有多种实现，一般就是执行 WAIT指令进入节能状态。 1 号进程与 2 号进程会派生很多新的内核线程来完成各种内核功能。在 SMP 系统上，1号进程会打开所有辅核，让后面的内核启动真正并行起来。包括显卡驱动在内的各种设备驱动都在 1 号进程里面完成，因此第三阶段除了起始点以外的的大部分时间是有显示信息输出的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748noinline void __ref rest_init(void)&#123; struct task_struct *tsk; int pid; rcu_scheduler_starting(); /* * We need to spawn init first so that it obtains pid 1, however * the init task will end up wanting to create kthreads, which, if * we schedule it before we create kthreadd, will OOPS. */ pid = kernel_thread(kernel_init, NULL, CLONE_FS); /* * Pin init on the boot CPU. Task migration is not properly working * until sched_init_smp() has been run. It will set the allowed * CPUs for init to the non isolated CPUs. */ rcu_read_lock(); tsk = find_task_by_pid_ns(pid, &amp;init_pid_ns); tsk-&gt;flags |= PF_NO_SETAFFINITY; set_cpus_allowed_ptr(tsk, cpumask_of(smp_processor_id())); rcu_read_unlock(); numa_default_policy(); pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); rcu_read_lock(); kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns); rcu_read_unlock(); /* * Enable might_sleep() and smp_processor_id() checks. * They cannot be enabled earlier because with CONFIG_PREEMPTION=y * kernel_thread() would trigger might_sleep() splats. With * CONFIG_PREEMPT_VOLUNTARY=y the init task might have scheduled * already, but it&#x27;s stuck on the kthreadd_done completion. */ system_state = SYSTEM_SCHEDULING; complete(&amp;kthreadd_done); /* * The boot idle thread must execute schedule() * at least once to get things moving: */ schedule_preempt_disabled(); /* Call into cpu_idle with preempt disabled */ cpu_startup_entry(CPUHP_ONLINE);&#125;","categories":[{"name":"内核分析","slug":"内核分析","permalink":"https://azreallem.github.io/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://azreallem.github.io/tags/linux/"},{"name":"source code","slug":"source-code","permalink":"https://azreallem.github.io/tags/source-code/"},{"name":"start_kernel","slug":"start-kernel","permalink":"https://azreallem.github.io/tags/start-kernel/"}]},{"title":"状态机","slug":"状态机","date":"2021-10-26T04:12:13.000Z","updated":"2022-04-14T01:10:44.000Z","comments":true,"path":"2021/10/26/状态机/","link":"","permalink":"https://azreallem.github.io/2021/10/26/%E7%8A%B6%E6%80%81%E6%9C%BA/","excerpt":"","text":"什么是状态机？状态机的全称是有限状态自动机，是现实事物运行规则抽象而成的一个数学模型。给定一个状态机，同时给定它的当前状态以及输入，那么输出状态时可以明确的运算出来的。 状态机四大概念下面来给出状态机的四大概念。 第一个是 State ，状态。一个状态机至少要包含两个状态。例如上面自动门的例子，有 open 和 closed 两个状态。 第二个是 Event ，事件。事件就是执行某个操作的触发条件或者口令。对于自动门，“按下开门按钮”就是一个事件。 第三个是 Action ，动作。事件发生以后要执行动作。例如事件是“按开门按钮”，动作是“开门”。编程的时候，一个 Action 一般就对应一个函数。 第四个是 Transition ，变换。也就是从一个状态变化为另一个状态。例如“开门过程”就是一个变换。 应用最后再来说说状态机的应用。状态机是一个对真实世界的抽象，而且是逻辑严谨的数学抽象，所以明显非常适合用在数字领域。可以应用到各个层面上，例如硬件设计，编译器设计，以及编程实现各种具体业务逻辑的时候。 来举个例子。街上的自动售货机中明显能看到状态机逻辑。我们做一下简化，假设这是一台只卖2元一瓶的汽水的售货机，只接受五毛和一块的硬币。初始状态是”未付款“，中间状态有”已付款5毛“，”已付款1块“，”已付款1.5块“，”已足额付款“，四个状态。状态切换的触发条件是”投一块硬币“和”投5毛硬币“两种，”到达足额付款“状态，还要进行余额清零和弹出汽水操作。所以如果画出一张完整的状态转换图，也会是比较复杂的一张图了。而实际中的售货机对应的状态机就会更加复杂了。 总之，状态机应用范围很广，这里就不展开了。插一句，跟状态机类似的概念还有图灵机，图灵机就是计算机底层采用的计算模型。 总结这就是对状态机概念的一个通俗的简述了。总结一下，状态机不是实际机器设备，而是一个数学模型，通常体现为一个状态转换图。涉及到的相关概念是 State 状态，Event 事件，Action 动作，Transition 转换。状态机是计算机科学的重要基础概念之一，也可以说是一种总结归纳问题的思想，应用范围非常广泛。","categories":[{"name":"随手笔记","slug":"随手笔记","permalink":"https://azreallem.github.io/categories/%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"FSM","slug":"FSM","permalink":"https://azreallem.github.io/tags/FSM/"}]},{"title":"tlb异常处理","slug":"tlb异常处理","date":"2021-10-21T11:09:17.000Z","updated":"2022-03-29T15:17:28.000Z","comments":true,"path":"2021/10/21/tlb异常处理/","link":"","permalink":"https://azreallem.github.io/2021/10/21/tlb%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"tlb异常相关的简要概述该内核源码为linux5.14中的32位loongarch架构下tlb异常相关部分。下面为相关部分的关键源代码和函数。 mm&#x2F;tlbex-32.S handle_tlb_load handle_tlb_store handle_tlb_modify heandle_tlb_refill kernel&#x2F;traps.c ebase eentry+0x4000 LOONGARCH_CSR_EENTRY 例外入口地址 0x200 * 32 &#x3D; 0x4000 tlbrentr vec_size &#x3D; 0x200 12345678910do_raise_exception_err: 14 0mips_cpu_do_interrupt enter: PC 0018c16c EPC 0018c024 RFEPC 0x000000000018c024 TLB refill exceptionmips_cpu_do_interrupt: PC a0201000 EPC 0x0018c16c cause 63(refill) EXST 003f0000 EXCFG 0x00071c1c BADVA 0x002134d4 ENV_PGDL 0xa23e1000 BADI 0x00000000 SYS_NUM 2381672 cpu 0 asid 0x1exception_return: EPC 0x18c16cdo_raise_exception_err: 29 0mips_cpu_do_interrupt enter: PC 0018c16c EPC 0018c16c RFEPC 0x000000000018c16c TLB load exceptionmips_cpu_do_interrupt: PC a0214000 EPC 0x0018c16c cause 1 EXST 00010000 EXCFG 0x00071c1c BADVA 0x002134d4 ENV_PGDL 0xa23e1000 BADI 0x00000000 SYS_NUM 2381672 cpu 0 asid 0x1do_raise_exception_err: 65538 0 tlb_load *(0xa0210000 + 0x200) gdb调试: 12b *0xa0210200x /32i 0xa0210200 trap_init 1234567void __init trap_init(void)&#123; set_handler(EXCCODE_GENERIC * vec_size , except_vec_vi_handler, vec_size); ... set_handler(EXCCODE_TLBL * vec_size, handle_tlb_load, vec_size); ...&#125; kerne&#x2F;geneX.S except_vec_vi_handler loongarch32&#x2F;irq.c plat_irq_dispatch 中断 0x800 时钟中断 arch&#x2F;loongarch&#x2F;mm&#x2F;tlb.c __update_tlb arch&#x2F;loongarch&#x2F;mm&#x2F;fault.c do_page_fault mm&#x2F;tlbex-32.S中handle_tlb_load函数1234567891011121314151617181920212223242526SYM_FUNC_START(handle_tlb_load) /* 保存现场 */ csrwr ra, EXCEPTION_KS2 lu12i.w ra, 0xc slli.w ra, ra, 0x10 csrrd t0, LOONGARCH_CSR_BADV bgeu t0, ra, vmalloc_load csrrd t1, LOONGARCH_CSR_PGDvmalloc_done_load: /* Get PGD offset in bytes */ srli.w t0, t0, 0x16 andi t0, t0, 0x3ff slli.w t0, t0, 0x2 /* 页内偏移为12位，故t0为PGD OFFSET(也为12bit) */ add.w t1, t1, t0 /* PGD基址 + PGD_OFFSET = 该PTE基址 */ ld.w t1, t1, 0 /* 从t1内存中取出数据(页目录号)放到t1中 */ csrrd t0, LOONGARCH_CSR_BADV srli.w t0, t0, 0xc andi t0, t0, 0x3ff /* 获取虚拟地址中间的PTE10位 */ slli.w t0, t0, 0x2 /* 获得PTE_OFFSET */ add.w t0, t0, t1 /* 该PTE基址 + PTE_OFFSET = 包含物理页号的物理地址*/ ld.w t1, t0, 0 /* 由物理页号的物理地址取出Page table bits */ tlbsrch /* 使用ASID和TLBEHI查询TLB */ 1234567891011121314151617181920212223242526272829/* 判断Page table bits的_PAGE_PRESENT是否为0 */ andi ra, t1, _PAGE_PRESENT beq ra, zero, nopage_tlb_load ori t1, t1, _PAGE_VALID /* 将PTEE中_PAGE_VALID置1 */ st.w t1, t0, 0 /* 更新page table bits */ /* tlb一次取两页，t0的第3位为0时，0表示偶数物理页，1表示基数物理页 */ ori t0, t0, 0x4 xori t0, t0, 0x4/* 只要PTEE的7:0位(flag位)和31:11位(PPN)，* 并且将31:11位(PPN)移到31:8位上(高4位清0)，存入TLBELO0(1)寄存器。（见TLB表项寄存器）*/ ld.w t1, t0, 0 /* 将t0内存的数据（PTE页表项）存到t1 */ srli.w ra, t1, 0xc slli.w ra, ra, 0x8 andi ra, ra, 0xff or t1, t1, ra csrwr t1, LOONGARCH_CSR_TLBELO0 ld.w t0, t0, 0x4 srli.w ra, t0, 0xc slli.w ra, ra, 0x8 andi t0, t0, 0xff and.w t0, t0, ra csrwr t0, LOONGARCH_CSR_TLBELO1 tlbwr /* 将TLBELO0/1写入TLB表项 */ 12345leave_load: csrrd t0, EXCEPTION_KS0 /* 恢复现场 */ csrrd t1, EXCEPTION_KS1 csrrd ra, EXCEPTION_KS2 ertn 1234567891011vmalloc_load: la.abs t1, swapper_pg_dir b vmalloc_done_loadnopage_tlb_load: dbar 0 csrrd ra, EXCEPTION_KS2 la.abs t0, tlb_do_page_fault_0 jirl $r0, t0, 0SYM_FUNC_END(handle_tlb_load) 传入的BADV为0x0022614c。其中PGD为0xa24b7000，*0xa24b7000 &#x3D; 0xa24bc000。PTE基址 &#x3D; PGD基址 + PGD_OFFSET &#x3D; 0xa24bc000 + (0x000(10bits)&lt;&lt;2) &#x3D; 0xa24bc000该PTE基址 + PTE_OFFSET &#x3D; 0xa24bc000 + (0x226(10bits)&lt;&lt;2) &#x3D; 0xa24bc898 &#x3D; 包含物理页号、页状态位的物理地址将(*0xa24bc898)0xff3a09c的page_valid位置1，即改为0xff3a09d，其中0xff3a(高20bits为物理页号)tlb取0xa24bc898、0xa24bc89c两页表项按规则填入TLBLO0和TLBLO1中填入规则：31:12(PPN)→8:27(PPN)，7:0(page状态位)→7:0(page状态位)，最高4位清0 handle_tlb_load执行过程进入tlb_load过程时，首先保存现场(0x1213b8)，即执行csrwr，将r1的地址0x1213b8存到了0x32地址的内存处。 12SYM_FUNC_START(handle_tlb_load) csrwr ra, EXCEPTION_KS2 csrrd传入出错虚拟地址(BADV)0x2134d4到r12寄存器，0x2134d4比0xc0000000小，故继续顺序执行。 1234lu12i.w ra, 0xc slli.w ra, ra, 0x10 csrrd t0, LOONGARCH_CSR_BADV bgeu t0, ra, vmalloc_load 将PGD基址0xa23e1000传入r13寄存器，其内存的值为0xa23de000 1csrrd t1, LOONGARCH_CSR_PGD 先获取t0(BADV)0x002134d4的前10bits再偏移2位，得到PGD_OFFSET(0x000)，加上PGD(0xa23e1000)，存到r13寄存器，为0xa23e1000。 123456vmalloc_done_load: /* Get PGD offset in bytes */ srli.w t0, t0, 0x16 andi t0, t0, 0x3ff slli.w t0, t0, 0x2 add.w t1, t1, t0 接着获取t0(0x002134d4)的中间10bits再偏移2位，得到PTE_OFFSET(213&lt;&lt;2 &#x3D; 0x84c)，最后加上t1寄存器内存处的值0xa23de000，得到地址0xa23de84c存到t0寄存器。 123456csrrd t0, LOONGARCH_CSR_BADV ld.w t1, t1, 0 srli.w t0, t0, 0xc andi t0, t0, 0x3ff slli.w t0, t0, 0x2 add.w t0, t0, t1 把r12内存处的值(*0xa23de84c&#x3D; 0)写入r13寄存器，再刷新tlb。 123label_smp_pgtable_load: ld.w t1, t0, 0 tlbsrch 因为_PAGE_PRESENT为0(页不存在)，所以跳转到nopage_tlb_load处，即PC跳转到0xa02102b0处执行。 12andi ra, t1, _PAGE_PRESENT beq ra, zero, nopage_tlb_load 接着恢复现场(r1&#x3D;0x1213b8)，跳转到tlb_do_page_fault函数处执行。 12345nopage_tlb_load: dbar 0 csrrd ra, EXCEPTION_KS2 la.abs t0, tlb_do_page_fault_0 jirl $r0, t0, 0 第二次tlb_load: 继续(gdb) c之后，可以看到第二次触发tlb_load的BADV也为0x2134d4。 继续(gdb) si调试到PTE+PTE_OFFSET可以得到r12为0x23de84c，此时该内存地址中有值，为0xff2309c，存到r13寄存器。 12345678910111213141516vmalloc_done_load:/* Get PGD offset in bytes */ srli.w t0, t0, 0x16 andi t0, t0, 0x3ff slli.w t0, t0, 0x2 add.w t1, t1, t0 csrrd t0, LOONGARCH_CSR_BADV ld.w t1, t1, 0 srli.w t0, t0, 0xc andi t0, t0, 0x3ff slli.w t0, t0, 0x2 add.w t0, t0, t1label_smp_pgtable_load: ld.w t1, t0, 0 tlbsrch 0xff2309c的_PAGE_PRESENT(第8位，判断该页是否存在)为1，并将_PAGE_VALID(第1位，判断该页是否有效)置1，即0xff2309d，将0xff2309d写回r12寄存器的内存地址处(*0xa23de84c&#x3D;0xff2309d)。注意：该_PAGE_PRESENT、_PAGE_VALID都为页表的软件位，tlb只有硬件位。 12345andi ra, t1, _PAGE_PRESENT beq ra, zero, nopage_tlb_load ori t1, t1, _PAGE_VALID st.w t1, t0, 0 由于tlb一次存取两页，其中第3位表示奇偶页。故将0xa23de848和0xa23de84c内存地址处的值（包含PPN、页表标志位的地址）按规则存入TLBLO0和TLBLO1中。由于TLBLO0寄存器的31:8位表示PPN，而页表31:12位表示PPN，故需要将该页表*0xa23de848的高20位PPN写入到TLBLO0寄存器的31:8位(其中高4位清0)，低8位标志位写入到TLBLO0寄存器的7:0位。所以TLBO0 &#x3D; ( t1 &gt;&gt;12 &lt;&lt; 8) | (t1 &amp; 0xff)。所以通过csrwr写入寄存器，TLBLO0寄存器按0xff229c写入 。TLBLO1寄存器按0xff239d写入，将旧值写回t0,t1。由于TLBLO0寄存器实际第8位只读恒为0，故第8位写忽略。 12345678910111213141516ori t0, t0, 0x4 xori t0, t0, 0x4 ld.w t1, t0, 0 srli.w ra, t1, 0xc slli.w ra, ra, 0x8 andi t1, t1, 0xff add.w t1, t1, ra csrwr t1, LOONGARCH_CSR_TLBELO0 ld.w t0, t0, 0x4 srli.w ra, t0, 0xc slli.w ra, ra, 0x8 andi t0, t0, 0xff add.w t0, t0, ra csrwr t0, LOONGARCH_CSR_TLBELO1 csrwr t0, LOONGARCH_CSR_TLBELO1 接着恢复现场，从例外处理现场返回。 123456tlbwr csrrd t0, LOONGARCH_CSR_KS0 csrrd t1, LOONGARCH_CSR_KS1 csrrd ra, EXCEPTION_KS2 ertn 总结 BADV: 0x002134d4 *0xa23de848 &#x3D; 0xff2209c, TLBLO0 &#x3D; ff229c(实际为ff221c，第8位恒为0，其中第1位页有效位为0); *0xa23de84c &#x3D; 0xff2309d, TLBLO0 &#x3D; ff239d(实际为ff231d，第8位恒为0，其中第1位页有效位为1); 1234do_raise_exception_err: 29 0mips_cpu_do_interrupt enter: PC 0018c16c EPC 0018c16c RFEPC 0x000000000018c16c TLB load exceptionmips_cpu_do_interrupt: PC a0214000 EPC 0x0018c16c cause 1 EXST 00010000 EXCFG 0x00071c1c BADVA 0x002134d4 ENV_PGDL 0xa23e1000 BADI 0x00000000 SYS_NUM 2381672 cpu 0 asid 0x1 参考四种TLB异常TLB 异常总共有 4 种：TLB&#x2F;XTLB 重填异常（TLB Refill Exception，意味着 TLB 中没有对应项），TLB 加载无效异常（TLB Load Invalid Exception，意味着读请求、TLB 中有对应项、但对应项无效），TLB 存储无效异常（TLB Store Invalid Exception，意味着写请求、TLB 中有对应项、但对应项无效），TLB 修改异常（TLB Modify Exception，意味着写请求，TLB 中有对应项、也有效、但对应项只读）。TLB&#x2F;XTLB 重填异常有专门的入口向量（向量 0 和向量 1），而其他几种异常使用通用入口向量（向量 3）。 BADV 出错虚地址 虚拟地址结构32位系统的页面大小4KB。PGD和PTE占10位，故页表项4B，页目录表4KB，页目录表中每个有效表项对应一个 4KB 页表。 虚拟地址 10：10：12 （PGD：PTE：PAGE_OFFSET） PGD 全局目录基址 PGDL+PGDOFFSET &#x3D; BADV对应PGD物理地址 TLBSRCH TLBELO0,1 ld.w和st.w指令12ld.w rd, rj, 0 /* 将rj内存中的数据装入到rd寄存器 */st.w rd, rj, 0 /* 将rd寄存器中的数据存入rj内存 */ Load 用于把内存中的数据装载到寄存器中。 rd &#x3D; *rjStore用于把寄存器中的数据存入内存。 *rj &#x3D; rd DBAR 栅障指令 ERTN TLBFILL Page table bits12345678910111213141516/* Page table bits */......#define _PAGE_VALID_SHIFT 0#define _PAGE_DIRTY_SHIFT 1#define _PAGE_PLV_SHIFT 2 /* 2~3, two bits */#define _CACHE_SHIFT 4 /* 4~5, two bits */#define _PAGE_GLOBAL_SHIFT 6#define _PAGE_HUGE_SHIFT 6 /* HUGE is a PMD bit */ #define _PAGE_PRESENT_SHIFT 7#define _PAGE_WRITE_SHIFT 8#define _PAGE_PROTNONE_SHIFT 9#define _PAGE_SPECIAL_SHIFT 10#define _PAGE_HGLOBAL_SHIFT 12 /* HGlobal is a PMD bit */#define _PAGE_PFN_SHIFT 12#define _PAGE_PFN_END_SHIFT 31...... 虚拟地址划分：最低的2GB（USEG）既缓存又分页；随后的512MB（KSEG0）缓存但不分页，对应物理地址的低 512MB（虚拟地址去掉高三位即为物理地址）；接下来的512MB（KSEG1）既不缓存又不分页，同样对应物理地址的低 512MB（虚拟地址去掉高三位即为物理地址）；最后的 1GB（KSEG2）对应物理既缓存又分页。 其他tlb_load1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071SYM_FUNC_START(handle_tlb_store) csrwr ra, EXCEPTION_KS2 lu12i.w ra, 0xc slli.w ra, ra, 0x10 csrrd t0, LOONGARCH_CSR_BADV bgeu t0, ra, vmalloc_store csrrd t1, LOONGARCH_CSR_PGDvmalloc_done_store: /* Get PGD offset in bytes */ srli.w t0, t0, 0x16 andi t0, t0, 0x3ff slli.w t0, t0, 2 add.w t1, t1, t0 csrrd t0, LOONGARCH_CSR_BADV ld.w t1, t1, 0 srli.w t0, t0, 0xc andi t0, t0, 0x3ff slli.w t0, t0, 0x2 add.w t1, t1, t0label_smp_pgtable_store: ld.w t0, t1, 0 tlbsrch srli.w ra, t0, _PAGE_PRESENT_SHIFT andi ra, ra, ((_PAGE_PRESENT | _PAGE_WRITE) &gt;&gt; _PAGE_PRESENT_SHIFT) xori ra, ra, ((_PAGE_PRESENT | _PAGE_WRITE) &gt;&gt; _PAGE_PRESENT_SHIFT) bne ra, $r0, nopage_tlb_store ori t0, t0, (_PAGE_VALID | _PAGE_DIRTY) st.w t0, t1, 0// beq t0, $r0, label_smp_pgtable_store ori t1, t1, 4 xori t1, t1, 4 ld.w t0, t1, 0 srli.w ra, t0, 0xc slli.w ra, ra, 0x8 andi t0, t0, 0xff add.w t0, t0, ra csrwr t0, LOONGARCH_CSR_TLBELO0 ld.w t1, t1, 4 srli.w ra, t1, 0xc slli.w ra, ra, 0x8 andi t1, t1, 0xff add.w t1, t1, ra csrwr t1, LOONGARCH_CSR_TLBELO1 tlbwr csrrd t0, LOONGARCH_CSR_KS0 csrrd t1, LOONGARCH_CSR_KS1 csrrd ra, EXCEPTION_KS2 ertnvmalloc_store: la.abs t1, swapper_pg_dir b vmalloc_done_storenopage_tlb_store: dbar 0 csrrd ra, EXCEPTION_KS2 la.abs t0, tlb_do_page_fault_1 jirl $r0, t0, 0SYM_FUNC_END(handle_tlb_store) tlb_modify12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273SYM_FUNC_START(handle_tlb_modify) csrwr ra, EXCEPTION_KS2 /* * The vmalloc handling is not in the hotpath. */ lu12i.w ra, 0xc slli.w ra, ra, 0x10 csrrd t0, LOONGARCH_CSR_BADV bgeu t0, ra, vmalloc_modify csrrd t1, LOONGARCH_CSR_PGDvmalloc_done_modify: /* Get PGD offset in bytes */ srli.w t0, t0, 0x16 andi t0, t0, 0x3ff slli.w t0, t0, 2 add.w t1, t1, t0 csrrd t0, LOONGARCH_CSR_BADV ld.w t1, t1, 0 srli.w t0, t0, 0xc andi t0, t0, 0x3ff slli.w t0, t0, 0x2 add.w t1, t1, t0label_smp_pgtable_modify: ld.w t0, t1, 0 tlbsrch srli.w ra, t0, _PAGE_WRITE_SHIFT andi ra, ra, 1 beq ra, $r0, nopage_tlb_modify ori t0, t0, (_PAGE_VALID | _PAGE_DIRTY) st.w t0, t1, 0// beq t0, $r0, label_smp_pgtable_modify ori t1, t1, 4 xori t1, t1, 4 ld.w t0, t1, 0 srli.w ra, t0, 0xc slli.w ra, ra, 0x8 andi t0, t0, 0xff add.w t0, t0, ra csrwr t0, LOONGARCH_CSR_TLBELO0 ld.w t1, t1, 0x4 srli.w ra, t1, 0xc slli.w ra, ra, 0x8 andi t1, t1, 0xff add.w t1, t1, ra csrwr t1, LOONGARCH_CSR_TLBELO1 tlbwr csrrd t0, LOONGARCH_CSR_KS0 csrrd t1, LOONGARCH_CSR_KS1 csrrd ra, EXCEPTION_KS2 ertnvmalloc_modify: la.abs t1, swapper_pg_dir b vmalloc_done_modifynopage_tlb_modify: dbar 0 csrrd ra, EXCEPTION_KS2 la.abs t0, tlb_do_page_fault_1 jirl $r0, t0, 0SYM_FUNC_END(handle_tlb_modify) tlb_refill12345678910111213141516171819202122232425262728293031323334353637SYM_FUNC_START(handle_tlb_refill) csrwr t0, LOONGARCH_CSR_KS0 csrwr t1, LOONGARCH_CSR_KS1 csrwr ra, EXCEPTION_KS2 csrrd t0, LOONGARCH_CSR_PGD csrrd t1, LOONGARCH_CSR_BADV srli.w t1, t1, 0x16 slli.w t1, t1, 0x2 add.w t0, t0, t1 ld.w t0, t0, 0 csrrd t1, LOONGARCH_CSR_BADV srli.w t1, t1, 0xa andi t1, t1, 0xff8 add.w t0, t0, t1 ld.w t1, t0, 0 srli.w ra, t1, 0xc slli.w ra, ra, 0x8 andi t1, t1, 0xff add.w t1, t1, ra csrwr t1, LOONGARCH_CSR_TLBELO0 ld.w t1, t0, 0x4 srli.w ra, t1, 0xc slli.w ra, ra, 0x8 andi t1, t1, 0xff add.w t1, t1, ra csrwr t1, LOONGARCH_CSR_TLBELO1 tlbfill csrrd t0, LOONGARCH_CSR_KS0 csrrd t1, LOONGARCH_CSR_KS1 csrrd ra, EXCEPTION_KS2 ertnSYM_FUNC_END(handle_tlb_refill)","categories":[{"name":"内核分析","slug":"内核分析","permalink":"https://azreallem.github.io/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://azreallem.github.io/tags/linux/"},{"name":"tlbex","slug":"tlbex","permalink":"https://azreallem.github.io/tags/tlbex/"}]},{"title":"EOF","slug":"EOF","date":"2021-07-30T02:46:29.000Z","updated":"2022-04-03T08:56:12.000Z","comments":true,"path":"2021/07/30/EOF/","link":"","permalink":"https://azreallem.github.io/2021/07/30/EOF/","excerpt":"","text":"EOF是&lt;stdio.h&gt;中的宏定义，EOF(End Of File)是一个与标准输入&#x2F;输出流相关联的标志位。当文件指针已经指向文件尾且再次尝试读取时，EOF标志会被设置。同时，某些函数会在读取到文件尾（即EOF标志被设置）时返回EOF作为标识。 12345678/* Buffered I/O macros */#define BUFSIZ 512// ......#define EOF (-1)// ...... 在操作系统中，文件以文件存储占用的扇区数作为文件大小的计数单位，故而如果文件的大小不能恰好填满存储文件的最后一个扇区，则需要对该扇区剩余的空间进行填充，过去填充使用的是值为26(0x1a)的字节，也就是某些系统中 Ctrl+Z 的对应码值。 EOF 函数getchar()getchar()的返回值与EOF进行比较，如果不相同，说明还没有到达文件结尾。 在Unix系统中，可以通过在一行开始键入Ctrl+D来从键盘模拟文件结束条件；windows系统则使用Ctrl+Z来达到这个目的。 1while （(ch = getchar ()) != EOF） scanf()scanf()函数返回一个整数值，这个值是成功读取的项目数，或者当遇到文件结束时返回一个EOF(文件结尾符)。 1while (scanf (&quot;%d&quot;, &amp;n) != EOF) fclose()fclose()函数 如果成功返回 0，否则返回EOF（-1）。 getc()如果读入字符时发现已经到达文件结尾，getc()会返回一个特殊值EOF。 1234567int ch;FILE * fp;fp = fopen (&quot;abc.txt&quot;, &quot;r&quot;);while ((ch = getc (fp)) != EOF)&#123; putchar (ch);&#125; feof()int feof(FILE * stream); 会检查与文件对应流的eof( end of file )标志是否被设置，如果被设置则返回非零值，如未被设置，则返回0。 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main(void)&#123; FILE *ptr = fopen(&quot;a.txt&quot;,&quot;r&quot;); if(!ptr) &#123; printf(&quot;打开文件失败！\\n&quot;); return -1; &#125; char ch; int count = 0 ; while(!feof(ptr)) //检测到EOF标志则停止 &#123; count++; ch = fgetc(ptr); printf(&quot;%c&quot;,ch); &#125; printf(&quot;%5d&quot;,count); printf(&quot;\\n&quot;); fclose(ptr); return 0;&#125;","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://azreallem.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"technique","slug":"technique","permalink":"https://azreallem.github.io/tags/technique/"},{"name":"note","slug":"note","permalink":"https://azreallem.github.io/tags/note/"},{"name":"C","slug":"C","permalink":"https://azreallem.github.io/tags/C/"}]},{"title":"《C Primer Plus》笔记","slug":"《C-Primer-Plus》笔记","date":"2021-07-26T04:51:22.000Z","updated":"2022-03-29T15:17:28.000Z","comments":true,"path":"2021/07/26/《C-Primer-Plus》笔记/","link":"","permalink":"https://azreallem.github.io/2021/07/26/%E3%80%8AC-Primer-Plus%E3%80%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"摘要：从2021&#x2F;07&#x2F;19到2021&#x2F;07&#x2F;26阅读完毕 参考： C在线工具 C Primer Plus 第6版中文版.pdf 基础内容#include#include这行代码是一条C预处理器指令（preprocessor directive）。通常，C编译器在编译前会对源代码做一些准备工作，即预处理（preprocessing）。 #include &quot;hotels.h&quot;指令中的双引号表明被包含的源文件位于当前目录中（通常是包含源代码的目录）。 字符和字符串字符串是以空字符（\\0）（ASCII &#x3D; 0）结尾的char类型数组。 scanf()只会读取字符数组中的一个单词，而不是一整句，在遇到空格、换行时就停止了。 字符串常量”x”和字符常量’x’不同。区别之一在于’x’是基本类型（char），而”x”是派生类型（char数组）；区别之二是”x”实际上由两个字符组成：’x’和空字符\\0。 sizeof() 、size_t和 scanf()sizeof 运算符，它以字节为单位给出对象的大小。sizeof 返回 size_t 类型的值。这是一个无符号整数类型，但它不是新类型。 size_t是语言定义的标准类型，size_t 类型被定义为 sizeof 运算符的返回值类型——无符号整数类型。C有一个typedef机制，允许程序员为现有类型创建别名。例如，typedef double real;类似地，C 头文件系统可以使用 typedef把 size_t 作为 unsigned int 或unsigned long的别名。stddef.h文件中包含了size_t类型的typedef或#define定义。这样，在使用size_t类型时，编译器会根据不同的系统替换标准类型。 scanf()中把***放在%和转换字符之间时，会使得scanf()跳过相应的输出项。如%*d、%.2f等 字符缓冲区用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。 为什么要有缓冲区？ 首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。缓冲分为两类：完全缓冲I&#x2F;O和行缓冲I&#x2F;O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I&#x2F;O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。 行缓冲输入getchar() 回显无缓冲输入的getche() 无回显无缓冲输入的getch() 缓冲输入和无缓冲输入 从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。 如果包含&lt;stdio.h&gt;文件，并使用EOF符号，就不必担心EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。 重定向输入 、 重定向输出123./helloworld &lt; words # 将words文件中的内容以字符流的方式输入到helloworld中./helloworld &gt; words # Ctrl + D 结束输入./helloworld &lt; words &gt; words2 # 组合重定向 递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。 指针和运算符地址运算符：&amp;一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。可以把地址看作是变量在内存中的位置。 12pooh = 24;printf(&quot;%d %p\\n&quot;, pooh, &amp;pooh); 指针指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址，大小为4B。 要创建指针变量，先要声明指针变量的类型。假设想把ptr声明为储存int类型变量地址的指针，就要使用间接运算符：*。 间接运算符：*123int bah = 500;int *ptr = &amp;bah; // 定义ine类型的指针ptr，值为bah地址int val = *ptr; // 找出ptr指向的值,val = 500 scanf(&quot;%d&quot;, &amp;num) //scanf()读取一个值，然后把该值储存到指定的地址上。 12345678910#include &lt;stdio.h&gt;#define STLEN 5int main(void)&#123; int a = 1; int* p = &amp;a; scanf(&quot;%d&quot;, p); printf(&quot;a=%d\\t*p=%d\\n&quot;, a, *p); return 0;&#125; 指针和数组我们的系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节。 12345678910#include &lt;stdio.h&gt;int main(void)&#123; int a[10] = &#123; 1, 2,3,4 ,5,6,7,8,9,0&#125;; char c[11] = &quot;abcdefghij&quot;; printf(&quot;%d\\n&quot;, *(a + 1)); //ar[i] 与 *(ar + i) printf(&quot;%c\\n&quot;, *(c + 1)); return 0;&#125; 对形式参数使用const如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。 1int sum(const int ar[], int n); /* 函数原型 */ 多维数组zippo[2][1] &#x3D; ((zippo+2) + 1)zippo[0] &#x3D; *zippozippo[0][0] &#x3D; *zippo[0] &#x3D; **zippo &#x3D; 2 数组的数组 1void somefunction( int pt[][4]); 命令行参数 命令行参数 字符串什么是字符串gets()、gets_s()、fgets()、puts()、fputs()、strcat()、strncat()、strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr() 字符串是以空字符（\\0）结尾的char类型数组。在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）。 初始化数组 字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。 1234567891011121314#define MSG &quot;I&#x27;m special&quot;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char ar[] = MSG; const char* pt = MSG; printf(&quot;address ar: %p\\n&quot;, ar); printf(&quot;address pt: %p\\n&quot;, pt); printf(&quot;address of MSG: %p\\n&quot;, MSG); printf(&quot;address of \\&quot;I&#x27;m special\\&quot;: %p \\n&quot;, &quot;I&#x27;m special&quot;); printf(&quot;%c\\tsizeof(MSG)=%d\\tstrlen(MSG)=%d\\tsizeof(pt)=%d\\n&quot;, MSG[1], sizeof(ar), strlen(MSG), sizeof(pt)); return 0;&#125; 初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。 字符串中数组和指针的区别初始化字符数组来储存字符串和初始化指针来指向字符串有何区别（“指向字符串”的意思是指向字符串的首字符）？ 例如，假设有下面两个声明：char heart[] &#x3D; “I love Tillie!”;const char *head &#x3D; “I love Millie!”;两者主要的区别是：数组名heart是常量，而指针名head是变量，字符串常量属于静态存储类别（static storage class）。 12345678910#include &lt;stdio.h&gt;int main()&#123; char heart[] = &quot;I love Tillie!&quot;; const char* head = &quot;I love Millie!&quot;; head = heart; heart[2] = &#x27;a&#x27;; printf(&quot;%s\\n&quot;, head); return 0;&#125; 12char * word = &quot;frame&quot;;word[1] = &#x27;l&#x27;; // 是否允许？ 这样的语句可能导致内存访问错误。原因前面提到过，编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。如果编译器使用这种单次副本表示法，并允许word[1]修改为’1’，那将影响所有使用该字符串的代码。因此，建议在把指针初始化为字符串字面量时使用const限定符：const char * word = &quot;frame&quot;; // 推荐用法 12345678910111213#include &lt;stdio.h&gt;#define MES &quot;Don&#x27;t be a fool!&quot;int main(void)&#123; const char* mesg = &quot;Don&#x27;t be a fool!&quot;; const char* copy; copy = mesg; printf(&quot;%s\\n&quot;, copy); printf(&quot;mesg = %s; &amp;mesg = %p; value = %p\\n&quot;, mesg, &amp;mesg, mesg); printf(&quot;copy = %s; &amp;copy = %p; value = %p\\n&quot;, copy, &amp;copy, copy); printf(&quot;\\&quot;%s\\&quot; = %p&quot;, MES,MES); return 0;&#125; 读入字符串scanf()、gets()和fgets()为字符串分配内存后，便可读入字符串。C 库提供了许多读取字符串的函数：scanf()、gets()和fgets()。 scanf()和转换说明%s只能读取一个字符。 gets()函数读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符’\\0’使其成为一个 C 字符串。它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。 如果输入的字符串过长，会导致缓冲区溢出，该函数的不安全行为造成了安全隐患。【运行时异常】过去通常用fgets()来代替gets()。C11标准新增的gets_s()函数也可代替gets()。用一个参数限制读入的字符数。 fgets()和fputs()fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别如下。 fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。 fgets()函数的第3个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与 fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout（标准输出）作为该参数。 123456789101112#include &lt;stdio.h&gt;#define STLEN 5int main(void)&#123; char words[STLEN]; puts(&quot;Enter a string, please.&quot;); fgets(words, STLEN, stdin); // 典型用法 printf(&quot;Your string twice:\\n&quot;); puts(words); // 末尾有换行 fputs(words, stdout); // 末尾没有换行 return 0;&#125; 字符串函数 unsigned long strlen(const char *p);用以统计字符串的长度。（不包含‘\\0’） char *strcat(char *p, const char *q); 用以拼接字符串，返回第一个参数 char *strncat(char *dest, const char *src, size_t count);用以拼接字符串，返回第一个参数，第三个参数是能够添加字符数的大小 int strcmp(const char *cs, const char *ct);由于非零值都为“真”，while (strcmp(str1, str2)) &#x2F;&#x2F;当str1和str2不相同时如果两个字符串相等，则返回0 char *strcpy(char *p, const char *q); char *strncpy(char *p, const char *q, unsigned long size);将str2拷贝到str1中 char *strchr(const char * s, int c); 【参数】str 为要查找的字符串，c 为要查找的字符。 【返回值】如果找到指定的字符则返回该字符所在地址，否则返回 NULL。 strchr() 将会找出 str 字符串中第一次出现的字符 c 的地址，然后将该地址返回。 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123; char* s = &quot;0123456789012345678901234567890&quot;; char* p = strchr(s, &#x27;5&#x27;); printf(&quot;%p\\n&quot;, s); printf(&quot;%p\\n&quot;, p); return 0;&#125; int sprintf( char *buffer, const char *format, [ argument] … ); buffer： char型指针，指向将要写入的字符串的缓冲区。format：格式化字符串。***[argument]…***：可选参数，可以是任何类型的数据。return：成功则返回参数buffer字符串长度，失败则返回-1，错误原因存于errno 中。 12sprintf(s, &quot;%d&quot;, 123); //把整数123打印成一个字符串保存在s中sprintf(buf, &quot;The length of the string is more than %d\\n&quot;, 10); 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main(void)&#123; char str[100]; int offset = 0; int i = 0; srand(time(0)); // *随机种子 for (i = 0; i &lt; 10; i++) &#123; offset += sprintf(str + offset, &quot;%d,&quot;, rand() % 100); // 格式化的数据写入字符串 &#125; str[offset - 1] = &#x27;\\0&#x27;; printf(str); return 0;&#125; 12345678910#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; int count; printf(&quot;The command line has %d arguments:\\n&quot;, argc - 1); for (count = 0; count &lt; argc; count++) printf(&quot;argv[%d]: %s\\n&quot;, count, argv[count]); printf(&quot;\\n&quot;); return 0;&#125; 存储类别、链接和内存管理存储类别从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为对象（object）。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小。（面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言） 从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来完成： 12int entity = 3;const char * pc = &quot;Behold a string literal!&quot;; 程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值的数组就是一个对象。由于数组中的每个字符都能被单独访问，所以每个字符也是一个对象。该声明还创建了一个标识符为pc的对象，储存着字符串的地址。由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的左值。const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指向别的字符串。 可以用存储期（storage duration）描述对象，所谓存储期是指对象在内存中保留了多长时间。标识符用于访问对象，可以用作用域（scope）和链接（linkage）描述标识符，标识符的作用域和链接表明了程序的哪些部分可以使用它。不同的存储类别具有不同的存储期、作用域和链接。标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的执行期存在。可以通过函数调用的方式显式分配和释放内存。 链接C 变量有 3 种链接属性：外部链接、内部链接或无链接。具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。 C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。 一些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”。 123456int giants = 5; // 文件作用域，外部链接static int dodgers = 3; // 文件作用域，内部链接int main()&#123;...&#125; 存储期C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。 静态存储期：它在程序的执行期间一直存在。无论是内部链接（static）还是外部链接，所有的文件作用域变量都具有静态存储期。 线程存储期：用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明（_Thread_local）时到线程结束一直存在。 自动存储期：局部变量。块作用域的变量通常都具有自动存储期，当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。 动态分配存储期：malloc()、free()。 静态变量块作用域的静态变量“局部静态变量”是描述具有块作用域的静态变量的另一个术语。 1234567891011121314151617181920#include &lt;stdio.h&gt;void trystat1(void);int main(void)&#123; int count; int stay = 0; for (count = 1; count &lt;= 3; count++) &#123; printf(&quot;Here comes iteration %d:\\n&quot;, count); trystat1(); printf(&quot;main: stay:%d\\n&quot;, stay); &#125; return 0;&#125;void trystat1(void)&#123; int fade = 1; static int stay = 1; //块作用域的静态变量 printf(&quot;fade = %d and stay = %d\\n&quot;, fade++, stay++);&#125; 内部链接的静态变量普通的外部变量可用于同一程序中任意文件中的函数，但是内部链接的静态变量只能用于同一个文件中的函数。 12345static int svil = 1; // 静态变量，内部链接int main(void)&#123; ...&#125; C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。 外部链接的静态变量把变量的定义性声明（defining declaration）放在在所有函数的外面便创建了外部变量。当然，为了指出该函数使用了外部变量，可以在函数中用关键字extern再次声明。 12345678910int Errupt; /* 外部定义的变量 ，定义式声明（defining declaration）*/double Up[100]; /* 外部定义的数组 ，定义式声明（defining declaration）*/extern char Coal; /* 如果Coal被定义在另一个文件，引用式声明（referencing declaration） */int main(void)&#123; extern int Errupt; /* 可选的重复声明，引用式声明（referencing declaration）*/ extern double Up[]; /* 可选的重复声明，引用式声明（referencing declaration）*/ ...&#125; 外部变量只能初始化一次，且必须在定义该变量时进行，只有定义式声明才能初始化变量。 1234567891011121314/* file1.c */int Errupt = 1; /* 定义式声明（defining declaration）+ 初始化 *//* file2.c */#include &lt;stdio.h&gt;//以下声明错误：//extern int Errupt = 1; /* 引用式声明（referencing declaration），不能初始化*/extern int Errupt;int main(void)&#123; Errupt = 2; printf(&quot;%d\\n&quot;, Errupt); return 0;&#125; 存储类别说明符C语言有6个关键字作为存储类别说明符：auto、register、static、extern、_Thread_local和typedef。 下面用一个简短的程序使用了5种存储类别。 1234567891011121314151617181920212223242526// parta.c --- 不同的存储类别// 与 partb.c 一起编译#include &lt;stdio.h&gt;void report_count();void accumulate(int k);int count = 0; // 文件作用域，外部链接int main(void)&#123; int value; // 自动变量 register int i; // 寄存器变量 printf(&quot;Enter a positive integer (0 to quit): &quot;); while (scanf(&quot;%d&quot;, &amp;value) == 1 &amp;&amp; value &gt; 0) &#123; ++count; // 使用文件作用域变量 for (i = value; i &gt;= 0; i--) accumulate(i); printf(&quot;Enter a positive integer (0 to quit): &quot;); &#125; report_count(); return 0;&#125;void report_count()&#123; printf(&quot;Loop executed %d times\\n&quot;, count);&#125; 12345678910111213141516171819202122// partb.c -- 程序的其余部分// 与 parta.c 一起编译#include &lt;stdio.h&gt;extern int count; // 引用式声明，外部链接static int total = 0; // 静态定义，内部链接void accumulate(int k); // 函数原型void accumulate(int k) // k具有块作用域，无链接&#123; static int subtotal = 0; // 静态，无链接 if (k &lt;= 0) &#123; printf(&quot;loop cycle: %d\\n&quot;, count); printf(&quot;subtotal: %d; total: %d\\n&quot;, subtotal, total); subtotal = 0; &#125; else &#123; subtotal += k; total += k; &#125;&#125; 存储类别和函数函数也有存储类别，可以是外部函数（默认）或静态函数。 123double gamma(double); /* 该函数默认为外部函数 */static double beta(int, int);extern double delta(double, int); 在同一个程序中，其他文件中的函数可以调用gamma()和delta()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。 通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，否则一般函数声明都默认为extern。 随机数函数和静态变量ANSI C库提供了rand()函数生成随机数。生成随机数有多种算法，ANSI C允许C实现针对特定机器使用最佳算法。然而，ANSI C标准还提供了一个可移植的标准算法，在不同系统中生成相同的随机数。实际上，rand()是“伪随机数生成器”，意思是可预测生成数字的实际序列。但是，数字在其取值范围内均匀分布。 可移植版本的方案开始于一个“种子”数字。该函数使用该种子生成新的数，这个新数又成为新的种子。然后，新种子可用于生成更新的种子，以此类推。 123456789101112131415161718192021/* rand0.c --生成随机数*//* 使用 ANSI C 可移植算法 */static unsigned long int next = 1; /* 种子 */unsigned int rand0(void)&#123; /* 生成伪随机数的魔术公式 */ next = next * 1103515245 + 12345; return (unsigned int)(next / 65536) % 32768;&#125;/* r_drive0.c -- 测试 rand0()函数 *//* 与 rand0.c 一起编译*/#include &lt;stdio.h&gt;extern unsigned int rand0(void);int main(void)&#123; int count; for (count = 0; count &lt; 5; count++) printf(&quot;%d\\n&quot;, rand0()); return 0;&#125; 问题：伪随机，每次运行的结果都相同。改进：可以引入另一个函数srand1()重置种子来解决这个问题。关键是要让next成为只供rand1()和srand1()访问的内部链接静态变量（srand1()相当于C库中的srand()函数）。 1234567891011121314151617181920212223242526272829303132333435/* s_and_r.c -- 包含 rand1() 和 srand1() 的文件 *//* 使用 ANSI C 可移植算法 */static unsigned long int next = 1; /* 种子 */int rand1(void)&#123; /*生成伪随机数的魔术公式*/ next = next * 1103515245 + 12345; return (unsigned int)(next / 65536) % 32768;&#125;void srand1(unsigned int seed)&#123; next = seed;&#125;/* r_drive1.c -- 测试 rand1() 和 srand1() *//* 与 s_and_r.c 一起编译 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;extern void srand1(unsigned int x);extern int rand1(void);int main(void)&#123; int count; unsigned seed; printf(&quot;Please enter your choice for seed.\\n&quot;); while (scanf(&quot;%u&quot;, &amp;seed) == 1) &#123; srand1(seed); /* 重置种子 */ for (count = 0; count &lt; 5; count++) printf(&quot;%d\\n&quot;, rand1()); printf(&quot;Please enter next seed (q to quit):\\n&quot;); &#125; printf(&quot;Done\\n&quot;); return 0;&#125; 如果 C 实现允许访问一些可变的量（如，时钟系统），可以用这些值（可能会被截断）初始化种子值。 12#include &lt;time.h&gt; /* 提供time()的ANSI原型*/srand1((unsigned int) time(0)); /* 初始化种子 */ 掷骰子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//diceroll.h#include &lt;stdlib.h&gt; /* 提供rand()的原型 */extern int roll_count;int roll_n_dice(int dice, int sides);#ifdef rollemint rollem(int sides)&#123; int roll; roll = rand() % sides + 1; return roll;&#125;#endif // DEBUG/* diceroll.c -- 掷骰子模拟程序 *//* 与 mandydice.c 一起编译 */#include &quot;diceroll.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* 提供库函数 rand()的原型 */int roll_count = 0; /* 外部链接 */static int rollem(int sides) /* 该函数属于该文件私有 */&#123; int roll; roll = rand() % sides + 1; ++roll_count; /* 计算函数调用次数 */ return roll;&#125;int roll_n_dice(int dice, int sides)&#123; int d; int total = 0; if (sides &lt; 2) &#123; printf(&quot;Need at least 2 sides.\\n&quot;); return -2; &#125; if (dice &lt; 1) &#123; printf(&quot;Need at least 1 die.\\n&quot;); return -1; &#125; for (d = 0; d &lt; dice; d++) total += rollem(sides); return total;&#125;/* manydice.c -- 多次掷骰子的模拟程序 *//* 与 diceroll.c 一起编译*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* 为库函数 srand() 提供原型 */#include &lt;time.h&gt; /* 为 time() 提供原型 */#include &quot;diceroll.h&quot; /* 为roll_n_dice()提供原型，为roll_count变量提供声明 */int main(void)&#123; int dice, roll; int sides; int status; srand((unsigned int)time(0)); /* 随机种子 */ printf(&quot;Enter the number of sides per die, 0 to stop.\\n&quot;); while (scanf(&quot;%d&quot;, &amp;sides) == 1 &amp;&amp; sides &gt; 0) &#123; printf(&quot;How many dice?\\n&quot;); if ((status = scanf(&quot;%d&quot;, &amp;dice)) != 1) &#123; if (status == EOF) break; /* 退出循环 */ else &#123; printf(&quot;You should have entered an integer.&quot;); printf(&quot; Let&#x27;s begin again.\\n&quot;); while (getchar() != &#x27;\\n&#x27;) continue; /* 处理错误的输入 */ printf(&quot;How many sides? Enter 0 to stop.\\n&quot;); continue; /* 进入循环的下一轮迭代 */ &#125; &#125; roll = roll_n_dice(dice, sides); printf(&quot;You have rolled a %d using %d %d-sided dice.\\n&quot;, roll, dice, sides); printf(&quot;How many sides? Enter 0 to stop.\\n&quot;); &#125; printf(&quot;The rollem() function was called %d times.\\n&quot;, roll_count); /* 使用外部变量 */ printf(&quot;GOOD FORTUNE TO YOU!\\n&quot;); return 0;&#125; 分配内存：malloc()和free()malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。从ANSI C标准开始，C使用一个新的类型：指向void的指针。该类型相当于一个“通用指针”。malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。在ANSI C中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向 void的指针赋给任意类型的指针完全不用考虑类型匹配的问题。如果 malloc()分配内存失败，将返回空指针。 123double * ptd;ptd = (double *) malloc(30 * sizeof(double));free(ptd); 通常，malloc()要与free()配套使用。free()函数的参数是之前malloc()返回的地址，该函数释放之前malloc()分配的内存。 设想malloc()和free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用free()把内存归还内存池中，这样便可重复使用这些内存。free()的参数应该是一个指针，指向由 malloc()分配的一块内存。不能用 free()释放通过其他方式（如，声明一个数组）分配的内存。malloc()和free()的原型都在stdlib.h头文件中。 calloc()函数123long * newmem;newmem = (long *)calloc(100, sizeof (long));free(newmem); 变长数组12345int n;int* pi;scanf(&quot;%d&quot;, &amp;n);pi = (int*)malloc(n * sizeof(int)); //变长数组int ar[n];// 变长数组：编译错误 变长二位数组正确的做法是先分配行，再分配列。 释放内存的时候，要先释放列，再释放行。 注意，顺序反了的话，会把列的地址擦除，导致释放列时内存时找不到地址，程序崩溃。 正确的分配空间代码如下： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; int num = 0; int offset = 0; int n = 5, m = 6; char str[100]; int** arr = (int**)malloc(n * sizeof(int*)); for (int i = 0; i &lt; n; i++) arr[i] = (int*)malloc(m * sizeof(int)); for (int i = 0; i &lt; 5; i++) for (int j = 0; j &lt; 6; j++) &#123; arr[i][j] = ++num; offset += sprintf(str + offset, &quot;%d,&quot;, arr[i][j]); &#125; str[offset - 1] = &#x27;\\0&#x27;; printf(&quot;%s&quot;, str); //正确的释放空间代码如下： for (int i = 0; i &lt; n; i++) free(arr[i]);/*释放列*/ free(arr);/*释放行*/ return 0;&#125; 这种分配方式得到的其实并不是真正意义上的二维数组，因为其行与行之间的内存并不连续，虽然可以用下标arr[i][j]的方式访问，但当用指向该二维数组的指针来访问时候，不能通过指针值的增加来跨行获取元素，不过这种情况一般用的也不多，因此上述分配方式在大多数情况下的操作都能得到正确的结果。 ANSI C类型限定符const类型限定符以const关键字声明的对象，其值不能通过赋值或递增、递减来修改。 123456789const int nochange = 12;const int days1[12] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;const char* str;const float * pf; /* pf 指向一个float类型的const值 */float * const pt; /* pt 是一个const指针 */const float * const ptr; /* 表明ptr既不能指向别处，它所指向的值也不能改变。 */float const * pfc; // 与const float * pfc;相同 就近原则：const 跟 float 还是 * 更近。创建了 pf 指向的值不能被改变，而 pf 本身的值可以改变。创建的指针pt本身的值不能更改。pt必须指向同一个地址，但是它所指向的值可以改变。 const放在左侧任意位置，限定了指针指向的数据不能改变；const放在的右侧，限定了指针本身不能改变。 volatile类型限定符1、为什么用volatile？ volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。例如，一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算机传入的信息。 123vall = x;/* 一些不使用 x 的代码*/val2 = x; 现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但并未改变它的值。于是编译器把 x的值临时储存在寄存器中，然后在val2需要使用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时间。这个过程被称为高速缓存（caching）。 volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如： 12345volatile int i=10;int a = i;...// 其他代码，并未明确告诉编译器，对 i 进行过操作int b = i; volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中（内存）读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。volatile 可以保证对特殊地址的稳定访问。 123456789101112131415#include &lt;stdio.h&gt;void main()&#123; volatile int i = 10; int a = i; printf(&quot;i = %d\\n&quot;, a); __asm &#123; mov dword ptr[ebp - 4], 20h &#125; int b = i; printf(&quot;i = %d\\n&quot;, b);&#125; 一般说来，volatile用在如下的几个地方： 中断服务程序中修改的供其它程序检测的变量需要加 volatile； 多任务环境下各任务间共享的标志应该加 volatile； 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义； 可以同时用const和volatile限定一个值。例如，通常用const把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。 12volatile const int loc;const volatile int * ploc; 参考：C&#x2F;C++ 中 volatile 关键字详解 restrict类型限定符restrict 关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。 123456789101112int ar[10];int * restrict restar = (int *) malloc(10 * sizeof(int));int * par = ar;for (n = 0; n &lt; 10; n++)&#123; par[n] += 5; restar[n] += 5; ar[n] *= 2; par[n] += 3; restar[n] += 3;&#125; 由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式，编译器可以把涉及 restar的两条语句替换成下面这条语句，效果相同：restar[n] += 8; /* 可以进行替换 */ restrict 限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途。例如，C 库有两个函数用于把一个位置上的字节拷贝到另一个位置。在C99中，这两个函数的原型是： 12void * memcpy(void * restrict s1, const void * restrict s2, size_t n);void * memmove(void * s1, const void * s2, size_t n); _Atomic类型限定符（C11）并发程序设计把程序执行分成可以同时执行的多个线程。这给程序设计带来了新的挑战，包括如何管理访问相同数据的不同线程。C11通过包含可选的头文件stdatomic.h和threads.h，提供了一些可选的（不是必须实现的）管理方法。值得注意的是，要通过各种宏函数来访问原子类型。当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。 12_Atomic int hogs; // hogs 是一个原子类型的变量atomic_store(&amp;hogs, 12); // stdatomic.h中的宏 文件输入&#x2F;输出函数：fopen()、getc()、putc()、exit()、fclose()fprintf()、fscanf()、fgets()、fputs()rewind()、fseek()、ftell()、fflush()fgetpos()、fsetpos()、feof()、ferror()ungetc()、setvbuf()、fread()、fwrite() C程序把输入看作是字节流(文本流或二进制流)，输入流来源于文件、输入设备（如键盘），或者甚至是另一个程序的输出。类似地，C程序把输出也看作是字节流，输出流的目的地可以是文件、视频显示等。 与文件进行通信二进制模式和文本模式C 提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式中，程序所见的内容和文件的实际内容不同。 I&#x2F;O的级别可以选择I&#x2F;O的两个级别（即处理文件访问的两个级别）。底层I&#x2F;O（low-level I&#x2F;O）使用操作系统提供的基本I&#x2F;O服务。标准高级I&#x2F;O（standard high-level I&#x2F;O）使用C库的标准包和stdio.h头文件定义。因为无法保证所有的操作系统都使用相同的底层I&#x2F;O模型，C标准只支持标准I&#x2F;O包。有些实现会提供底层库，但是C标准建立了可移植的I&#x2F;O模型，我们主要讨论这些I&#x2F;O。 标准文件C程序会自动打开3个文件，它们被称为标准输入（standard input）、标准输出（standard output）和标准错误输出（standard error output）。在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。 通常，标准输入为程序提供输入，它是 getchar()和 scanf()使用的文件。程序通常输出到标准输出，它是putchar()、puts()和printf()使用的文件。 标准I&#x2F;O与底层I&#x2F;O相比，标准I&#x2F;O包除了可移植以外还有两个好处。第一，标准I&#x2F;O有许多专门的函数简化了处理不同I&#x2F;O的问题。例如，printf()把不同形式的数据转换成与终端相适应的字符串输出。第二，输入和输出都是缓冲的。也就是说，一次转移一大块信息而不是一字节信息（通常至少512字节）。 12345678910111213141516171819202122232425262728/* count.c -- 使用标准 I/O */#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 提供 exit()的原型int main(int argc, char* argv[])&#123; int ch;// 读取文件时，储存每个字符的地方 FILE* fp;// “文件指针” unsigned long count = 0; if (argc != 2) &#123; printf(&quot;Usage: %s filename\\n&quot;, argv[0]); exit(EXIT_FAILURE); &#125; if ((fp = fopen(argv[1], &quot;r&quot;)) == NULL) &#123; printf(&quot;Can&#x27;t open %s\\n&quot;, argv[1]); exit(EXIT_FAILURE); &#125; while ((ch = getc(fp)) != EOF) &#123; putc(ch, stdout);// 与 putchar(ch); 相同 count++; &#125; fclose(fp); printf(&quot;File %s has %lu characters\\n&quot;, argv[1], count); return 0;&#125; getc()和putc()函数12345ch = getchar(); //“从标准输入中获取一个字符”：ch = getc(fp); //“从fp指定的文件中获取一个字符”：putchar(ch); //“把字符ch放入标准输出中”：putc(ch,stdout);putc(ch, fpout); //“把字符ch放入FILE指针fpout指定的文件中”： 文件结尾getc()函数在读取一个字符时发现是文件结尾，它将返回一个特殊值EOF。 fclose()函数如果成功关闭，fclose()函数返回0，否则返回EOF： 12if (fclose(fp) != 0) printf(&quot;Error in closing file %s\\n&quot;, argv[1]); 指向标准文件的指针stdio.h头文件把3个文件指针与3个标准文件相关联，C程序会自动打开这3个标准文件。 这些文件指针都是指向FILE的指针，所以它们可用作标准I&#x2F;O函数的参数，如fclose(fp)中的fp。 一个简单的文件压缩程序问题描述：把一个文件中选定的数据拷贝到另一个文件中。该程序同时打开了两个文件，以”r”模式打开一个，以”w”模式打开另一个。以保留每3个字符中的第1个字符的方式压缩第1个文件的内容。最后，把压缩后的文本存入第2个文件。第2个文件的名称是第1个文件名加上.red后缀。 12345678910111213141516171819202122232425262728293031323334353637383940414243// reducto.c –把文件压缩成原来的1/3！#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 提供 exit()的原型#include &lt;string.h&gt;// 提供 strcpy()、strcat()的原型#define LEN 40int main(int argc, char* argv[])&#123; FILE* in, * out;// 声明两个指向 FILE 的指针 int ch; char name[LEN];// 储存输出文件名 int count = 0; // 检查命令行参数 if (argc &lt; 2) &#123; fprintf(stderr, &quot;Usage: %s filename\\n&quot;, argv[0]); exit(EXIT_FAILURE); &#125; // 设置输入 if ((in = fopen(argv[1], &quot;r&quot;)) == NULL) &#123; fprintf(stderr, &quot;I couldn&#x27;t open the file \\&quot;%s\\&quot;\\n&quot;, argv[1]); exit(EXIT_FAILURE); &#125; // 设置输出 strncpy(name, argv[1], LEN - 5);// 拷贝文件名 name[LEN - 5] = &#x27;\\0&#x27;; strcat(name, &quot;.red&quot;);// 在文件名后添加.red if ((out = fopen(name, &quot;w&quot;)) == NULL) &#123;// 以写模式打开文件 fprintf(stderr, &quot;Can&#x27;t create output file.\\n&quot;); exit(3); &#125; // 拷贝数据 while ((ch = getc(in)) != EOF) if (count++ % 3 == 0) putc(ch, out);// 打印3个字符中的第1个字符 // 收尾工作 if (fclose(in) != 0 || fclose(out) != 0) fprintf(stderr, &quot;Error in closing files\\n&quot;); return 0;&#125; 文件I&#x2F;O：fprintf()、fscanf()、fgets()和fputs()I&#x2F;O函数都类似于文件I&#x2F;O函数。它们的主要区别是，文件I&#x2F;O函数要用FILE指针指定待处理的文件。与 getc()、putc()类似，这些函数都要求用指向 FILE 的指针（如，stdout）指定一个文件，或者使用fopen()的返回值。 1234fprintf(stdout, &quot;Can&#x27;t open \\&quot;wordy\\&quot; file.\\n&quot;);fprintf(fp, &quot;%s\\n&quot;, words);while (fscanf(fp, &quot;%s&quot;, words) == 1) puts(words); fgets(buf, STLEN, fp);输入函数，读操作，buf是char类型数组的名称，STLEN是字符串的大小，fp是指向FILE的指针。 fputs(buf, fp);输出函数，写操作，这里，buf是字符串的地址，fp用于指定目标文件。 ch &#x3D; getc(fp); &#x2F;&#x2F;输入流→输入缓冲区putchar(ch);putc(ch,stdout); &#x2F;&#x2F;输出缓冲区→输出流 随机访问：fseek()和ftell()有了 fseek()函数，便可把文件看作是数组，在 fopen()打开的文件中直接移动到任意字节处。 fseek(fp, offset, SEEK_MODE); fseek()的第1个参数是FILE指针，指向待查找的文件，fopen()应该已打开该文件。 fseek()的第2个参数是偏移量（offset）。该参数表示从起始点开始要移动的距离（参见表13.3列出的起始点模式）。该参数必须是一个long类型的值，可以为正（前移）、负（后移）或0（保持不动） fseek()的第3个参数是模式，该参数确定起始点。 如果一切正常，fseek()的返回值为0；如果出现错误（如试图移动的距离超出文件的范围），其返回值为-1。 12345fseek(fp, 0L, SEEK_SET); // 定位至文件开始处fseek(fp, 10L, SEEK_SET); // 定位至文件中的第10个字节fseek(fp, 2L, SEEK_CUR); // 从文件当前位置前移2个字节fseek(fp, 0L, SEEK_END); // 定位至文件结尾fseek(fp, -10L, SEEK_END); // 从文件结尾处回退10个字节 example: 1234567fseek(fp, 0L, SEEK_END); // 把当前位置设置为距文件末尾 0 字节偏移量。long last = ftell(fp); // 把从文件开始处到文件结尾的字节数赋给last。for (count = 1L; count &lt;= last; count++)&#123; fseek(fp, -count, SEEK_END); /* go backward */ ch = getc(fp); // 从后往前输出字符到fp&#125; fgetpos()和fsetpos()函数ANSI C新增了两个处理较大文件的新定位函数：fgetpos()和 fsetpos()。这两个函数不使用 long 类型的值表示位置，它们使用一种新类型：fpos_t（代表file, position, type，文件定位类型）。fpos_t类型不是基本类型，它根据其他类型来定义。 int fgetpos(FILE * restrict stream, fpos_t * restrict pos); 调用该函数时，它把fpos_t类型的值放在pos指向的位置上，该值描述了文件中的一个位置。如果成功，fgetpos()函数返回0；如果失败，返回非0。 int fsetpos(FILE *stream, const fpos_t *pos); 调用该函数时，使用pos指向位置上的fpos_t类型值来设置文件指针指向该值指定的位置。如果成功，fsetpos()函数返回0；如果失败，则返回非0。fpos_t类型的值应通过之前调用fgetpos()获得。 标准I&#x2F;O的机理调用fopen()打开文件fopen()函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen()返回一个指向该结构的指针，以便其他函数知道如何找到该结构。 文件输入：调用fscanf()、getc()或 fgets()将输入流拷贝到输入缓冲区调用这些函数，文件中的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而异，一般是512字节或是它的倍数，如4096。最初调用函数，除了填充缓冲区外，还要设置fp所指向的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从字节0开始。 当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中。 文件输出：调用fprinf()、putc()或 fputs()将输出缓冲区拷贝到输出流输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。 ungetc()、fllush()、setvbuf()函数int ungetc()函数把c指定的字符放回输入流中。如果把一个字符放回输入流，下次调用标准输入函数时将读取该字符。 int ungetc(int c, FILE *fp); int fflush(FILE *fp); 调用fflush()函数引起输出缓冲区中所有的未写入数据被发送到fp指定的输出文件。这个过程称为刷新缓冲区。只要最近一次操作不是输入操作，就可以用该函数来更新流（任何读写模式）。 int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size); setvbuf()函数创建了一个供标准I&#x2F;O函数替换使用的缓冲区。在打开文件后且未对流进行其他操作之前，调用该函数。 假设一个程序要储存一种数据对象，每个数据对象的大小是3000字节。可以使用setvbuf()函数创建一个缓冲区，其大小是该数据对象大小的倍数。 二进制I&#x2F;O：fread()和fwrite()为什么需要用二进制文件存储？之前用到的标准I&#x2F;O函数都是面向文本的，用于处理字符和字符串。如何要在文件中保存数值数据？用 fprintf()函数和%f转换说明只是把数值保存为字符串。例如： 12double num = 1./3.;fprintf(fp,&quot;%f&quot;, num); 把num储存为8个字符：0.333333。 为保证数值在储存前后一致，最精确的做法是使用与计算机相同的位组合来储存。因此，double 类型的值应该储存在一个 double 大小的单元中。如果以程序所用的表示法把数据储存在文件中，则称以二进制形式储存数据。这样就不存在从数值形式到字符串的转换过程。 实际上，所有的数据都是以二进制形式储存的，甚至连字符都以字符码的二进制表示来储存。如果文件中的所有数据都被解释成字符码，则称该文件包含文本数据。如果部分或所有的数据都被解释成二进制形式的数值数据，则称该文件包含二进制数据（另外，用数据表示机器语言指令的文件都是二进制文件） fwrite()函数size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp); fwrite()函数把二进制数据写入文件。fwrite()函数返回成功写入项的数量。正常情况下，该返回值就是nmemb，但如果出现写入错误，返回值会比nmemb小。 1234char buffer[256];fwrite(buffer, 256, 1, fp);double earnings[10];fwrite(earnings, sizeof(double), 10, fp); fwrite()原型中的const void * restrict ptr声明。fwrite()的一个问题是，它的第1个参数不是固定的类型。例如，第1个例子中使用buffer，其类型是指向char的指针；而第2个例子中使用earnings，其类型是指向double的指针。在ANSI C函数原型中，这些实际参数都被转换成指向void的指针类型，这种指针可作为一种通用类型指针（在ANSI C之前，这些参数使用char*类型，需要把实参强制转换成char *类型）。 fread()函数size_t fread(void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp); fwrite()函数把文件中的二进制数据读入数据指针。ffread()函数返回成功读取项的数量。正常情况下，该返回值就是nmemb，但如果出现读取错误或读到文件结尾，该返回值就会比nmemb小。 12double earnings[10];fread(earnings, sizeof (double), 10, fp); // 该调用把10个double大小的值拷贝进earnings数组中 如果标准输入函数返回 EOF，则通常表明函数已到达文件结尾。然而，出现读取错误时，函数也会返回EOF。feof()和ferror()函数用于区分这两种情况。当上一次输入调用检测到文件结尾时，feof()函数返回一个非零值，否则返回0。当读或写出现错误，ferror()函数返回一个非零值，否则返回0。 程序：使用fread()和fwrite()函数进行拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* append.c -- 把文件附加到另一个文件末尾 */#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUFSIZE 4096#define SLEN 81void append(FILE* source, FILE* dest);char* s_gets(char* st, int n);int main(void)&#123; FILE* fa, * fs;// fa 指向目标文件，fs 指向源文件 int files = 0;// 附加的文件数量 char file_app[SLEN];// 目标文件名 char file_src[SLEN];// 源文件名 int ch; puts(&quot;Enter name of destination file:&quot;); s_gets(file_app, SLEN); if ((fa = fopen(file_app, &quot;a+&quot;)) == NULL) &#123; fprintf(stderr, &quot;Can&#x27;t open %s\\n&quot;, file_app); exit(EXIT_FAILURE); &#125; if (setvbuf(fa, NULL, _IOFBF, BUFSIZE) != 0) &#123; fputs(&quot;Can&#x27;t create output buffer\\n&quot;, stderr); exit(EXIT_FAILURE); &#125; puts(&quot;Enter name of first source file (empty line to quit):&quot;); while (s_gets(file_src, SLEN) &amp;&amp; file_src[0] != &#x27;\\0&#x27;) &#123; if (strcmp(file_src, file_app) == 0) fputs(&quot;Can&#x27;t append file to itself\\n&quot;, stderr); else if ((fs = fopen(file_src, &quot;r&quot;)) == NULL) fprintf(stderr, &quot;Can&#x27;t open %s\\n&quot;, file_src); else &#123; if (setvbuf(fs, NULL, _IOFBF, BUFSIZE) != 0) &#123; fputs(&quot;Can&#x27;t create input buffer\\n&quot;, stderr); continue; &#125; append(fs, fa); if (ferror(fs) != 0) fprintf(stderr, &quot;Error in reading file %s.\\n&quot;, file_src); if (ferror(fa) != 0) fprintf(stderr, &quot;Error in writing file %s.\\n&quot;, file_app); fclose(fs); files++; printf(&quot;File %s appended.\\n&quot;, file_src); puts(&quot;Next file (empty line to quit):&quot;); &#125; &#125; printf(&quot;Done appending.%d files appended.\\n&quot;, files); rewind(fa); printf(&quot;%s contents:\\n&quot;, file_app); while ((ch = getc(fa)) != EOF) putchar(ch); puts(&quot;Done displaying.&quot;); fclose(fa); return 0;&#125;void append(FILE* source, FILE* dest)&#123; size_t bytes; static char temp[BUFSIZE]; // 只分配一次 while ((bytes = fread(temp, sizeof(char), BUFSIZE, source)) &gt; 0) fwrite(temp, sizeof(char), bytes, dest);&#125;char* s_gets(char* st, int n)&#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;);// 查找换行符 if (find)// 如果地址不是NULL， *find = &#x27;\\0&#x27;;// 在此处放置一个空字符 else while (getchar() != &#x27;\\n&#x27;) continue; &#125; return ret_val;&#125; 程序：用二进制I&#x2F;O进行随机访问12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* randbin.c -- 用二进制I/O进行随机访问 */#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ARSIZE 1000int main()&#123; double numbers[ARSIZE]; double value; const char* file = &quot;numbers.dat&quot;; int i; long pos; FILE* iofile; // 创建一组 double类型的值 for (i = 0; i &lt; ARSIZE; i++) numbers[i] = 100.0 * i + 1.0 / (i + 1); // 尝试打开文件 if ((iofile = fopen(file, &quot;wb&quot;)) == NULL) &#123; fprintf(stderr, &quot;Could not open %s for output.\\n&quot;, file); exit(EXIT_FAILURE); &#125; // 以二进制格式把数组写入文件 fwrite(numbers, sizeof(double), ARSIZE, iofile); fclose(iofile); if ((iofile = fopen(file, &quot;rb&quot;)) == NULL) &#123; fprintf(stderr, &quot;Could not open %s for random access.\\n&quot;, file); exit(EXIT_FAILURE); &#125; // 从文件中读取选定的内容 printf(&quot;Enter an index in the range 0-%d.\\n&quot;, ARSIZE - 1); while (scanf(&quot;%d&quot;, &amp;i) == 1 &amp;&amp; i &gt;= 0 &amp;&amp; i &lt; ARSIZE) &#123; pos = (long)i * sizeof(double);// 计算偏移量 fseek(iofile, pos, SEEK_SET);// 定位到此处 fread(&amp;value, sizeof(double), 1, iofile); printf(&quot;The value there is %f.\\n&quot;, value); printf(&quot;Next index (out of range to quit):\\n&quot;); &#125; // 完成 fclose(iofile); puts(&quot;Bye!&quot;); return 0;&#125; 结构和其他数据形式关键字：struct、union、typedef运算符：.和-&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344//* book.c -- 一本书的图书目录 */#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;string.h&gt;char* s_gets(char* st, int n);#define MAXTITL 41/* 书名的最大长度 + 1*/#define MAXAUTL 31/* 作者姓名的最大长度 + 1*/struct book &#123;/* 结构模版：标记是 book */ char title[MAXTITL]; char author[MAXAUTL]; float value;&#125;;/* 结构模版结束*/int main(void)&#123; struct book library;/* 把 library 声明为一个 book 类型的变量 */ printf(&quot;Please enter the book title.\\n&quot;); s_gets(library.title, MAXTITL);/* 访问title部分*/ printf(&quot;Now enter the author.\\n&quot;); s_gets(library.author, MAXAUTL); printf(&quot;Now enter the value.\\n&quot;); scanf(&quot;%f&quot;, &amp;library.value); printf(&quot;%s by %s: $%.2f\\n&quot;, library.title, library.author, library.value); printf(&quot;%s: \\&quot;%s\\&quot; ($%.2f)\\n&quot;, library.author, library.title, library.value); printf(&quot;Done.\\n&quot;); return 0;&#125;char* s_gets(char* st, int n)&#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;);// 查找换行符 if (find)// 如果地址不是 NULL, *find = &#x27;\\0&#x27;;// 在此处放置一个空字符 else while (getchar() != &#x27;\\n&#x27;) continue;//处理输入行中剩余的字符 &#125; return ret_val;&#125; C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。参考：C 库函数 - fgets() 定义结构变量初始化结构初始化变量和数组如下： 12int count = 0;int fibo[7] = &#123;0,1,1,2,3,5,8&#125;; 结构变量是否也可以这样初始化？是的，可以。初始化一个结构变量与初始化数组的语法类似： 12345678910struct book &#123;/* 结构模版：标记是 book */ char title[MAXTITL]; char author[MAXAUTL]; float value;&#125;;/* 结构模版结束*/struct book library = &#123;&quot;The Pious Pirate and the Devious Damsel&quot;,&quot;Renee Vivotte&quot;,1.95&#125;; 访问结构成员1234struct book bill;printf(&quot;%f\\n&quot;,bill.value);struct book *newt;printf(&quot;%f\\n&quot;,bill-&gt;value); 其他结构特性1234o_data = n_data; // 把一个结构赋值给另一个结构struct names right_field = &#123;&quot;Ruthie&quot;, &quot;George&quot;&#125;;struct names captain = right_field; // 把一个结构初始化为另一个结构 结构中的字符数组和字符指针 1234567891011121314151617#define LEN 20struct names &#123;char first[LEN];char last[LEN];&#125;;struct pnames &#123;char * first;char * last;&#125;;struct names veep = &#123;&quot;Talia&quot;, &quot;Summers&quot;&#125;;struct pnames treas = &#123;&quot;Brad&quot;, &quot;Fallingjaw&quot;&#125;;printf(&quot;%s and %s\\n&quot;, veep.first, treas.first);struct pnames attorney;scanf(&quot;%s&quot;, attorney.last); /* 这里有一个潜在的危险 */ 对于struct names类型的结构变量veep，以上字符串都储存在结构内部，结构总共要分配40字节储存姓名。然而，对于struct pnames类型的结构变量treas，以上字符串储存在编译器储存常量的地方。结构本身只储存了两个地址，在我们的系统中共占16字节（一个指针在64位的计算机上，占8个字节；一个指针在32位的计算机上，占4个字节）。如果要用结构储存字符串，用字符数组作为成员比较简单。用指向 char 的指针也行，但是误用会导致严重的问题。 如果使用malloc()分配内存并使用指针储存该地址，那么在结构中使用指针处理字符串就比较合理。 1234567891011121314151617181920212223242526struct namect &#123; char * fname; // 用指针代替数组 char * lname; int letters;&#125;;void getinfo (struct namect * pst)&#123; char temp[SLEN]; printf(&quot;Please enter your first name.\\n&quot;); s_gets(temp, SLEN); // 分配内存储存名 pst-&gt;fname = (char *) malloc(strlen(temp) + 1); // 把名拷贝到已分配的内存 strcpy(pst-&gt;fname, temp); printf(&quot;Please enter your last name.\\n&quot;); s_gets(temp, SLEN); pst-&gt;lname = (char *) malloc(strlen(temp) + 1); strcpy(pst-&gt;lname, temp);&#125;void cleanup(struct namect * pst)&#123; free(pst-&gt;fname); free(pst-&gt;lname);&#125; 复合字面量1(struct book) &#123;&quot;The Idiot&quot;, &quot;Fyodor Dostoyevsky&quot;, 6.99&#125; 伸缩型数组成员（flexible array member）利用这项特性声明的结构，其最后一个数组成员具有一些特性。第1个特性是，该数组不会立即存在。第2个特性是，使用这个伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样。 12345678910struct flex&#123;int count;double average;double scores[]; // 伸缩型数组成员&#125;;struct flex * pf; // 声明一个指针// 请求为一个结构和一个数组分配存储空间pf = malloc(sizeof(struct flex) + 5 * sizeof(double)); 带伸缩型数组成员的结构确实有一些特殊的处理要求。第一，不能用结构进行赋值或拷贝： *pf2 = *pf1; // 不要这样做 这样做只能拷贝除伸缩型数组成员以外的其他成员。确实要进行拷贝，应使用memcpy()函数。 第二，不要以按值方式把这种结构传递给结构。原因相同，按值传递一个参数与赋值类似。要把结构的地址传递给函数。第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员。 匿名结构（C11）12345678struct person&#123; int id; struct &#123;char first[20]; char last[20];&#125;; // 匿名结构&#125;;struct person ted = &#123;8483, &#123;&quot;Ted&quot;, &quot;Grass&quot;&#125;&#125;;puts(ted.first); 把结构内容保存到文件中储存记录最没效率的方法是用fprintf() fprintf(pbooks, &quot;%s %s %.2f\\n&quot;, primer.title,primer.author, primer.value); 更好的方案是使用fread()和fwrite()函数读写结构大小的单元。这两个函数使用与程序相同的二进制表示法。 fwrite(&amp;primer, sizeof(struct book), 1, pbooks); 缺点移植性较差。以二进制表示法储存数据的缺点是，不同的系统可能使用不同的二进制表示法，所以数据文件可能不具可移植性。甚至同一个系统，不同编译器设置也可能导致不同的二进制布局。 联合简介联合（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。 根据以下形式声明的结构可以储存一个int类型、一个double类型和char类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的值或char类型的值。 声明时，编译器分配足够的空间以便它能储存联合声明中占用最大字节的类型。其中double类型占64位，即8字节。 1234567891011121314151617181920212223//联合定义union hold &#123; int digit; double bigfl; char letter;&#125;;//联合声明union hold fit; // hold类型的联合变量union hold save[10]; // 内含10个联合变量的数组union hold * pu; // 指向hold类型联合变量的指针//联合初始化union hold valA;valA.letter = &#x27;R&#x27;;union hold valB = valA; // 用另一个联合来初始化union hold valC = &#123;88&#125;; // 初始化联合的digit 成员union hold valD = &#123;.bigfl = 118.2&#125;; // 指定初始化器//联合使用fit.digit = 23; //把 23 储存在 fit，占2字节fit.bigfl = 2.0; // 清除23，储存 2.0，占8字节fit.letter = &#x27;h&#x27;; // 清除2.0，储存h，占1字节 匿名联合（C11）匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的无名联合成员。 1234567891011121314151617181920struct owner &#123; char socsecurity[12]; ...&#125;;struct leasecompany &#123; char name[40]; char headquarters[40];...&#125;;struct car_data &#123; char make[15]; int status; /* 私有为0，租赁为1 */ union &#123; struct owner owncar; struct leasecompany leasecar; &#125;;...&#125;; 如果flits是car_data类型的结构变量，通过以下方式访问 flits.owncar.socsecurity 枚举类型可以用枚举类型（enumerated type）声明符号名称来表示整型常量。使用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如，可以这样声明： 123456789enum spectrum &#123;red, orange, yellow, green, blue, violet&#125;; //0~5enum spectrum color;int c;color = blue;if (color == yellow)...;for (color = red; color &lt;= violet; color++)...; C枚举的一些特性并不适用于C++。例如，C允许枚举变量使用++运算符，但是C++标准不允许。 赋值12enum levels &#123;low = 100, medium = 500, high = 2000&#125;;enum feline &#123;cat, lynx = 10, puma, tiger&#125;; //cat = 0; lynx = 10, puma = 11, tiger = 12 枚举类型的目的是为了提高程序的可读性和可维护性。 因为枚举类型是整数类型，所以可以在表达式中以使用整数变量的方式使用enum变量。它们用在case语句中很方便。 共享名称空间C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来识别。作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲突；两个相同作用域的同名变量冲突。 在特定作用域中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称空间与普通变量使用的空间不同。这意味着在相同作用域中变量和标记的名称可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。 12struct rect &#123; double x; double y; &#125;;int rect; // 在C中不会产生冲突 尽管如此，以两种不同的方式使用相同的标识符会造成混乱。另外，C++不允许这样做，因为它把标记名和变量名放在相同的名称空间中。 typedef简介利用typedef可以为某一类型自定义名称。这方面与#define类似，但是两者有3处不同： 与#define不同，typedef创建的符号名只受限于类型，不能用于值。 typedef由编译器解释，不是预处理器。 在其受限范围内，typedef比#define更灵活。 12345678910111213typedef unsigned char BYTE;BYTE x, y[10], * z;typedef char * STRING;STRING name, sign;typedef struct complex &#123;float real;float imag;&#125; COMPLEX;//然后便可使用COMPLEX类型代替complex结构来表示复数。typedef struct &#123;double x; double y;&#125; rect; 使用typedef的第1个原因是：为经常出现的类型创建一个方便、易识别的类型名。 使用typedef的第2个原因是：typedef常用于给复杂的类型命名。 通过结构、联合和typedef，C提供了有效处理数据的工具和处理可移植数据的工具。 其他复杂的声明1234567int board[8][8]; // 声明一个内含int数组的数组int ** ptr; // 声明一个指向指针的指针，被指向的指针指向intint * risks[10]; // 声明一个内含10个元素的数组，每个元素都是一个指向int的指针int (* rusks)[10]; // 声明一个指向数组的指针，该数组内含10个int类型的值int * oof[3][4]; // 声明一个3×4 的二维数组，每个元素都是指向int的指针int (* uuf)[3][4]; // 声明一个指向3×4二维数组的指针，该数组中内含int类型值int (* uof[3])[4]; // 声明一个内含3个指针元素的数组，其中每个指针都指向一个内含4个int类型元素的数组 数组名后面的[]和函数名后面的()具有相同的优先级。它们比*（解引用运算符）的优先级高。 []和()的优先级相同，且都是从左往右结合 函数和指针123void ToUpper(char *); // 把字符串中的字符转换成大写字符void (*pf)(char *); // (*pf)是一个参数列表为(char *)、返回类型为void的函数。void *pf(char *); // pf 是一个返回字符指针的函数 12345678void ToUpper(char *);void ToLower(char *);int round(double);void (*pf)(char *);pf = ToUpper; // 有效，ToUpper是该类型函数的地址pf = ToLower; //有效，ToUpper是该类型函数的地址pf = round; // 无效，round与指针类型不匹配pf = ToLower(); // 无效，ToLower()不是地址 12345678void ToUpper(char *);void ToLower(char *);void (*pf)(char *);char mis[] = &quot;Nina Metier&quot;;pf = ToUpper;(*pf)(mis); // 把ToUpper 作用于（语法1），相当于ToUpper(mis)pf = ToLower;pf(mis); // 把ToLower 作用于（语法2） 位操作运算符：～、&amp;、|、^、&lt;&lt;、&gt;&gt;&amp;&#x3D;、|&#x3D;、^&#x3D;、&gt;&gt;&#x3D;、&lt;&lt;&#x3D; 处理一个值中的位的两个C工具：位运算符和位字段 关键字：_Alignas、_Alignof 按位运算符逻辑运算符、移位运算符 按位逻辑运算符 二进制反码或按位取反：~ 1newval = ~val; 按位与：&amp;（1&amp;1&#x3D;1，其余为0） 12val &amp;= 0377;val = val &amp; 0377; 按位或： |（0|0&#x3D;0，其余为1） 12val |= 0377;val = val | 0377; 按位异或：^（0^1&#x3D;1; 1^0&#x3D;1） 12val ^= 0377;val = val ^ 0377; 用法：掩码&amp;按位与（&amp;）运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合。 例如，假设定义符号常量MASK为2 （即，二进制形式为00000010）, 1234flags = flags &amp; MASK; //把flags中除1号位以外的所有位都设置为0（值小于MASK、flags）flags &amp;= MASK;ch &amp;= 0xff; /* 或者 ch &amp;= 0377; oxff的二进制形式是11111111，八进制形式是0377。*/ 把掩码中的0看作不透明，1看作透明。表达式flags&amp;MASK相当于用掩码覆盖在flags的位组合上，只有MASK为1的位才可见。 用法：打开位（设置位）|有时，需要打开一个值中的特定位，同时保持其他位不变。例如，一台IBM PC 通过向端口发送值来控制硬件。例如，为了打开内置扬声器，必须打开 1 号位，同时保持其他位不变。这种情况可以使用按位或运算符（|）。 12flags = flags | MASK; //把flags的1号位设置为1，且其他位不变。（值大于MASK、flags）flags |= MASK; 用法：关闭位（清空位）&amp;~和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的位。假设要关闭变量flags中的1号位。同样，MASK只有1号位为1（即，打开）。可以这样做： 1flags = flags &amp; ~MASK; 例如：假设flags是00001111，MASK是10110110。~MASK&#x3D;01001001，flags &amp; ~MASK = 00001001 用法：切换位^切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或运算符（^）切换位。 如果使用^组合一个值和一个掩码，将切换该值与MASK为1的位相对应的位，该值与MASK为0的位相对应的位不变。 12flags = flags ^ MASK;flags ^= MASK; 例如：(00001111) ^ (10110110) &#x2F;&#x2F; 表达式其结果为：(10111001) &#x2F;&#x2F; 结果值 用法：检查位的值有时，需要检查某位的值。例如，flags中1号位是否被设置为1？ 12if ((flags &amp; MASK) == MASK) puts(&quot;Wow!&quot;); 位移运算符左移：&lt;&lt;左移运算符（&lt;&lt;）将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。左侧运算对象移出左末端位的值丢失，用0填充空出的位置。 1000 1000&lt;&lt;1 &#x3D; 0010 000 12345int stonk = 1;int onkoo;onkoo = stonk &lt;&lt; 2; /* 把4赋给onkoo */stonk &lt;&lt;= 2; /* 把stonk的值改为4 * 右移：&gt;&gt;右移运算符（&gt;&gt;）将其左侧运算对象每一位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢。对于无符号类型，用0填充空出的位置；对于有符号类型，其结果取决于机器（空出的位置可用0填充，或者用符号位的副本填充）。 下面是有符号值的例子：(10001010) &gt;&gt; 2 &#x2F;&#x2F; 表达式，有符号值(00100010) &#x2F;&#x2F; 在某些系统中的结果值(10001010) &gt;&gt; 2 &#x2F;&#x2F; 表达式，有符号值(11100010) &#x2F;&#x2F; 在另一些系统上的结果值 下面是无符号值的例子：(10001010) &gt;&gt; 2 &#x2F;&#x2F; 表达式，无符号值(00100010) &#x2F;&#x2F; 所有系统都得到该结果值 1234int sweet = 16;int ooosw;ooosw = sweet &gt;&gt; 3; // ooosw = 2，sweet的值仍然为16sweet &gt;&gt;=3; // sweet的值为2 用法：移位运算符移位运算符针对2的幂提供快速有效的乘法和除法：number &lt;&lt; n number乘以2的n次幂number &gt;&gt; n 如果number为非负，则用number除以2的n次幂 位字段操控位的第2种方法是位字段（bit field）。位字段是一个signed int或unsigned int类型变量中的一组相邻的位（C99和C11新增了**_Bool类型**的位字段）。位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度。 1234567891011121314151617181920struct &#123; unsigned int autfd : 1; unsigned int bldfc : 1; unsigned int undln : 1; unsigned int itals : 1;&#125; prnt;prnt.itals = 0;prnt.undln = 1;//多位struct &#123; unsigned int code1 : 2; unsigned int code2 : 2; unsigned int code3 : 8; //8位&#125; prcode;prcode.code1 = 0;prcode.code2 = 3;prcode.code3 = 102; 如果声明的总位数超过了一个unsigned int类型的大小会怎样？ 会用到下一个unsigned int类型的存储位置。一个字段不允许跨越两个unsigned int之间的边界。编译器会自动移动跨界的字段，保持unsigned int的边界对齐。一旦发生这种情况，第1个unsigned int中会留下一个未命名的“洞”。 1234567struct &#123; unsigned int field1 : 1; unsigned int : 2; unsigned int field2 : 1; unsigned int : 0; unsigned int field3 : 1; &#125; stuff; 这里，在stuff.field1和stuff.field2之间，有一个2位的空隙；stuff.field3将储存在下一个unsigned int中。 位字段示例我们假设方框具有如下属性：方框是透明的或不透明的；方框的填充色选自以下调色板：黑色、红色、绿色、黄色、蓝色、紫色、青色或白色；边框可见或隐藏；边框颜色与填充色使用相同的调色板；边框可以使用实线、点线或虚线样式。 12345678910#include &lt;stdbool.h&gt;struct box_props &#123; bool opaque : 1; unsigned int fill_color : 3; unsigned int : 4; bool show_border : 1; unsigned int border_color : 3; unsigned int border_style : 2; unsigned int : 2; &#125;; 加上未命名的字段，该结构共占用 16 位。如果不使用填充，该结构占用 10 位。C语言以unsigned int作为位字段结构的基本布局单元。（unsigned int是32位） 对齐特性（C11）C11 的对齐特性比用位填充字节更自然，它们还代表了C在处理硬件相关问题上的能力。在这种上下文中，对齐指的是如何安排对象在内存中的位置。 例如，把数据从一个硬件位置转移到另一个位置，或者调用指令同时操作多个数据项。 _Alignof运算符给出一个类型的对齐要求，在关键字_Alignof后面的圆括号中写上类型名即可： 12345size_t d_align = _Alignof(float);_Alignas(double) char c1;_Alignas(8) char c2;unsigned char _Alignas(long double) c_arr[sizeof(long double)]; 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdalign.h&gt;int main(void)&#123; double dx; char ca; char cx; double dz; char cb; char _Alignas(double) cz; printf(&quot;char alignment:%zd\\n&quot;, _Alignof(char)); printf(&quot;double alignment: %zd\\n&quot;, _Alignof(double)); printf(&quot;&amp;dx: %p\\n&quot;, &amp;dx); printf(&quot;&amp;ca: %p\\n&quot;, &amp;ca); printf(&quot;&amp;cx: %p\\n&quot;, &amp;cx); printf(&quot;&amp;dz: %p\\n&quot;, &amp;dz); printf(&quot;&amp;cb: %p\\n&quot;, &amp;cb); printf(&quot;&amp;cz: %p\\n&quot;, &amp;cz); return 0;&#125; C11在stdlib.h库还添加了一个新的内存分配函数，用于对齐动态分配的内存。该函数的原型如下：void *aligned_alloc(size_t alignment, size_t size);第1个参数代表指定的对齐，第2个参数是所需的字节数，其值应是第1个参数的倍数。与其他内存分配函数一样，要使用free()函数释放之前分配的内存。 C预处理器和C库预处理指令：#define、#include、#ifdef、#else、#endif、#ifndef、#if、#elif、#line、#error、#pragma关键字：_Generic、_Noreturn、_Static_assert函数&#x2F;宏：sqrt()、atan()、atan2()、exit()、atexit()、assert()、memcpy()、memmove()、va_start()、va_arg()、va_copy()、va_end() C语言建立在适当的关键字、表达式、语句以及使用它们的规则上。然而，C标准不仅描述C语言，还描述如何执行C预处理器、C标准库有哪些函数，以及详述这些函数的工作原理。 GCC预处理——编译——汇编——链接 使用C语编写test程序的源代码文件test.c过程： 首先进入GCC的预编译器进行预处理，对头文件、宏定义等进行展开，生成test.i文件；然后进入GCC的编译器，编译完生成汇编程序test.s；然后调用汇编器进行汇编，生成可重定位的目标程序test.o；最后调用链接器，将所有目标文件和C语言库链接成可执行的二进制文件。 预处理器C预处理器在程序执行之前查看程序。根据程序中的预处理器指令，预处理器把符号缩写替换成其表示的内容。 翻译程序的第一步在预处理之前，编译器必须对该程序进行一些翻译处理。 Step1: 编译器把源代码中出现的字符映射到源字符集。该过程处理多字节字符集或Unicode字符集——字符扩展让C更加国际化（要在编译器中设置相关选项才能激活这个特性） Step2: 编译器定位每个反斜杠后面跟着换行符的实例，并删除它们。也就是说，把下面两个物理行（physical line）： 12printf(&quot;That&#x27;s wond\\erful!\\n&quot;); 将变成： 1printf(&quot;That&#x27;s wonderful\\n!&quot;); Step3: 编译器把文本划分成预处理记号序列、空白序列和注释序列。编译器将用一个空格字符替换每一条注释。 1int/* 这看起来并不像一个空格*/fox; 将变成： 1int fox; 最后，程序已经准备好进入预处理阶段，预处理器查找一行中以#号开始的预处理指令。 明示常量：#define 12345678#define TWO 2 /* 可以使用注释 */int main(void)&#123; int t = TWO; return 0;&#125; 将变为： 12345int main(void)&#123; int t = 2; return 0;&#125; 记号从技术角度来看，可以把宏的替换体看作是记号（token）型字符串，而不是字符型字符串。 重定义常量假设先把LIMIT定义为20，稍后在该文件中又把它定义为25。这个过程称为重定义常量。 如果需要重定义宏，使用#undef 指令（稍后讨论）。 如果确实需要重定义常量，使用const关键字和作用域规则更容易些。 在#define中使用参数12#define SQUARE(X) X*X#define PR(X) printf(&quot;The result is %d.\\n&quot;, X) 预处理器黏合剂：##运算符123456789#include &lt;stdio.h&gt;#define XNAME(n) x ## nint main(void)&#123; int XNAME(1) = 14; //将变成int x1 = 14; printf(&quot;%d&quot;, x1); return 0;&#125; 变参宏：…和__VA_ARGS__一些函数（如 printf()）接受数量可变的参数。stdvar.h 头文件提供了工具，让用户自定义带可变参数的函数。C99&#x2F;C11也对宏提供了这样的工具。 通过把宏参数列表中最后的参数写成省略号（...）来实现这一功能。这样，预定义宏__VA_ARGS__可用在替换部分中，表明省略号代表什么。 1234#define PR(...) printf(_ _VA_ARGS_ _)PR(&quot;Howdy&quot;);PR(&quot;weight = %d, shipping = $%.2f\\n&quot;, wt, sp); 程序： 123456789101112#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define PR(X, ...) printf(&quot;Message &quot; #X &quot;: &quot; __VA_ARGS__)int main(void)&#123; double x = 48; double y; y = sqrt(x); PR(1, &quot;x = %g\\n&quot;, x); PR(2, &quot;x = %.2f, y = %.4f\\n&quot;, x, y); return 0;&#125; 宏和函数的选择宏的一个优点是，不用担心变量类型 123#define MAX(X,Y) ((X) &gt; (Y) ? (X) : (Y))#define ABS(X) ((X) &lt; 0 ? -(X) : (X))#define ISSIGN(X) ((X) == &#x27;+&#x27; || (X) == &#x27;-&#x27; ? 1 : 0) 文件包含：#include当预处理器发现#include 指令时，会查看后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的#include指令。 这相当于把被包含文件的全部内容输入到源文件#include指令所在的位置。#include指令有两种形式：#include &lt;stdio.h&gt; ←查找系统目录#include &quot;hot.h&quot; ←查找当前工作目录#include &quot;/usr/biff/p.h&quot; ←查找&#x2F;usr&#x2F;biff目录 头文件中最常用的形式如下。 明示常量——例如，stdio.h中定义的EOF、NULL和BUFSIZE（标准I&#x2F;O缓冲区大小）。 宏函数——例如，getc(stdin)通常用getchar()定义，而getc()经常用于定义较复杂的宏，头文件ctype.h通常包含ctype系列函数的宏定义。 函数声明——例如，string.h头文件（一些旧的系统中是strings.h）包含字符串函数系列的函数声明。在ANSI C和后面的标准中，函数声明都是函数原型形式。 结构模版定义——标准I&#x2F;O函数使用FILE结构，该结构中包含了文件和与文件缓冲区相关的信息。FILE结构在头文件stdio.h中。 类型定义——标准 I&#x2F;O 函数使用指向 FILE 的指针作为参数。通常，stdio.h 用#define 或typedef把FILE定义为指向结构的指针。类似地，size_t和time_t类型也定义在头文件中。 外部变量——还可以使用头文件声明外部变量供其他文件共享。 其他指令程序员可能要为不同的工作环境准备C程序和C库包。不同的环境可能使用不同的代码类型。预处理器提供一些指令，程序员通过修改#define的值即可生成可移植的代码。#undef指令取消之前的#define定义。#if、#ifdef、#ifndef、#else、#elif和#endif指令用于指定什么情况下编写哪些代码。#line指令用于重置行和文件信息，#error指令用于给出错误消息，#pragma指令用于向编译器发出指令。 #undef指令#undef指令用于“取消”已定义的#define指令。 1234#define LIMIT 400......#undef LIMIT 从C预处理器角度看已定义 当预处理器在预处理器指令中发现一个标识符时，它会把该标识符当作已定义的或未定义的。 12345#define LIMIT 1000 // LIMIT是已定义的#define GOOD // GOOD 是已定义的#define A(X) ((-(X))*(X)) // A 是已定义的int q; // q 不是宏，因此是未定义的#undef GOOD // GOOD 取消定义，是未定义的 条件编译可以使用其他指令创建条件编译（conditinal compilation）。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息（或代码）块。 #ifdef、#else和#endif指令 1234567#ifdef MAVIS #include &quot;horse.h&quot; // 如果已经用#define定义了 MAVIS，则执行下面的指令 #define STABLES 5#else #include &quot;cow.h&quot; //如果没有用#define定义 MAVIS，则执行下面的指令 #define STABLES 15#endif #ifndef指令 #ifndef指令通常用于防止多次包含一个文件。 12345// arrays.h文件#ifndef SIZE #define SIZE 100#endif...... 123// main.c文件#define SIZE 10#include &quot;arrays.h&quot; SIZE则被设置为10。这里，当执行到#include “arrays.h”这行，处理array.h中的代码时，由于SIZE是已定义的，所以跳过了#define SIZE 100这行代码。 预定义宏 C99 标准提供一个名为__func__的预定义标识符，它展开为一个代表函数名的字符串（该函数包含该标识符）。 12345678910111213141516171819// predef.c -- 预定义宏和预定义标识符#include &lt;stdio.h&gt;void why_me();int main()&#123; printf(&quot;The file is %s.\\n&quot;, __FILE__); printf(&quot;The date is %s.\\n&quot;, __DATE__); printf(&quot;The time is %s.\\n&quot;, __TIME__); printf(&quot;The version is %ld.\\n&quot;,__STDC_VERSION__); printf(&quot;This is line %d.\\n&quot;, __LINE__); printf(&quot;This function is %s\\n&quot;, __func__); why_me(); return 0;&#125;void why_me()&#123; printf(&quot;This function is %s\\n&quot;, __func__); printf(&quot;This is line %d.\\n&quot;, __LINE__);&#125; #line和#error#line指令重置__LINE__和__FILE__宏报告的行号和文件名。 12#line 1000 // 把当前行号重置为1000#line 10 &quot;cool.c&quot; // 把行号重置为10，把文件名重置为cool.c #error指令让预处理器发出一条错误消息，该消息包含指令中的文本。如果可能的话，编译过程应该中断。 123456// newish.c文件...#if __STDC_VERSION__ != 201112L #error Not C11#endif... 编译以上代码生成后，输出如下： 1234$ gcc newish.cnewish.c:14:2: error: #error Not C11$ gcc -std=c11 newish.c$ 如果编译器只支持旧标准，则会编译失败，如果支持C11标准，就能成功编译。 #pragma在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些设置。#pragma把编译器指令放入源代码中。 例如，在开发C99时，标准被称为C9X，可以使用下面的编译指示（pragma）让编译器支持C9X： 1#pragma c9x on 一般而言，编译器都有自己的编译指示集。例如，编译指示可能用于控制分配给自动变量的内存量，或者设置错误检查的严格程度，或者启用非标准语言特性等。 C99还提供_Pragma预处理器运算符，该运算符把字符串转换成普通的编译指示。 1_Pragma(&quot;nonstandardtreatmenttypeB on&quot;) 等价于： 1#pragma nonstandardtreatmenttypeB on 由于该运算符不使用#符号，所以可以把它作为宏展开的一部分： 12#define PRAGMA(X) _Pragma(#X)#define LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X) 泛型选择（C11）在程序设计中，泛型编程（generic programming）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。 C++在模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代码。C没有这种功能。C11新增了一种表达式，叫作泛型选择表达式（generic selection expression），可根据表达式的类型（即表达式的类型是int、double 还是其他类型）选择一个值。 1_Generic(x, int: 0, float: 1, double: 2, default: 3) _Generic是C11的关键字。_Generic后面的圆括号中包含多个用逗号分隔的项。第1个项是一个表达式，后面的每个项都由一个类型、一个冒号和一个值组成，如float: 1。如果x的类型匹配是float:标签，那么整个表达式的值就是1。 下面的例子为：对泛型选择表达式求值得字符串。 123456#define MYTYPE(X) _Generic((X),\\int: &quot;int&quot;,\\float : &quot;float&quot;,\\double: &quot;double&quot;,\\default: &quot;other&quot;\\) 内联函数通常，函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回。使用宏使代码内联，可以避免这样的开销。C99还提供另一种方法：内联函数（inline function）。 其实C99和C11标准中叙述的是：“把函数变成内联函数建议尽可能快地调用该函数，其具体效果由实现定义”。因此，把函数变成内联函数，编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。 标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。因此，最简单的方法是使用函数说明符 inline 和存储类别说明符static。 123456789101112#include &lt;stdio.h&gt;inline static void eatline() // 内联函数定义/原型&#123; while (getchar() != &#x27;\\n&#x27;) continue;&#125;int main()&#123; //... eatline(); // 函数调用 //...&#125; 编译器查看内联函数的定义（也是原型），可能会用函数体中的代码替换 eatline()函数调用。也就是说，效果相当于在函数调用的位置输入函数体中的代码： 12345678910111213#include &lt;stdio.h&gt;inline static void eatline() // 内联函数定义/原型&#123; while (getchar() != &#x27;\\n&#x27;) continue;&#125;int main()&#123; //... while (getchar() != &#x27;\\n&#x27;) continue; //...&#125; 由于并未给内联函数预留单独的代码块，所以无法获得内联函数的地址（实际上可以获得地址，不过这样做之后，编译器会生成一个非内联函数）。另外，内联函数无法在调试器中显示。 编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。鉴于此，一般情况下内联函数都具有内部链接。因此，如果程序有多个文件都要使用某个内联函数，那么这些文件中都必须包含该内联函数的定义。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。 123456789// eatline.h#ifndef EATLINE_H_#define EATLINE_H_inline static void eatline()&#123; while (getchar() != &#x27;\\n&#x27;) continue;&#125;#endif 一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。 _Noreturn函数（C11）C99新增inline关键字时，它是唯一的函数说明符（关键字extern和static是存储类别说明符，可应用于数据对象和函数）。 C11新增了第2个函数说明符_Noreturn，表明调用完成后函数不返回主调函数。 exit()函数是_Noreturn函数的一个示例，一旦调用exit()，它不会再返回主调函数。void类型的函数在执行完毕后返回主调函数，只是它不提供返回值。 C库使用库表述C99&#x2F;C11标准提供了下面的描述： 12#include &lt;stdio.h&gt;size_t fread(void * restrict ptr, size_t size,size_t nmemb, FILE * restrict stream); size_t 类型被定义为 sizeof 运算符的返回值类型——无符号整数类型，通常是unsignedint或unsigned long。stddef.h文件中包含了size_t类型的typedef或#define定义。其他文件（包括stdio.h）通过包含stddef.h来包含这个定义。许多函数（包括fread()）的实际参数中都要使用sizeof运算符，形式参数的size_t类型中正好匹配这种常见的情况。 restrict关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。 数学库#include &lt;math.h&gt;#include &lt;math.h&gt; 利用C11新增的泛型选择表达式_Generic定义一个泛型宏，根据参数类型选择最合适的数学函数版本。 1234567// 泛型平方根函数#define SQRT(X) _Generic((X),\\long double: sqrtl, \\default: sqrt, \\float: sqrtf)(X)long double y = SQRT(x); &lt;tgmath.h&gt;定义 sqrt()宏展开为sqrtf()、sqrt()或 sqrtl()函数。 通用工具库rand()、srand()、malloc()和free()函数。在ANSI C标准中，这些函数的原型都在&lt;stdlib.h&gt;头文件中。 exit()和atexit()函数在main()返回系统时将自动调用exit()函数。 atexit()函数通过退出时注册被调用的函数提供这种功能，atexit()函数接受一个函数指针作为参数。 123456789101112131415161718192021222324252627282930/* byebye.c -- atexit()示例 */#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void sign_off(void);void too_bad(void);int main(void)&#123; int n; atexit(sign_off); /* 注册 sign_off()函数 */ puts(&quot;Enter an integer:&quot;); if (scanf(&quot;%d&quot;, &amp;n) != 1) &#123; puts(&quot;That&#x27;s no integer!&quot;); atexit(too_bad); /* 注册 too_bad()函数 */ exit(EXIT_FAILURE); &#125; printf(&quot;%d is %s.\\n&quot;, n, (n % 2 == 0) ? &quot;even&quot; : &quot;odd&quot;); return 0;&#125;void sign_off(void)&#123; puts(&quot;Thus terminates another magnificent program from&quot;); puts(&quot;SeeSaw Software!&quot;);&#125;void too_bad(void)&#123; puts(&quot;SeeSaw Software extends its heartfelt condolences&quot;); puts(&quot;to you upon the failure of your program.&quot;);&#125; 如果在IDE中运行，可能看不到最后4行。 atexit()函数的用法 这个函数使用函数指针。要使用 atexit()函数，只需把退出时要调用的函数地址传递给 atexit()即可。函数名作为函数参数时相当于该函数的地址，所以该程序中把sign_off或too_bad作为参数。然后，atexit()注册函数列表中的函数，当调用exit()时就会执行这些函数。ANSI保证，在这个列表中至少可以放 32 个函数。最后调用 exit()函数时，exit()会执行这些函数（执行顺序与列表中的函数顺序相反，即最后添加的函数最先执行）。 exit()函数的用法 exit()执行完atexit()指定的函数后，会完成一些清理工作：刷新所有输出流、关闭所有打开的流和关闭由标准I&#x2F;O函数tmpfile()创建的临时文件。然后exit()把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。在main()以外的函数中使用exit()也会终止整个程序。 qsort()函数对较大型的数组而言，“快速排序”方法是最有效的排序算法之一。 它把数组不断分成更小的数组，直到变成单元素数组。首先，把数组分成两部分，一部分的值都小于另一部分的值。这个过程一直持续到数组完全排序好为止。 1void qsort(void* base, size_t nmemb, size_t size, int (*compar)(const void*, const void*)); 第1个参数是指针，指向待排序数组的首元素。ANSI C允许把指向任何数据类型的指针强制转换成指向void的指针，因此，qsort()的第1个实际参数可以引用任何类型的数组。 第2个参数是待排序项的数量。函数原型把该值转换为size_t类型。前面提到过，size_t定义在标准头文件中，是sizeof运算符返回的整数类型。 由于qsort()把第1个参数转换为void指针，所以qsort()不知道数组中每个元素的大小。为此，函数原型用第 3 个参数补偿这一信息，显式指明待排序数组中每个元素的大小。例如，如果排序 double类型的数组，那么第3个参数应该是sizeof(double)。 最后，qsort()还需要一个指向函数的指针，这个被指针指向的比较函数用于确定排序的顺序。该函数应接受两个参数：分别指向待比较两项的指针。如果第1项的值大于第2项，比较函数则返回正数；如果两项相同，则返回0；如果第1项的值小于第2项，则返回负数。qsort()根据给定的其他信息计算出两个指针的值，然后把它们传递给比较函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* qsorter.c -- 用 qsort()排序一组数字 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUM 40void fillarray(double ar[], int n);void showarray(const double ar[], int n);int mycomp(const void* p1, const void* p2);int main(void)&#123; double vals[NUM]; fillarray(vals, NUM); puts(&quot;Random list:&quot;); showarray(vals, NUM); qsort(vals, NUM, sizeof(double), mycomp); puts(&quot;\\nSorted list:&quot;); showarray(vals, NUM); return 0;&#125;void fillarray(double ar[], int n)&#123; int index; for (index = 0; index &lt; n; index++) ar[index] = (double)rand() / ((double)rand() + 0.1);&#125;void showarray(const double ar[], int n)&#123; int index; for (index = 0; index &lt; n; index++) &#123; printf(&quot;%9.4f &quot;, ar[index]); if (index % 6 == 5) putchar(&#x27;\\n&#x27;); &#125; if (index % 6 != 0) putchar(&#x27;\\n&#x27;);&#125;/* 按从小到大的顺序排序 */int mycomp(const void* p1, const void* p2)&#123; /* 要使用指向double的指针来访问这两个值 */ const double* a1 = (const double*)p1; const double* a2 = (const double*)p2; if (*a1 &lt; *a2) return -1; else if (*a1 == *a2) return 0; else return 1;&#125; string.h库中的memcpy()和 memmove()不能把一个数组赋给另一个数组，所以要通过循环把数组中的每个元素赋给另一个数组相应的元素。有一个例外的情况是：使用strcpy()和strncpy()函数来处理字符数组。memcpy()和memmove()函数提供类似的方法处理任意类型的数组。 12void *memcpy(void * restrict s1, const void * restrict s2, size_t n);void *memmove(void *s1, const void *s2, size_t n); 这两个函数都从 s2 指向的位置拷贝 n 字节到 s1 指向的位置，而且都返回 s1 的值。 所不同的是， memcpy()的参数带关键字restrict，即memcpy()假设两个内存区域之间没有重叠；而memmove()不作这样的假设，所以拷贝过程类似于先把所有字节拷贝到一个临时缓冲区，然后再拷贝到最终目的地。 可变参数：stdarg.h12345678910111213141516171819202122232425//varargs.c -- use variable number of arguments#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;double sum(int, ...);int main(void)&#123; double s, t; s = sum(3, 1.1, 2.5, 13.3); t = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1); printf(&quot;return value for &quot; &quot;sum(3, 1.1, 2.5, 13.3): %g\\n&quot;, s); printf(&quot;return value for &quot; &quot;sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): %g\\n&quot;, t); return 0;&#125;double sum(int lim, ...)&#123; va_list ap; // 声明一个对象储存参数 double tot = 0; va_start(ap, lim); // 把ap初始化为参数列表 for (int i = 0; i &lt; lim; i++) tot += va_arg(ap, double); // 访问参数列表中的每一项 va_end(ap); // 清理工作 return tot;&#125; 高级数据表示从数组到链表使用数组分配内存空间： 一种方法是调用malloc()一次，为5个movies结构请求分配足够的空间；另一种方法是调用malloc()5次，分别为每个movies结构请求分配足够的空间。 如果用不完500个指针，这种方法节约了大量的内存，因为内含500个指针的数组比内含500个结构的数组所占的内存少得多。尽管如此，如果用不到 500 个指针，还是浪费了不少空间。而且，这样还是有500个结构的限制。 还有一种更好的方法。每次使用 malloc()为新结构分配空间时，也为新指针分配空间。但是，还得需要另一个指针来跟踪新分配的指针，用于跟踪新指针的指针本身，也需要一个指针来跟踪，以此类推。要重新定义结构才能解决这个潜在的问题，即每个结构中包含指向 next 结构的指针。 123456#define TSIZE 45 /* 储存片名的数组大小*/struct film &#123; char title[TSIZE]; int rating; struct film* next;&#125;; 虽然结构不能含有与本身类型相同的结构，但是可以含有指向同类型结构的指针。这种定义是定义链表（linked list）的基础，链表中的每一项都包含着在何处能找到下一项的信息。 假设要显示这个链表，每显示一项，就可以根据该项中已储存的地址来定位下一个待显示的项。然而，这种方案能正常运行，还需要一个指针储存链表中第1项的地址，因为链表中没有其他项储存该项的地址。此时，头指针就派上了用场。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* films2.c -- 使用结构链表 */#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* 提供malloc()原型 */#include &lt;string.h&gt; /* 提供strcpy()原型 */#define TSIZE 45 /* 储存片名的数组大小 */struct film &#123; char title[TSIZE]; int rating; struct film* next; /* 指向链表中的下一个结构 */&#125;;char* s_gets(char* st, int n);int main(void)&#123; struct film* head = NULL; struct film* prev = NULL, * current; char input[TSIZE]; /* 收集并储存信息 */ puts(&quot;Enter first movie title:&quot;); while (s_gets(input, TSIZE) != NULL &amp;&amp; input[0] != &#x27;\\0&#x27;) &#123; current = (struct film*)malloc(sizeof(struct film)); if (head == NULL) /* 第1个结构 */ head = current; else /* 后续的结构 */ prev-&gt;next = current; current-&gt;next = NULL; strcpy(current-&gt;title, input); puts(&quot;Enter your rating &lt;0-10&gt;:&quot;); scanf(&quot;%d&quot;, &amp;current-&gt;rating); while (getchar() != &#x27;\\n&#x27;) continue; puts(&quot;Enter next movie title (empty line to stop):&quot;); prev = current; &#125; /* 显示电影列表 */ if (head == NULL) printf(&quot;No data entered. &quot;); else printf(&quot;Here is the movie list:\\n&quot;); current = head; while (current != NULL) &#123; printf(&quot;Movie: %s Rating: %d\\n&quot;, current-&gt;title, current-&gt;rating); current = current-&gt;next; &#125; /* 完成任务，释放已分配的内存 */ for (current = head; current != NULL; current = current-&gt;next) &#123; free(current); printf(&quot;free\\n&quot;); &#125; printf(&quot;Bye!\\n&quot;); return 0;&#125;char* s_gets(char* st, int n)&#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = &#x27;\\0&#x27;; // 在此处放置一个空字符 else while (getchar() != &#x27;\\n&#x27;) continue; // 处理剩余输入行 &#125; return ret_val;&#125; 抽象数据类型（ADT）计算机科学领域已开发了一种定义新类型的好方法，用3个步骤完成从抽象到具体的过程。 提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实现，也不能依赖特定的编程语言。这种正式的抽象描述被称为抽象数据类型（ADT）。 开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执行所需操作的函数。例如在 C中，可以提供结构定义和操控该结构的函数原型。这些作用于用户定义类型的函数相当于作用于 C基本类型的内置运算符。需要使用该新类型的程序员可以使用这个接口进行编程。 编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无需了解具体的实现细节。 链表的ADT： 类型名： 简单链表类型属性： 可以储存一系列项类型操作： 初始化链表为空确定链表为空确定链表已满确定链表中的项数在链表末尾添加项遍历链表，处理链表中的项清空链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* list.h -- 简单链表类型的头文件 */#ifndef LIST_H_#define LIST_H_#include &lt;stdbool.h&gt; /* C99特性 *//* 特定程序的声明 */#define TSIZE 45 /* 储存电影名的数组大小 */struct film&#123; char title[TSIZE]; int rating;&#125;;/* 一般类型定义 */typedef struct film Item;typedef struct node&#123; Item item; struct node* next;&#125; Node;typedef Node* List;/* 函数原型 *//* 操作： 初始化一个链表 *//* 前提条件： plist指向一个链表 *//* 后置条件： 链表初始化为空 */void InitializeList(List* plist);/* 操作： 确定链表是否为空定义，plist指向一个已初始化的链表 *//* 后置条件： 如果链表为空，该函数返回true；否则返回false */bool ListIsEmpty(const List* plist);/* 操作： 确定链表是否已满，plist指向一个已初始化的链表 *//* 后置条件： 如果链表已满，该函数返回真；否则返回假 */bool ListIsFull(const List* plist);/* 操作： 确定链表中的项数, plist指向一个已初始化的链表 *//* 后置条件： 该函数返回链表中的项数 */unsigned int ListItemCount(const List* plist);/* 操作： 在链表的末尾添加项 *//* 前提条件： item是一个待添加至链表的项, plist指向一个已初始化的链表 *//* 后置条件： 如果可以，该函数在链表末尾添加一个项，且返回true；否则返回false */bool AddItem(Item item, List* plist);/* 操作： 把函数作用于链表中的每一项 *//* plist指向一个已初始化的链表 *//* pfun指向一个函数，该函数接受一个Item类型的参数，且无返回值 *//* 后置条件： pfun指向的函数作用于链表中的每一项一次 */void Traverse(const List* plist, void(*pfun)(Item item));/* 操作： 释放已分配的内存（如果有的话） *//* plist指向一个已初始化的链表 *//* 后置条件： 释放了为链表分配的所有内存，链表设置为空 */void EmptyTheList(List* plist);#endif 接口函数的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* list.c -- 支持链表操作的函数 */#include &lt; stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;list.h&quot;/* 局部函数原型 */static void CopyToNode(Item item, Node * pnode);/* 接口函数 *//* 把链表设置为空 */void InitializeList(List* plist)&#123; *plist = NULL;&#125;/* 如果链表为空，返回true */bool ListIsEmpty(const List* plist)&#123; if (*plist == NULL) return true; else return false;&#125;/* 如果链表已满，返回true */bool ListIsFull(const List* plist)&#123; Node* pt; bool full; pt = (Node*)malloc(sizeof(Node)); if (pt == NULL) full = true; else full = false; free(pt); return full;&#125;/* 返回节点的数量 */unsigned int ListItemCount(const List* plist)&#123; unsigned int count = 0; Node* pnode = *plist; /* 设置链表的开始 */ while (pnode != NULL) &#123; ++count; pnode = pnode-&gt;next; /* 设置下一个节点 */ &#125; return count;&#125;/* 创建储存项的节点，并将其添加至由plist指向的链表末尾（较慢的实现） */bool AddItem(Item item, List* plist)&#123; Node* pnew; Node* scan = *plist; pnew = (Node*)malloc(sizeof(Node)); if (pnew == NULL) return false; /* 失败时退出函数 */ CopyToNode(item, pnew); pnew-&gt;next = NULL; if (scan == NULL) /* 空链表，所以把 */ *plist = pnew; /* pnew放在链表的开头 */ else &#123; while (scan-&gt;next != NULL) scan = scan-&gt;next; /* 找到链表的末尾 */ scan-&gt;next = pnew; /* 把pnew添加到链表的末尾 */ &#125; return true;&#125;/* 访问每个节点并执行pfun指向的函数 */void Traverse(const List* plist, void(*pfun)(Item item))&#123; Node* pnode = *plist; /* 设置链表的开始 */ while (pnode != NULL) &#123; (*pfun)(pnode-&gt;item); /* 把函数应用于链表中的项 */ pnode = pnode-&gt;next; /* 前进到下一项 */ &#125;&#125;/* 释放由malloc()分配的内存 *//* 设置链表指针为NULL */void EmptyTheList(List* plist)&#123; Node* psave; while (*plist != NULL) &#123; psave = (*plist)-&gt;next; /* 保存下一个节点的地址 */ free(*plist); /* 释放当前节点 */ *plist = psave; /* 前进至下一个节点 */ &#125;&#125;/* 局部函数定义 *//* 把一个项拷贝到节点中 */static void CopyToNode(Item item, Node* pnode)&#123; pnode-&gt;item = item; /* 拷贝结构 */&#125; 使用接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* films3.c -- 使用抽象数据类型（ADT）风格的链表 *//* 与list.c一起编译 */#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* 提供exit()的原型 */#include &quot;list.h&quot; /* 定义List、Item */void showmovies(Item item);char* s_gets(char* st, int n);int main(void)&#123; List movies; Item temp; /* 初始化 */ InitializeList(&amp;movies); if (ListIsFull(&amp;movies)) &#123; fprintf(stderr, &quot;No memory available! Bye!\\n&quot;); exit(1); &#125; /* 获取用户输入并储存 */ puts(&quot;Enter first movie title:&quot;); while (s_gets(temp.title, TSIZE) != NULL &amp;&amp; temp.title[0] != &#x27;\\0&#x27;) &#123; puts(&quot;Enter your rating &lt;0-10&gt;:&quot;); scanf(&quot;%d&quot;, &amp;temp.rating); while (getchar() != &#x27;\\n&#x27;) continue; if (AddItem(temp, &amp;movies) == false) &#123; fprintf(stderr, &quot;Problem allocating memory\\n&quot;); break; &#125; if (ListIsFull(&amp;movies)) &#123; puts(&quot;The list is now full.&quot;); break; &#125; puts(&quot;Enter next movie title (empty line to stop):&quot;); &#125; /* 显示 */ if (ListIsEmpty(&amp;movies)) printf(&quot;No data entered. &quot;); else &#123; printf(&quot;Here is the movie list:\\n&quot;); Traverse(&amp;movies, showmovies); &#125; printf(&quot;You entered %d movies.\\n&quot;, ListItemCount(&amp;movies)); /* 清理 */ EmptyTheList(&amp;movies); printf(&quot;Bye!\\n&quot;); return 0;&#125;void showmovies(Item item)&#123; printf(&quot;Movie: %s Rating: %d\\n&quot;, item.title, item.rating);&#125;char* s_gets(char* st, int n)&#123; char* ret_val; char* find; ret_val = fgets(st, n, stdin); if (ret_val) &#123; find = strchr(st, &#x27;\\n&#x27;); // 查找换行符 if (find) // 如果地址不是NULL， *find = &#x27;\\0&#x27;; // 在此处放置一个空字符 else while (getchar() != &#x27;\\n&#x27;) continue; // 处理输入行的剩余内容 &#125; return ret_val;&#125; 队列队列是一种“先进先出”（first in,first out，缩写为FIFO）的数据形式 123456789101112typedef int Item;typedef struct node&#123; Item item; struct node* next;&#125; Node;typedef struct queue&#123; Node* front; /* 指向队列首项的指针 */ Node* rear; /*指向队列尾项的指针*/ int items; /* 队列中的项数*/&#125; Queue; 链表和数组 二叉查找树 123456789101112typedef char* Item;typedef struct trnode&#123; Item item; struct trnode* left; struct trnode* right;&#125; Trnode;typedef struct tree&#123; Trnode* root; int size;&#125; Tree;","categories":[{"name":"编程技术","slug":"编程技术","permalink":"https://azreallem.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"note","slug":"note","permalink":"https://azreallem.github.io/tags/note/"},{"name":"C","slug":"C","permalink":"https://azreallem.github.io/tags/C/"},{"name":"book","slug":"book","permalink":"https://azreallem.github.io/tags/book/"}]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2021-07-15T15:09:16.000Z","updated":"2022-03-29T15:17:28.000Z","comments":true,"path":"2021/07/15/Hexo搭建个人博客/","link":"","permalink":"https://azreallem.github.io/2021/07/15/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"前提准备 安装了Git for windows 配置了GitHub_Settings_keys 在github中新建一个名为username.github.io的仓库 安装node.js进入Node官网，安装node.js，打开cmd输入以下命令行： 123456# 验证版本信息node -vnpm -v# 该命令完成hexo的安装npm install -g hexo-cli 配置hexohttps://hexo.io/zh-cn/docs/ 123hexo init # 该命令完成hexo在本地博客目录的初始化hexo g # 生成静态文件hexo s # 开启本地预览 配置GitHub配置站点配置文件hexo 有2种 _config.yml文件，一个是根目录下的全局的 _config.yml，一个是各个主题 theme 下的 _config.yml。将前者称为站点配置文件， 后者称为主题配置文件。 打开根目录下站点配置文件 _config.yml，配置有关 deploy 的部分： 部署到Github123npm install hexo-deployer-git --save # 安装部署插件hexo d # 该命令行必须使用git bash 网址： https://azreallem.github.io/ 能够正常访问即部署成功。 Hexo博客基本配置更改主题https://github.com/theme-next/hexo-theme-next 12345git clone https://github.com/theme-next/hexo-theme-next themes/next# updatecd themes/nextgit pull 启用主题，打开站点配置文件 _config.yml， 找到 theme 字段，并更改为 next，如下： 打开主题配置文件：themes\\next_config.yml，找到 scheme 字段，并更改为 Gemini，如下： 上传到github1234hexo clean # 清除缓存hexo g # 生成hexo s # serverhexo d # 部署 其他主题https://github.com/Candinya/Kratos-Rebirth/ 1git clone [https://github.com/Candinya/Kratos-Rebirth/](https://github.com/Candinya/Kratos-Rebirth/) themes/kratos-rebirth hexo常用命令123456789101112131415161718192021222324252627282930313233hexo new “postName” # 新建文章hexo clean # 清除缓存hexo generate # 生成静态页面至 public 目录hexo server # 开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server）hexo deploy # 部署到 GitHubhexo help # 查看帮助hexo version # 查看 Hexo 的版本# hexo常用命令## 常见命令 1. hexo new “postName” # 新建文章 2. hexo clean # 清除缓存 3. hexo generate # 生成静态页面至 public 目录 4. hexo server # 开启预览访问端口（默认端口 4000，’ctrl + c’关闭 server） 5. hexo deploy # 部署到 GitHub 6. hexo help # 查看帮助 7. hexo version # 查看 Hexo 的版本# 缩写 1. hexo n == hexo new 2. hexo g == hexo generate 3. hexo s == hexo server 4. hexo d == hexo deploy# 组合命令 1. hexo s -g # 生成并本地预览 2. hexo d -g # 生成并上传# 文章保存为草稿 1. 建立文章草稿 hexo new draft &lt;title&gt; 2. 本机预览草稿 hexo s --draft 3. 将草稿发布为正式文章hexo p &lt;filename&gt; 参考教程https://mumaxu.github.io/2018/12/09/GitHub-Hexo-从零开始搭建个人博客/ https://candinya.com/posts/Kratos-Rebirth-Manual/#Top-Menu-顶部导航栏相关","categories":[{"name":"教程文档","slug":"教程文档","permalink":"https://azreallem.github.io/categories/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://azreallem.github.io/tags/hexo/"}]}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://azreallem.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"编程技术","slug":"编程技术","permalink":"https://azreallem.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"随手笔记","slug":"随手笔记","permalink":"https://azreallem.github.io/categories/%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0/"},{"name":"内核分析","slug":"内核分析","permalink":"https://azreallem.github.io/categories/%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"},{"name":"教程文档","slug":"教程文档","permalink":"https://azreallem.github.io/categories/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"link","slug":"link","permalink":"https://azreallem.github.io/tags/link/"},{"name":"OS","slug":"OS","permalink":"https://azreallem.github.io/tags/OS/"},{"name":"note","slug":"note","permalink":"https://azreallem.github.io/tags/note/"},{"name":"book","slug":"book","permalink":"https://azreallem.github.io/tags/book/"},{"name":"Linux","slug":"Linux","permalink":"https://azreallem.github.io/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://azreallem.github.io/tags/shell/"},{"name":"quckily-note","slug":"quckily-note","permalink":"https://azreallem.github.io/tags/quckily-note/"},{"name":"algorithm","slug":"algorithm","permalink":"https://azreallem.github.io/tags/algorithm/"},{"name":"c++","slug":"c","permalink":"https://azreallem.github.io/tags/c/"},{"name":"combine","slug":"combine","permalink":"https://azreallem.github.io/tags/combine/"},{"name":"backtracking","slug":"backtracking","permalink":"https://azreallem.github.io/tags/backtracking/"},{"name":"linux","slug":"linux","permalink":"https://azreallem.github.io/tags/linux/"},{"name":"source code","slug":"source-code","permalink":"https://azreallem.github.io/tags/source-code/"},{"name":"iproute2","slug":"iproute2","permalink":"https://azreallem.github.io/tags/iproute2/"},{"name":"setup_arch","slug":"setup-arch","permalink":"https://azreallem.github.io/tags/setup-arch/"},{"name":"start_kernel","slug":"start-kernel","permalink":"https://azreallem.github.io/tags/start-kernel/"},{"name":"FSM","slug":"FSM","permalink":"https://azreallem.github.io/tags/FSM/"},{"name":"tlbex","slug":"tlbex","permalink":"https://azreallem.github.io/tags/tlbex/"},{"name":"technique","slug":"technique","permalink":"https://azreallem.github.io/tags/technique/"},{"name":"C","slug":"C","permalink":"https://azreallem.github.io/tags/C/"},{"name":"hexo","slug":"hexo","permalink":"https://azreallem.github.io/tags/hexo/"}]}